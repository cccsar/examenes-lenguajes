        -:    0:Source:catch_amalgamated.cpp
        -:    0:Graph:test.gcno
        -:    0:Data:test.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://              Copyright Catch2 Authors
        -:    2:// Distributed under the Boost Software License, Version 1.0.
        -:    3://   (See accompanying file LICENSE_1_0.txt or copy at
        -:    4://        https://www.boost.org/LICENSE_1_0.txt)
        -:    5:
        -:    6:// SPDX-License-Identifier: BSL-1.0
        -:    7:
        -:    8://  Catch v3.0.0-preview.3
        -:    9://  Generated: 2020-10-08 13:59:26.616931
        -:   10://  ----------------------------------------------------------
        -:   11://  This file is an amalgamation of multiple different files.
        -:   12://  You probably shouldn't edit it directly.
        -:   13://  ----------------------------------------------------------
        -:   14:
        -:   15:#include "catch_amalgamated.hpp"
        -:   16:
        -:   17:
        -:   18:// Adapted from donated nonius code.
        -:   19:
        -:   20:
        -:   21:
        -:   22:#include <cassert>
        -:   23:#include <iterator>
        -:   24:#include <random>
        -:   25:
        -:   26:
        -:   27:#if defined(CATCH_CONFIG_USE_ASYNC)
        -:   28:#include <future>
        -:   29:#endif
        -:   30:
        -:   31:namespace {
        -:   32:
        -:   33:using Catch::Benchmark::Detail::sample;
        -:   34:
        -:   35:     template <typename URng, typename Estimator>
    #####:   36:     sample resample(URng& rng, int resamples, std::vector<double>::iterator first, std::vector<double>::iterator last, Estimator& estimator) {
        -:   37:         auto n = last - first;
    #####:   38:         std::uniform_int_distribution<decltype(n)> dist(0, n - 1);
        -:   39:
        -:   40:         sample out;
    #####:   41:         out.reserve(resamples);
    #####:   42:         std::generate_n(std::back_inserter(out), resamples, [n, first, &estimator, &dist, &rng] {
        -:   43:             std::vector<double> resampled;
    #####:   44:             resampled.reserve(n);
    #####:   45:             std::generate_n(std::back_inserter(resampled), n, [first, &dist, &rng] { return first[dist(rng)]; });
    #####:   46:             return estimator(resampled.begin(), resampled.end());
        -:   47:         });
        -:   48:         std::sort(out.begin(), out.end());
    #####:   49:         return out;
        -:   50:     }
        -:   51:
        -:   52:
    #####:   53:    double erf_inv(double x) {
        -:   54:        // Code accompanying the article "Approximating the erfinv function" in GPU Computing Gems, Volume 2
        -:   55:        double w, p;
        -:   56:
    #####:   57:        w = -log((1.0 - x) * (1.0 + x));
        -:   58:
    #####:   59:        if (w < 6.250000) {
    #####:   60:            w = w - 3.125000;
        -:   61:            p = -3.6444120640178196996e-21;
    #####:   62:            p = -1.685059138182016589e-19 + p * w;
    #####:   63:            p = 1.2858480715256400167e-18 + p * w;
    #####:   64:            p = 1.115787767802518096e-17 + p * w;
    #####:   65:            p = -1.333171662854620906e-16 + p * w;
    #####:   66:            p = 2.0972767875968561637e-17 + p * w;
    #####:   67:            p = 6.6376381343583238325e-15 + p * w;
    #####:   68:            p = -4.0545662729752068639e-14 + p * w;
    #####:   69:            p = -8.1519341976054721522e-14 + p * w;
    #####:   70:            p = 2.6335093153082322977e-12 + p * w;
    #####:   71:            p = -1.2975133253453532498e-11 + p * w;
    #####:   72:            p = -5.4154120542946279317e-11 + p * w;
    #####:   73:            p = 1.051212273321532285e-09 + p * w;
    #####:   74:            p = -4.1126339803469836976e-09 + p * w;
    #####:   75:            p = -2.9070369957882005086e-08 + p * w;
    #####:   76:            p = 4.2347877827932403518e-07 + p * w;
    #####:   77:            p = -1.3654692000834678645e-06 + p * w;
    #####:   78:            p = -1.3882523362786468719e-05 + p * w;
    #####:   79:            p = 0.0001867342080340571352 + p * w;
    #####:   80:            p = -0.00074070253416626697512 + p * w;
    #####:   81:            p = -0.0060336708714301490533 + p * w;
    #####:   82:            p = 0.24015818242558961693 + p * w;
    #####:   83:            p = 1.6536545626831027356 + p * w;
    #####:   84:        } else if (w < 16.000000) {
    #####:   85:            w = sqrt(w) - 3.250000;
        -:   86:            p = 2.2137376921775787049e-09;
    #####:   87:            p = 9.0756561938885390979e-08 + p * w;
    #####:   88:            p = -2.7517406297064545428e-07 + p * w;
    #####:   89:            p = 1.8239629214389227755e-08 + p * w;
    #####:   90:            p = 1.5027403968909827627e-06 + p * w;
    #####:   91:            p = -4.013867526981545969e-06 + p * w;
    #####:   92:            p = 2.9234449089955446044e-06 + p * w;
    #####:   93:            p = 1.2475304481671778723e-05 + p * w;
    #####:   94:            p = -4.7318229009055733981e-05 + p * w;
    #####:   95:            p = 6.8284851459573175448e-05 + p * w;
    #####:   96:            p = 2.4031110387097893999e-05 + p * w;
    #####:   97:            p = -0.0003550375203628474796 + p * w;
    #####:   98:            p = 0.00095328937973738049703 + p * w;
    #####:   99:            p = -0.0016882755560235047313 + p * w;
    #####:  100:            p = 0.0024914420961078508066 + p * w;
    #####:  101:            p = -0.0037512085075692412107 + p * w;
    #####:  102:            p = 0.005370914553590063617 + p * w;
    #####:  103:            p = 1.0052589676941592334 + p * w;
    #####:  104:            p = 3.0838856104922207635 + p * w;
        -:  105:        } else {
    #####:  106:            w = sqrt(w) - 5.000000;
        -:  107:            p = -2.7109920616438573243e-11;
    #####:  108:            p = -2.5556418169965252055e-10 + p * w;
    #####:  109:            p = 1.5076572693500548083e-09 + p * w;
    #####:  110:            p = -3.7894654401267369937e-09 + p * w;
    #####:  111:            p = 7.6157012080783393804e-09 + p * w;
    #####:  112:            p = -1.4960026627149240478e-08 + p * w;
    #####:  113:            p = 2.9147953450901080826e-08 + p * w;
    #####:  114:            p = -6.7711997758452339498e-08 + p * w;
    #####:  115:            p = 2.2900482228026654717e-07 + p * w;
    #####:  116:            p = -9.9298272942317002539e-07 + p * w;
    #####:  117:            p = 4.5260625972231537039e-06 + p * w;
    #####:  118:            p = -1.9681778105531670567e-05 + p * w;
    #####:  119:            p = 7.5995277030017761139e-05 + p * w;
    #####:  120:            p = -0.00021503011930044477347 + p * w;
    #####:  121:            p = -0.00013871931833623122026 + p * w;
    #####:  122:            p = 1.0103004648645343977 + p * w;
    #####:  123:            p = 4.8499064014085844221 + p * w;
        -:  124:        }
    #####:  125:        return p * x;
        -:  126:    }
        -:  127:
    #####:  128:    double standard_deviation(std::vector<double>::iterator first, std::vector<double>::iterator last) {
        -:  129:        auto m = Catch::Benchmark::Detail::mean(first, last);
        -:  130:        double variance = std::accumulate(first, last, 0., [m](double a, double b) {
    #####:  131:            double diff = b - m;
    #####:  132:            return a + diff * diff;
    #####:  133:            }) / (last - first);
    #####:  134:            return std::sqrt(variance);
        -:  135:    }
        -:  136:
        -:  137:}
        -:  138:
        -:  139:namespace Catch {
        -:  140:    namespace Benchmark {
        -:  141:        namespace Detail {
        -:  142:
    #####:  143:            double weighted_average_quantile(int k, int q, std::vector<double>::iterator first, std::vector<double>::iterator last) {
        -:  144:                auto count = last - first;
    #####:  145:                double idx = (count - 1) * k / static_cast<double>(q);
    #####:  146:                int j = static_cast<int>(idx);
    #####:  147:                double g = idx - j;
    #####:  148:                std::nth_element(first, first + j, last);
    #####:  149:                auto xj = first[j];
    #####:  150:                if (g == 0) return xj;
        -:  151:
    #####:  152:                auto xj1 = *std::min_element(first + (j + 1), last);
    #####:  153:                return xj + g * (xj1 - xj);
        -:  154:            }
        -:  155:
        -:  156:
    #####:  157:            double erfc_inv(double x) {
    #####:  158:                return erf_inv(1.0 - x);
        -:  159:            }
        -:  160:
    #####:  161:            double normal_quantile(double p) {
        -:  162:                static const double ROOT_TWO = std::sqrt(2.0);
        -:  163:
        -:  164:                double result = 0.0;
    #####:  165:                assert(p >= 0 && p <= 1);
    #####:  166:                if (p < 0 || p > 1) {
        -:  167:                    return result;
        -:  168:                }
        -:  169:
    #####:  170:                result = -erfc_inv(2.0 * p);
        -:  171:                // result *= normal distribution standard deviation (1.0) * sqrt(2)
    #####:  172:                result *= /*sd * */ ROOT_TWO;
        -:  173:                // result += normal disttribution mean (0)
    #####:  174:                return result;
        -:  175:            }
        -:  176:
        -:  177:
    #####:  178:            double outlier_variance(Estimate<double> mean, Estimate<double> stddev, int n) {
    #####:  179:                double sb = stddev.point;
    #####:  180:                double mn = mean.point / n;
    #####:  181:                double mg_min = mn / 2.;
    #####:  182:                double sg = std::min(mg_min / 4., sb / std::sqrt(n));
    #####:  183:                double sg2 = sg * sg;
    #####:  184:                double sb2 = sb * sb;
        -:  185:
    #####:  186:                auto c_max = [n, mn, sb2, sg2](double x) -> double {
    #####:  187:                    double k = mn - x;
    #####:  188:                    double d = k * k;
    #####:  189:                    double nd = n * d;
    #####:  190:                    double k0 = -n * nd;
    #####:  191:                    double k1 = sb2 - n * sg2 + nd;
    #####:  192:                    double det = k1 * k1 - 4 * sg2 * k0;
    #####:  193:                    return (int)(-2. * k0 / (k1 + std::sqrt(det)));
    #####:  194:                };
        -:  195:
        -:  196:                auto var_out = [n, sb2, sg2](double c) {
    #####:  197:                    double nc = n - c;
    #####:  198:                    return (nc / n) * (sb2 - nc * sg2);
        -:  199:                };
        -:  200:
    #####:  201:                return std::min(var_out(1), var_out(std::min(c_max(0.), c_max(mg_min)))) / sb2;
        -:  202:            }
        -:  203:
        -:  204:
    #####:  205:            bootstrap_analysis analyse_samples(double confidence_level, int n_resamples, std::vector<double>::iterator first, std::vector<double>::iterator last) {
        -:  206:                CATCH_INTERNAL_START_WARNINGS_SUPPRESSION
        -:  207:                CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS
    #####:  208:                static std::random_device entropy;
        -:  209:                CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -:  210:
        -:  211:                auto n = static_cast<int>(last - first); // seriously, one can't use integral types without hell in C++
        -:  212:
        -:  213:                auto mean = &Detail::mean<std::vector<double>::iterator>;
        -:  214:                auto stddev = &standard_deviation;
        -:  215:
        -:  216:#if defined(CATCH_CONFIG_USE_ASYNC)
        -:  217:                auto Estimate = [=](double(*f)(std::vector<double>::iterator, std::vector<double>::iterator)) {
        -:  218:                    auto seed = entropy();
        -:  219:                    return std::async(std::launch::async, [=] {
        -:  220:                        std::mt19937 rng(seed);
        -:  221:                        auto resampled = resample(rng, n_resamples, first, last, f);
        -:  222:                        return bootstrap(confidence_level, first, last, resampled, f);
        -:  223:                    });
        -:  224:                };
        -:  225:
        -:  226:                auto mean_future = Estimate(mean);
        -:  227:                auto stddev_future = Estimate(stddev);
        -:  228:
        -:  229:                auto mean_estimate = mean_future.get();
        -:  230:                auto stddev_estimate = stddev_future.get();
        -:  231:#else
    #####:  232:                auto Estimate = [=](double(*f)(std::vector<double>::iterator, std::vector<double>::iterator)) {
        -:  233:                    auto seed = entropy();
        -:  234:                    std::mt19937 rng(seed);
    #####:  235:                    auto resampled = resample(rng, n_resamples, first, last, f);
    #####:  236:                    return bootstrap(confidence_level, first, last, resampled, f);
    #####:  237:                };
        -:  238:
    #####:  239:                auto mean_estimate = Estimate(mean);
    #####:  240:                auto stddev_estimate = Estimate(stddev);
        -:  241:#endif // CATCH_USE_ASYNC
        -:  242:
    #####:  243:                double outlier_variance = Detail::outlier_variance(mean_estimate, stddev_estimate, n);
        -:  244:
    #####:  245:                return { mean_estimate, stddev_estimate, outlier_variance };
        -:  246:            }
        -:  247:        } // namespace Detail
        -:  248:    } // namespace Benchmark
        -:  249:} // namespace Catch
        -:  250:
        -:  251:
        -:  252:/** \file
        -:  253: * This is a special TU that combines what would otherwise be a very
        -:  254: * small benchmarking-related TUs into one bigger TU.
        -:  255: *
        -:  256: * The reason for this is compilation performance improvements by
        -:  257: * avoiding reparsing headers for many small TUs, instead having this
        -:  258: * one TU include bit more, but having it all parsed only once.
        -:  259: *
        -:  260: * To avoid heavy-tail problem with compilation times, each "subpart"
        -:  261: * of Catch2 has its own combined TU like this.
        -:  262: */
        -:  263:
        -:  264:////////////////////////////////////////////
        -:  265:// vvv formerly catch_chronometer.cpp vvv //
        -:  266:////////////////////////////////////////////
        -:  267:
        -:  268:
        -:  269:namespace Catch {
        -:  270:    namespace Benchmark {
        -:  271:        namespace Detail {
        -:  272:            ChronometerConcept::~ChronometerConcept() = default;
        -:  273:        } // namespace Detail
        -:  274:    } // namespace Benchmark
        -:  275:} // namespace Catch
        -:  276:
        -:  277:
        -:  278:///////////////////////////////////////////////////
        -:  279:// vvv formerly catch_benchmark_function.cpp vvv //
        -:  280:///////////////////////////////////////////////////
        -:  281:
        -:  282:
        -:  283:namespace Catch {
        -:  284:    namespace Benchmark {
        -:  285:        namespace Detail {
        -:  286:            BenchmarkFunction::callable::~callable() = default;
        -:  287:            } // namespace Detail
        -:  288:    } // namespace Benchmark
        -:  289:} // namespace Catch
        -:  290:
        -:  291:
        -:  292:////////////////////////////////////////////////
        -:  293:// vvv formerly catch_complete_invoke.cpp vvv //
        -:  294:////////////////////////////////////////////////
        -:  295:
        -:  296:
        -:  297:namespace Catch {
        -:  298:    namespace Benchmark {
        -:  299:        namespace Detail {
        -:  300:            CATCH_INTERNAL_START_WARNINGS_SUPPRESSION
        -:  301:            CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS
        1:  302:            const std::string benchmarkErrorMsg = "a benchmark failed to run successfully";
        -:  303:            CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -:  304:        } // namespace Detail
        -:  305:    } // namespace Benchmark
        -:  306:} // namespace Catch
        -:  307:
        -:  308:
        -:  309:
        -:  310:
        -:  311://///////////////////////////////////////////////
        -:  312:// vvv formerly catch_run_for_at_least.cpp vvv //
        -:  313://///////////////////////////////////////////////
        -:  314:
        -:  315:#include <exception>
        -:  316:
        -:  317:namespace Catch {
        -:  318:    namespace Benchmark {
        -:  319:        namespace Detail {
    #####:  320:            struct optimized_away_error : std::exception {
        -:  321:                const char* what() const noexcept override;
        -:  322:            };
        -:  323:
    #####:  324:            const char* optimized_away_error::what() const noexcept {
    #####:  325:                return "could not measure benchmark, maybe it was optimized away";
        -:  326:            }
        -:  327:
    #####:  328:            void throw_optimized_away_error() {
    #####:  329:                Catch::throw_exception(optimized_away_error{});
        -:  330:            }
        -:  331:
        -:  332:        } // namespace Detail
        -:  333:    } // namespace Benchmark
        -:  334:} // namespace Catch
        -:  335:
        -:  336:
        -:  337:
        -:  338:#include <cmath>
        -:  339:#include <limits>
        -:  340:
        -:  341:namespace {
        -:  342:
        -:  343:// Performs equivalent check of std::fabs(lhs - rhs) <= margin
        -:  344:// But without the subtraction to allow for INFINITY in comparison
        -:  345:bool marginComparison(double lhs, double rhs, double margin) {
    #####:  346:    return (lhs + margin >= rhs) && (rhs + margin >= lhs);
        -:  347:}
        -:  348:
        -:  349:}
        -:  350:
        -:  351:namespace Catch {
        -:  352:
    #####:  353:    Approx::Approx ( double value )
        -:  354:    :   m_epsilon( std::numeric_limits<float>::epsilon()*100 ),
        -:  355:        m_margin( 0.0 ),
        -:  356:        m_scale( 0.0 ),
    #####:  357:        m_value( value )
    #####:  358:    {}
        -:  359:
    #####:  360:    Approx Approx::custom() {
    #####:  361:        return Approx( 0 );
        -:  362:    }
        -:  363:
    #####:  364:    Approx Approx::operator-() const {
    #####:  365:        auto temp(*this);
    #####:  366:        temp.m_value = -temp.m_value;
    #####:  367:        return temp;
        -:  368:    }
        -:  369:
        -:  370:
    #####:  371:    std::string Approx::toString() const {
    #####:  372:        ReusableStringStream rss;
    #####:  373:        rss << "Approx( " << ::Catch::Detail::stringify( m_value ) << " )";
    #####:  374:        return rss.str();
        -:  375:    }
        -:  376:
    #####:  377:    bool Approx::equalityComparisonImpl(const double other) const {
        -:  378:        // First try with fixed margin, then compute margin based on epsilon, scale and Approx's value
        -:  379:        // Thanks to Richard Harris for his help refining the scaled margin value
    #####:  380:        return marginComparison(m_value, other, m_margin)
    #####:  381:            || marginComparison(m_value, other, m_epsilon * (m_scale + std::fabs(std::isinf(m_value)? 0 : m_value)));
        -:  382:    }
        -:  383:
    #####:  384:    void Approx::setMargin(double newMargin) {
    #####:  385:        CATCH_ENFORCE(newMargin >= 0,
        -:  386:            "Invalid Approx::margin: " << newMargin << '.'
        -:  387:            << " Approx::Margin has to be non-negative.");
    #####:  388:        m_margin = newMargin;
    #####:  389:    }
        -:  390:
    #####:  391:    void Approx::setEpsilon(double newEpsilon) {
    #####:  392:        CATCH_ENFORCE(newEpsilon >= 0 && newEpsilon <= 1.0,
        -:  393:            "Invalid Approx::epsilon: " << newEpsilon << '.'
        -:  394:            << " Approx::epsilon has to be in [0, 1]");
    #####:  395:        m_epsilon = newEpsilon;
    #####:  396:    }
        -:  397:
        -:  398:namespace literals {
    #####:  399:    Approx operator "" _a(long double val) {
    #####:  400:        return Approx(val);
        -:  401:    }
    #####:  402:    Approx operator "" _a(unsigned long long val) {
    #####:  403:        return Approx(val);
        -:  404:    }
        -:  405:} // end namespace literals
        -:  406:
    #####:  407:std::string StringMaker<Catch::Approx>::convert(Catch::Approx const& value) {
    #####:  408:    return value.toString();
        -:  409:}
        -:  410:
        -:  411:} // end namespace Catch
        -:  412:
        -:  413:
        -:  414:
        -:  415:namespace Catch {
        -:  416:
    #####:  417:    AssertionResultData::AssertionResultData(ResultWas::OfType _resultType, LazyExpression const & _lazyExpression):
        -:  418:        lazyExpression(_lazyExpression),
    #####:  419:        resultType(_resultType) {}
        -:  420:
    #####:  421:    std::string AssertionResultData::reconstructExpression() const {
        -:  422:
    #####:  423:        if( reconstructedExpression.empty() ) {
    #####:  424:            if( lazyExpression ) {
    #####:  425:                ReusableStringStream rss;
    #####:  426:                rss << lazyExpression;
    #####:  427:                reconstructedExpression = rss.str();
        -:  428:            }
        -:  429:        }
    #####:  430:        return reconstructedExpression;
        -:  431:    }
        -:  432:
    #####:  433:    AssertionResult::AssertionResult( AssertionInfo const& info, AssertionResultData const& data )
        -:  434:    :   m_info( info ),
    #####:  435:        m_resultData( data )
    #####:  436:    {}
        -:  437:
        -:  438:    // Result was a success
    #####:  439:    bool AssertionResult::succeeded() const {
    #####:  440:        return Catch::isOk( m_resultData.resultType );
        -:  441:    }
        -:  442:
        -:  443:    // Result was a success, or failure is suppressed
    #####:  444:    bool AssertionResult::isOk() const {
    #####:  445:        return Catch::isOk( m_resultData.resultType ) || shouldSuppressFailure( m_info.resultDisposition );
        -:  446:    }
        -:  447:
    #####:  448:    ResultWas::OfType AssertionResult::getResultType() const {
    #####:  449:        return m_resultData.resultType;
        -:  450:    }
        -:  451:
    #####:  452:    bool AssertionResult::hasExpression() const {
    #####:  453:        return !m_info.capturedExpression.empty();
        -:  454:    }
        -:  455:
    #####:  456:    bool AssertionResult::hasMessage() const {
    #####:  457:        return !m_resultData.message.empty();
        -:  458:    }
        -:  459:
    #####:  460:    std::string AssertionResult::getExpression() const {
        -:  461:        // Possibly overallocating by 3 characters should be basically free
    #####:  462:        std::string expr; expr.reserve(m_info.capturedExpression.size() + 3);
    #####:  463:        if (isFalseTest(m_info.resultDisposition)) {
        -:  464:            expr += "!(";
        -:  465:        }
        -:  466:        expr += m_info.capturedExpression;
    #####:  467:        if (isFalseTest(m_info.resultDisposition)) {
        -:  468:            expr += ')';
        -:  469:        }
    #####:  470:        return expr;
        -:  471:    }
        -:  472:
    #####:  473:    std::string AssertionResult::getExpressionInMacro() const {
        -:  474:        std::string expr;
    #####:  475:        if( m_info.macroName.empty() )
    #####:  476:            expr = static_cast<std::string>(m_info.capturedExpression);
        -:  477:        else {
    #####:  478:            expr.reserve( m_info.macroName.size() + m_info.capturedExpression.size() + 4 );
        -:  479:            expr += m_info.macroName;
        -:  480:            expr += "( ";
        -:  481:            expr += m_info.capturedExpression;
        -:  482:            expr += " )";
        -:  483:        }
    #####:  484:        return expr;
        -:  485:    }
        -:  486:
    #####:  487:    bool AssertionResult::hasExpandedExpression() const {
    #####:  488:        return hasExpression() && getExpandedExpression() != getExpression();
        -:  489:    }
        -:  490:
    #####:  491:    std::string AssertionResult::getExpandedExpression() const {
    #####:  492:        std::string expr = m_resultData.reconstructExpression();
        -:  493:        return expr.empty()
        -:  494:                ? getExpression()
    #####:  495:                : expr;
        -:  496:    }
        -:  497:
    #####:  498:    std::string AssertionResult::getMessage() const {
    #####:  499:        return m_resultData.message;
        -:  500:    }
    #####:  501:    SourceLineInfo AssertionResult::getSourceInfo() const {
    #####:  502:        return m_info.lineInfo;
        -:  503:    }
        -:  504:
    #####:  505:    StringRef AssertionResult::getTestMacroName() const {
    #####:  506:        return m_info.macroName;
        -:  507:    }
        -:  508:
        -:  509:} // end namespace Catch
        -:  510:
        -:  511:
        -:  512:
        -:  513:
        -:  514:namespace Catch {
        -:  515:
        1:  516:    Config::Config( ConfigData const& data )
        -:  517:    :   m_data( data ),
        2:  518:        m_stream( openStream() )
        -:  519:    {
        -:  520:        // We need to trim filter specs to avoid trouble with superfluous
        -:  521:        // whitespace (esp. important for bdd macros, as those are manually
        -:  522:        // aligned with whitespace).
        -:  523:
        1:  524:        for (auto& elem : m_data.testsOrTags) {
    #####:  525:            elem = trim(elem);
        -:  526:        }
        1:  527:        for (auto& elem : m_data.sectionsToRun) {
    #####:  528:            elem = trim(elem);
        -:  529:        }
        -:  530:
        1:  531:        TestSpecParser parser(ITagAliasRegistry::get());
        1:  532:        if (!m_data.testsOrTags.empty()) {
    #####:  533:            m_hasTestFilters = true;
    #####:  534:            for (auto const& testOrTags : m_data.testsOrTags) {
    #####:  535:                parser.parse(testOrTags);
        -:  536:            }
        -:  537:        }
        2:  538:        m_testSpec = parser.testSpec();
        1:  539:    }
        -:  540:
        -:  541:    Config::~Config() = default;
        -:  542:
        -:  543:
    #####:  544:    std::string const& Config::getFilename() const {
    #####:  545:        return m_data.outputFilename ;
        -:  546:    }
        -:  547:
        1:  548:    bool Config::listTests() const          { return m_data.listTests; }
        1:  549:    bool Config::listTags() const           { return m_data.listTags; }
        1:  550:    bool Config::listReporters() const      { return m_data.listReporters; }
        -:  551:
    #####:  552:    std::string Config::getProcessName() const { return m_data.processName; }
        1:  553:    std::string const& Config::getReporterName() const { return m_data.reporterName; }
        -:  554:
    #####:  555:    std::vector<std::string> const& Config::getTestsOrTags() const { return m_data.testsOrTags; }
        1:  556:    std::vector<std::string> const& Config::getSectionsToRun() const { return m_data.sectionsToRun; }
        -:  557:
        4:  558:    TestSpec const& Config::testSpec() const { return m_testSpec; }
    #####:  559:    bool Config::hasTestFilters() const { return m_hasTestFilters; }
        -:  560:
    #####:  561:    bool Config::showHelp() const { return m_data.showHelp; }
        -:  562:
        -:  563:    // IConfig interface
    #####:  564:    bool Config::allowThrows() const                   { return !m_data.noThrow; }
       18:  565:    std::ostream& Config::stream() const               { return m_stream->stream(); }
        6:  566:    std::string Config::name() const                   { return m_data.name.empty() ? m_data.processName : m_data.name; }
        1:  567:    bool Config::includeSuccessfulResults() const      { return m_data.showSuccessfulTests; }
    #####:  568:    bool Config::warnAboutMissingAssertions() const    { return !!(m_data.warnings & WarnAbout::NoAssertions); }
        1:  569:    bool Config::warnAboutNoTests() const              { return !!(m_data.warnings & WarnAbout::NoTests); }
        2:  570:    ShowDurations Config::showDurations() const        { return m_data.showDurations; }
        1:  571:    double Config::minDuration() const                 { return m_data.minDuration; }
        3:  572:    TestRunOrder Config::runOrder() const              { return m_data.runOrder; }
        2:  573:    unsigned int Config::rngSeed() const               { return m_data.rngSeed; }
        1:  574:    UseColour Config::useColour() const                { return m_data.useColour; }
    #####:  575:    bool Config::shouldDebugBreak() const              { return m_data.shouldDebugBreak; }
        4:  576:    int Config::abortAfter() const                     { return m_data.abortAfter; }
    #####:  577:    bool Config::showInvisibles() const                { return m_data.showInvisibles; }
    #####:  578:    Verbosity Config::verbosity() const                { return m_data.verbosity; }
        -:  579:
        1:  580:    bool Config::benchmarkNoAnalysis() const                      { return m_data.benchmarkNoAnalysis; }
    #####:  581:    int Config::benchmarkSamples() const                          { return m_data.benchmarkSamples; }
    #####:  582:    double Config::benchmarkConfidenceInterval() const            { return m_data.benchmarkConfidenceInterval; }
    #####:  583:    unsigned int Config::benchmarkResamples() const               { return m_data.benchmarkResamples; }
    #####:  584:    std::chrono::milliseconds Config::benchmarkWarmupTime() const { return std::chrono::milliseconds(m_data.benchmarkWarmupTime); }
        -:  585:
    #####:  586:    IStream const* Config::openStream() {
        1:  587:        return Catch::makeStream(m_data.outputFilename);
        -:  588:    }
        -:  589:
        -:  590:} // end namespace Catch
        -:  591:
        -:  592:
        -:  593:
        -:  594:#include <cassert>
        -:  595:#include <stack>
        -:  596:
        -:  597:namespace Catch {
        -:  598:
        -:  599:    ////////////////////////////////////////////////////////////////////////////
        -:  600:
    #####:  601:    Catch::MessageBuilder::MessageBuilder( StringRef const& macroName,
        -:  602:                                           SourceLineInfo const& lineInfo,
        -:  603:                                           ResultWas::OfType type )
    #####:  604:        :m_info(macroName, lineInfo, type) {}
        -:  605:
        -:  606:    ////////////////////////////////////////////////////////////////////////////
        -:  607:
        -:  608:
    #####:  609:    ScopedMessage::ScopedMessage( MessageBuilder const& builder ):
    #####:  610:        m_info( builder.m_info ) {
    #####:  611:        m_info.message = builder.m_stream.str();
    #####:  612:        getResultCapture().pushScopedMessage( m_info );
    #####:  613:    }
        -:  614:
    #####:  615:    ScopedMessage::ScopedMessage( ScopedMessage&& old ) noexcept:
    #####:  616:        m_info( std::move( old.m_info ) ) {
    #####:  617:        old.m_moved = true;
    #####:  618:    }
        -:  619:
    #####:  620:    ScopedMessage::~ScopedMessage() {
    #####:  621:        if ( !uncaught_exceptions() && !m_moved ){
    #####:  622:            getResultCapture().popScopedMessage(m_info);
        -:  623:        }
    #####:  624:    }
        -:  625:
        -:  626:
    #####:  627:    Capturer::Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names ) {
    #####:  628:        auto trimmed = [&] (size_t start, size_t end) {
    #####:  629:            while (names[start] == ',' || isspace(static_cast<unsigned char>(names[start]))) {
    #####:  630:                ++start;
        -:  631:            }
    #####:  632:            while (names[end] == ',' || isspace(static_cast<unsigned char>(names[end]))) {
    #####:  633:                --end;
        -:  634:            }
    #####:  635:            return names.substr(start, end - start + 1);
    #####:  636:        };
    #####:  637:        auto skipq = [&] (size_t start, char quote) {
    #####:  638:            for (auto i = start + 1; i < names.size() ; ++i) {
    #####:  639:                if (names[i] == quote)
    #####:  640:                    return i;
    #####:  641:                if (names[i] == '\\')
    #####:  642:                    ++i;
        -:  643:            }
    #####:  644:            CATCH_INTERNAL_ERROR("CAPTURE parsing encountered unmatched quote");
    #####:  645:        };
        -:  646:
        -:  647:        size_t start = 0;
    #####:  648:        std::stack<char> openings;
    #####:  649:        for (size_t pos = 0; pos < names.size(); ++pos) {
    #####:  650:            char c = names[pos];
    #####:  651:            switch (c) {
        -:  652:            case '[':
        -:  653:            case '{':
        -:  654:            case '(':
        -:  655:            // It is basically impossible to disambiguate between
        -:  656:            // comparison and start of template args in this context
        -:  657://            case '<':
        -:  658:                openings.push(c);
        -:  659:                break;
        -:  660:            case ']':
        -:  661:            case '}':
        -:  662:            case ')':
        -:  663://           case '>':
        -:  664:                openings.pop();
        -:  665:                break;
        -:  666:            case '"':
        -:  667:            case '\'':
    #####:  668:                pos = skipq(pos, c);
        -:  669:                break;
        -:  670:            case ',':
    #####:  671:                if (start != pos && openings.empty()) {
    #####:  672:                    m_messages.emplace_back(macroName, lineInfo, resultType);
    #####:  673:                    m_messages.back().message = static_cast<std::string>(trimmed(start, pos));
    #####:  674:                    m_messages.back().message += " := ";
        -:  675:                    start = pos;
        -:  676:                }
        -:  677:            }
        -:  678:        }
    #####:  679:        assert(openings.empty() && "Mismatched openings");
    #####:  680:        m_messages.emplace_back(macroName, lineInfo, resultType);
    #####:  681:        m_messages.back().message = static_cast<std::string>(trimmed(start, names.size() - 1));
    #####:  682:        m_messages.back().message += " := ";
    #####:  683:    }
    #####:  684:    Capturer::~Capturer() {
    #####:  685:        if ( !uncaught_exceptions() ){
    #####:  686:            assert( m_captured == m_messages.size() );
    #####:  687:            for( size_t i = 0; i < m_captured; ++i  )
    #####:  688:                m_resultCapture.popScopedMessage( m_messages[i] );
        -:  689:        }
    #####:  690:    }
        -:  691:
    #####:  692:    void Capturer::captureValue( size_t index, std::string const& value ) {
    #####:  693:        assert( index < m_messages.size() );
    #####:  694:        m_messages[index].message += value;
    #####:  695:        m_resultCapture.pushScopedMessage( m_messages[index] );
    #####:  696:        m_captured++;
    #####:  697:    }
        -:  698:
        -:  699:} // end namespace Catch
        -:  700:
        -:  701:
        -:  702:
        -:  703:
        -:  704:namespace Catch {
        -:  705:
        -:  706:    namespace {
        -:  707:
        3:  708:        class RegistryHub : public IRegistryHub,
        -:  709:                            public IMutableRegistryHub,
        -:  710:                            private Detail::NonCopyable {
        -:  711:
        -:  712:        public: // IRegistryHub
        4:  713:            RegistryHub() = default;
        2:  714:            IReporterRegistry const& getReporterRegistry() const override {
        2:  715:                return m_reporterRegistry;
        -:  716:            }
        1:  717:            ITestCaseRegistry const& getTestCaseRegistry() const override {
        1:  718:                return m_testCaseRegistry;
        -:  719:            }
    #####:  720:            IExceptionTranslatorRegistry const& getExceptionTranslatorRegistry() const override {
    #####:  721:                return m_exceptionTranslatorRegistry;
        -:  722:            }
        1:  723:            ITagAliasRegistry const& getTagAliasRegistry() const override {
        1:  724:                return m_tagAliasRegistry;
        -:  725:            }
        1:  726:            StartupExceptionRegistry const& getStartupExceptionRegistry() const override {
        1:  727:                return m_exceptionRegistry;
        -:  728:            }
        -:  729:
        -:  730:        public: // IMutableRegistryHub
    #####:  731:            void registerReporter( std::string const& name, IReporterFactoryPtr factory ) override {
    #####:  732:                m_reporterRegistry.registerReporter( name, std::move(factory) );
    #####:  733:            }
    #####:  734:            void registerListener( IReporterFactoryPtr factory ) override {
    #####:  735:                m_reporterRegistry.registerListener( std::move(factory) );
    #####:  736:            }
        1:  737:            void registerTest( Detail::unique_ptr<TestCaseInfo>&& testInfo, Detail::unique_ptr<ITestInvoker>&& invoker ) override {
        2:  738:                m_testCaseRegistry.registerTest( std::move(testInfo), std::move(invoker) );
        1:  739:            }
    #####:  740:            void registerTranslator( const IExceptionTranslator* translator ) override {
    #####:  741:                m_exceptionTranslatorRegistry.registerTranslator( translator );
    #####:  742:            }
    #####:  743:            void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) override {
    #####:  744:                m_tagAliasRegistry.add( alias, tag, lineInfo );
    #####:  745:            }
    #####:  746:            void registerStartupException() noexcept override {
        -:  747:#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
    #####:  748:                m_exceptionRegistry.add(std::current_exception());
        -:  749:#else
        -:  750:                CATCH_INTERNAL_ERROR("Attempted to register active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!");
        -:  751:#endif
    #####:  752:            }
    #####:  753:            IMutableEnumValuesRegistry& getMutableEnumValuesRegistry() override {
    #####:  754:                return m_enumValuesRegistry;
        -:  755:            }
        -:  756:
        -:  757:        private:
        -:  758:            TestRegistry m_testCaseRegistry;
        -:  759:            ReporterRegistry m_reporterRegistry;
        -:  760:            ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;
        -:  761:            TagAliasRegistry m_tagAliasRegistry;
        -:  762:            StartupExceptionRegistry m_exceptionRegistry;
        -:  763:            Detail::EnumValuesRegistry m_enumValuesRegistry;
        -:  764:        };
        -:  765:    }
        -:  766:
        -:  767:    using RegistryHubSingleton = Singleton<RegistryHub, IRegistryHub, IMutableRegistryHub>;
        -:  768:
    #####:  769:    IRegistryHub const& getRegistryHub() {
    #####:  770:        return RegistryHubSingleton::get();
        -:  771:    }
    #####:  772:    IMutableRegistryHub& getMutableRegistryHub() {
    #####:  773:        return RegistryHubSingleton::getMutable();
        -:  774:    }
        1:  775:    void cleanUp() {
        1:  776:        cleanupSingletons();
        -:  777:        cleanUpContext();
        1:  778:    }
    #####:  779:    std::string translateActiveException() {
    #####:  780:        return getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();
        -:  781:    }
        -:  782:
        -:  783:
        -:  784:} // end namespace Catch
        -:  785:
        -:  786:
        -:  787:
        -:  788:#include <algorithm>
        -:  789:#include <iomanip>
        -:  790:#include <set>
        -:  791:
        -:  792:namespace Catch {
        -:  793:
        -:  794:    namespace {
        -:  795:        const int MaxExitCode = 255;
        -:  796:
        1:  797:        IStreamingReporterPtr createReporter(std::string const& reporterName, IConfig const* config) {
        1:  798:            auto reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, config);
        1:  799:            CATCH_ENFORCE(reporter, "No reporter registered with name: '" << reporterName << "'");
        -:  800:
        1:  801:            return reporter;
        -:  802:        }
        -:  803:
        1:  804:        IStreamingReporterPtr makeReporter(Config const* config) {
        1:  805:            if (Catch::getRegistryHub().getReporterRegistry().getListeners().empty()) {
        1:  806:                return createReporter(config->getReporterName(), config);
        -:  807:            }
        -:  808:
        -:  809:            // On older platforms, returning unique_ptr<ListeningReporter>
        -:  810:            // when the return type is unique_ptr<IStreamingReporter>
        -:  811:            // doesn't compile without a std::move call. However, this causes
        -:  812:            // a warning on newer platforms. Thus, we have to work around
        -:  813:            // it a bit and downcast the pointer manually.
    #####:  814:            auto ret = Detail::unique_ptr<IStreamingReporter>(new ListeningReporter);
        -:  815:            auto& multi = static_cast<ListeningReporter&>(*ret);
    #####:  816:            auto const& listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();
    #####:  817:            for (auto const& listener : listeners) {
    #####:  818:                multi.addListener(listener->create(Catch::ReporterConfig(config)));
        -:  819:            }
    #####:  820:            multi.addReporter(createReporter(config->getReporterName(), config));
        -:  821:            return ret;
        -:  822:        }
        -:  823:
        2:  824:        class TestGroup {
        -:  825:        public:
        1:  826:            explicit TestGroup(IStreamingReporterPtr&& reporter, Config const* config):
        -:  827:                m_reporter(reporter.get()),
        -:  828:                m_config{config},
        1:  829:                m_context{config, std::move(reporter)} {
        -:  830:
        1:  831:                auto const& allTestCases = getAllTestCasesSorted(*m_config);
        2:  832:                m_matches = m_config->testSpec().matchesByFilter(allTestCases, *m_config);
        1:  833:                auto const& invalidArgs = m_config->testSpec().getInvalidArgs();
        -:  834:
        1:  835:                if (m_matches.empty() && invalidArgs.empty()) {
        2:  836:                    for (auto const& test : allTestCases)
        1:  837:                        if (!test.getTestCaseInfo().isHidden())
        2:  838:                            m_tests.emplace(&test);
        -:  839:                } else {
    #####:  840:                    for (auto const& match : m_matches)
        -:  841:                        m_tests.insert(match.tests.begin(), match.tests.end());
        -:  842:                }
        1:  843:            }
        -:  844:
        1:  845:            Totals execute() {
        1:  846:                auto const& invalidArgs = m_config->testSpec().getInvalidArgs();
        1:  847:                Totals totals;
        2:  848:                m_context.testGroupStarting(m_config->name(), 1, 1);
        2:  849:                for (auto const& testCase : m_tests) {
        1:  850:                    if (!m_context.aborting())
        2:  851:                        totals += m_context.runTest(*testCase);
        -:  852:                    else
    #####:  853:                        m_reporter->skipTest(testCase->getTestCaseInfo());
        -:  854:                }
        -:  855:
        1:  856:                for (auto const& match : m_matches) {
    #####:  857:                    if (match.tests.empty()) {
    #####:  858:                        m_reporter->noMatchingTestCases(match.name);
    #####:  859:                        totals.error = -1;
        -:  860:                    }
        -:  861:                }
        -:  862:
        1:  863:                if (!invalidArgs.empty()) {
    #####:  864:                    for (auto const& invalidArg: invalidArgs)
    #####:  865:                         m_reporter->reportInvalidArguments(invalidArg);
        -:  866:                }
        -:  867:
        2:  868:                m_context.testGroupEnded(m_config->name(), totals, 1, 1);
        1:  869:                return totals;
        -:  870:            }
        -:  871:
        -:  872:        private:
        -:  873:            using Tests = std::set<TestCaseHandle const*>;
        -:  874:
        -:  875:            IStreamingReporter* m_reporter;
        -:  876:            Config const* m_config;
        -:  877:            RunContext m_context;
        -:  878:            Tests m_tests;
        -:  879:            TestSpec::Matches m_matches;
        -:  880:        };
        -:  881:
    #####:  882:        void applyFilenamesAsTags() {
    #####:  883:            for (auto const& testInfo : getRegistryHub().getTestCaseRegistry().getAllInfos()) {
    #####:  884:                testInfo->addFilenameTag();
        -:  885:            }
    #####:  886:        }
        -:  887:
        -:  888:    } // anon namespace
        -:  889:
        3:  890:    Session::Session() {
        -:  891:        static bool alreadyInstantiated = false;
        1:  892:        if( alreadyInstantiated ) {
    #####:  893:            CATCH_TRY { CATCH_INTERNAL_ERROR( "Only one instance of Catch::Session can ever be used" ); }
    =====:  894:            CATCH_CATCH_ALL { getMutableRegistryHub().registerStartupException(); }
        -:  895:        }
        -:  896:
        -:  897:        // There cannot be exceptions at startup in no-exception mode.
        -:  898:#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
        1:  899:        const auto& exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();
        1:  900:        if ( !exceptions.empty() ) {
    #####:  901:            config();
    #####:  902:            getCurrentMutableContext().setConfig(m_config.get());
        -:  903:
    #####:  904:            m_startupExceptions = true;
        -:  905:            Colour colourGuard( Colour::Red );
        -:  906:            Catch::cerr() << "Errors occurred during startup!" << '\n';
        -:  907:            // iterate over all exceptions and notify user
    #####:  908:            for ( const auto& ex_ptr : exceptions ) {
        -:  909:                try {
    #####:  910:                    std::rethrow_exception(ex_ptr);
    =====:  911:                } catch ( std::exception const& ex ) {
    =====:  912:                    Catch::cerr() << TextFlow::Column( ex.what() ).indent(2) << '\n';
        -:  913:                }
        -:  914:            }
        -:  915:        }
        -:  916:#endif
        -:  917:
        1:  918:        alreadyInstantiated = true;
        1:  919:        m_cli = makeCommandLineParser( m_configData );
        1:  920:    }
        2:  921:    Session::~Session() {
        1:  922:        Catch::cleanUp();
        1:  923:    }
        -:  924:
    #####:  925:    void Session::showHelp() const {
        -:  926:        Catch::cout()
    #####:  927:                << "\nCatch v" << libraryVersion() << "\n"
    #####:  928:                << m_cli << std::endl
        -:  929:                << "For more detailed usage please see the project docs\n" << std::endl;
    #####:  930:    }
    #####:  931:    void Session::libIdentify() {
        -:  932:        Catch::cout()
        -:  933:                << std::left << std::setw(16) << "description: " << "A Catch2 test executable\n"
        -:  934:                << std::left << std::setw(16) << "category: " << "testframework\n"
        -:  935:                << std::left << std::setw(16) << "framework: " << "Catch Test\n"
    #####:  936:                << std::left << std::setw(16) << "version: " << libraryVersion() << std::endl;
    #####:  937:    }
        -:  938:
        1:  939:    int Session::applyCommandLine( int argc, char const * const * argv ) {
        1:  940:        if( m_startupExceptions )
        -:  941:            return 1;
        -:  942:
        2:  943:        auto result = m_cli.parse( Clara::Args( argc, argv ) );
        1:  944:        if( !result ) {
    #####:  945:            config();
    #####:  946:            getCurrentMutableContext().setConfig(m_config.get());
        -:  947:            Catch::cerr()
        -:  948:                << Colour( Colour::Red )
        -:  949:                << "\nError(s) in input:\n"
    #####:  950:                << TextFlow::Column( result.errorMessage() ).indent( 2 )
    #####:  951:                << "\n\n";
        -:  952:            Catch::cerr() << "Run with -? for usage\n" << std::endl;
        -:  953:            return MaxExitCode;
        -:  954:        }
        -:  955:
        1:  956:        if( m_configData.showHelp )
    #####:  957:            showHelp();
        1:  958:        if( m_configData.libIdentify )
    #####:  959:            libIdentify();
        -:  960:        m_config.reset();
        1:  961:        return 0;
        -:  962:    }
        -:  963:
        -:  964:#if defined(CATCH_CONFIG_WCHAR) && defined(_WIN32) && defined(UNICODE)
        -:  965:    int Session::applyCommandLine( int argc, wchar_t const * const * argv ) {
        -:  966:
        -:  967:        char **utf8Argv = new char *[ argc ];
        -:  968:
        -:  969:        for ( int i = 0; i < argc; ++i ) {
        -:  970:            int bufSize = WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, nullptr, 0, nullptr, nullptr );
        -:  971:
        -:  972:            utf8Argv[ i ] = new char[ bufSize ];
        -:  973:
        -:  974:            WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, utf8Argv[i], bufSize, nullptr, nullptr );
        -:  975:        }
        -:  976:
        -:  977:        int returnCode = applyCommandLine( argc, utf8Argv );
        -:  978:
        -:  979:        for ( int i = 0; i < argc; ++i )
        -:  980:            delete [] utf8Argv[ i ];
        -:  981:
        -:  982:        delete [] utf8Argv;
        -:  983:
        -:  984:        return returnCode;
        -:  985:    }
        -:  986:#endif
        -:  987:
    #####:  988:    void Session::useConfigData( ConfigData const& configData ) {
    #####:  989:        m_configData = configData;
        -:  990:        m_config.reset();
    #####:  991:    }
        -:  992:
        1:  993:    int Session::run() {
        1:  994:        if( ( m_configData.waitForKeypress & WaitForKeypress::BeforeStart ) != 0 ) {
        -:  995:            Catch::cout() << "...waiting for enter/ return before starting" << std::endl;
        -:  996:            static_cast<void>(std::getchar());
        -:  997:        }
        1:  998:        int exitCode = runInternal();
        1:  999:        if( ( m_configData.waitForKeypress & WaitForKeypress::BeforeExit ) != 0 ) {
    #####: 1000:            Catch::cout() << "...waiting for enter/ return before exiting, with code: " << exitCode << std::endl;
        -: 1001:            static_cast<void>(std::getchar());
        -: 1002:        }
        1: 1003:        return exitCode;
        -: 1004:    }
        -: 1005:
    #####: 1006:    Clara::Parser const& Session::cli() const {
    #####: 1007:        return m_cli;
        -: 1008:    }
    #####: 1009:    void Session::cli( Clara::Parser const& newParser ) {
    #####: 1010:        m_cli = newParser;
    #####: 1011:    }
    #####: 1012:    ConfigData& Session::configData() {
    #####: 1013:        return m_configData;
        -: 1014:    }
        1: 1015:    Config& Session::config() {
        1: 1016:        if( !m_config )
        2: 1017:            m_config = Detail::make_unique<Config>( m_configData );
        1: 1018:        return *m_config;
        -: 1019:    }
        -: 1020:
        1: 1021:    int Session::runInternal() {
        1: 1022:        if( m_startupExceptions )
        -: 1023:            return 1;
        -: 1024:
        1: 1025:        if (m_configData.showHelp || m_configData.libIdentify) {
        -: 1026:            return 0;
        -: 1027:        }
        -: 1028:
        -: 1029:        CATCH_TRY {
        1: 1030:            config(); // Force config to be constructed
        -: 1031:
        1: 1032:            seedRng( *m_config );
        -: 1033:
        1: 1034:            if (m_configData.filenamesAsTags) {
    #####: 1035:                applyFilenamesAsTags();
        -: 1036:            }
        -: 1037:
        -: 1038:            // Set up global config instance before we start calling into other functions
        2: 1039:            getCurrentMutableContext().setConfig(m_config.get());
        -: 1040:
        -: 1041:            // Create reporter(s) so we can route listings through them
        1: 1042:            auto reporter = makeReporter(m_config.get());
        -: 1043:
        -: 1044:            // Handle list request
        1: 1045:            if (list(*reporter, *m_config)) {
        -: 1046:                return 0;
        -: 1047:            }
        -: 1048:
        2: 1049:            TestGroup tests { std::move(reporter), m_config.get() };
        1: 1050:            auto const totals = tests.execute();
        -: 1051:
        1: 1052:            if( m_config->warnAboutNoTests() && totals.error == -1 )
        -: 1053:                return 2;
        -: 1054:
        -: 1055:            // Note that on unices only the lower 8 bits are usually used, clamping
        -: 1056:            // the return value to 255 prevents false negative when some multiple
        -: 1057:            // of 256 tests has failed
        2: 1058:            return (std::min) (MaxExitCode, (std::max) (totals.error, static_cast<int>(totals.assertions.failed)));
        -: 1059:        }
        -: 1060:#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
    =====: 1061:        catch( std::exception& ex ) {
    =====: 1062:            Catch::cerr() << ex.what() << std::endl;
        -: 1063:            return MaxExitCode;
        -: 1064:        }
        -: 1065:#endif
        -: 1066:    }
        -: 1067:
        -: 1068:} // end namespace Catch
        -: 1069:
        -: 1070:
        -: 1071:
        -: 1072:#include <cassert>
        -: 1073:#include <cctype>
        -: 1074:#include <algorithm>
        -: 1075:
        -: 1076:namespace Catch {
        -: 1077:
        -: 1078:    namespace {
        -: 1079:        using TCP_underlying_type = uint8_t;
        -: 1080:        static_assert(sizeof(TestCaseProperties) == sizeof(TCP_underlying_type),
        -: 1081:                      "The size of the TestCaseProperties is different from the assumed size");
        -: 1082:
        -: 1083:        TestCaseProperties operator|(TestCaseProperties lhs, TestCaseProperties rhs) {
        -: 1084:            return static_cast<TestCaseProperties>(
        -: 1085:                static_cast<TCP_underlying_type>(lhs) | static_cast<TCP_underlying_type>(rhs)
        -: 1086:            );
        -: 1087:        }
        -: 1088:
        -: 1089:        TestCaseProperties& operator|=(TestCaseProperties& lhs, TestCaseProperties rhs) {
        -: 1090:            lhs = static_cast<TestCaseProperties>(
        -: 1091:                static_cast<TCP_underlying_type>(lhs) | static_cast<TCP_underlying_type>(rhs)
        1: 1092:            );
        -: 1093:            return lhs;
        -: 1094:        }
        -: 1095:
        -: 1096:        TestCaseProperties operator&(TestCaseProperties lhs, TestCaseProperties rhs) {
        -: 1097:            return static_cast<TestCaseProperties>(
        -: 1098:                static_cast<TCP_underlying_type>(lhs) & static_cast<TCP_underlying_type>(rhs)
        3: 1099:            );
        -: 1100:        }
        -: 1101:
        -: 1102:        bool applies(TestCaseProperties tcp) {
        -: 1103:            static_assert(static_cast<TCP_underlying_type>(TestCaseProperties::None) == 0,
        -: 1104:                          "TestCaseProperties::None must be equal to 0");
    #####: 1105:            return tcp != TestCaseProperties::None;
        -: 1106:        }
        -: 1107:
        2: 1108:        TestCaseProperties parseSpecialTag( StringRef tag ) {
        4: 1109:            if( !tag.empty() && tag[0] == '.' )
        -: 1110:                return TestCaseProperties::IsHidden;
        2: 1111:            else if( tag == "!throws"_sr )
        -: 1112:                return TestCaseProperties::Throws;
        2: 1113:            else if( tag == "!shouldfail"_sr )
        -: 1114:                return TestCaseProperties::ShouldFail;
        2: 1115:            else if( tag == "!mayfail"_sr )
        -: 1116:                return TestCaseProperties::MayFail;
        2: 1117:            else if( tag == "!nonportable"_sr )
        -: 1118:                return TestCaseProperties::NonPortable;
        2: 1119:            else if( tag == "!benchmark"_sr )
        -: 1120:                return static_cast<TestCaseProperties>(TestCaseProperties::Benchmark | TestCaseProperties::IsHidden );
        -: 1121:            else
        2: 1122:                return TestCaseProperties::None;
        -: 1123:        }
        1: 1124:        bool isReservedTag( StringRef tag ) {
        1: 1125:            return parseSpecialTag( tag ) == TestCaseProperties::None
        1: 1126:                && tag.size() > 0
        2: 1127:                && !std::isalnum( static_cast<unsigned char>(tag[0]) );
        -: 1128:        }
        1: 1129:        void enforceNotReservedTag( StringRef tag, SourceLineInfo const& _lineInfo ) {
        1: 1130:            CATCH_ENFORCE( !isReservedTag(tag),
        -: 1131:                          "Tag name: [" << tag << "] is not allowed.\n"
        -: 1132:                          << "Tag names starting with non alphanumeric characters are reserved\n"
        -: 1133:                          << _lineInfo );
        1: 1134:        }
        -: 1135:
    #####: 1136:        std::string makeDefaultName() {
        -: 1137:            static size_t counter = 0;
    #####: 1138:            return "Anonymous test case " + std::to_string(++counter);
        -: 1139:        }
        -: 1140:
        1: 1141:        StringRef extractFilenamePart(StringRef filename) {
        -: 1142:            size_t lastDot = filename.size();
       11: 1143:            while (lastDot > 0 && filename[lastDot - 1] != '.') {
        3: 1144:                --lastDot;
        -: 1145:            }
        1: 1146:            --lastDot;
        -: 1147:
        -: 1148:            size_t nameStart = lastDot;
       17: 1149:            while (nameStart > 0 && filename[nameStart - 1] != '/' && filename[nameStart - 1] != '\\') {
        4: 1150:                --nameStart;
        -: 1151:            }
        -: 1152:
        2: 1153:            return filename.substr(nameStart, lastDot - nameStart);
        -: 1154:        }
        -: 1155:
        -: 1156:        // Returns the upper bound on size of extra tags ([#file]+[.])
        -: 1157:        size_t sizeOfExtraTags(StringRef filepath) {
        -: 1158:            // [.] is 3, [#] is another 3
        -: 1159:            const size_t extras = 3 + 3;
        1: 1160:            return extractFilenamePart(filepath).size() + extras;
        -: 1161:        }
        -: 1162:    }
        -: 1163:
        -: 1164:    Detail::unique_ptr<TestCaseInfo>
        1: 1165:        makeTestCaseInfo(std::string const& _className,
        -: 1166:                         NameAndTags const& nameAndTags,
        -: 1167:                         SourceLineInfo const& _lineInfo ) {
        2: 1168:        return Detail::unique_ptr<TestCaseInfo>(new TestCaseInfo(_className, nameAndTags, _lineInfo));
        -: 1169:    }
        -: 1170:
        1: 1171:    TestCaseInfo::TestCaseInfo(std::string const& _className,
        -: 1172:                               NameAndTags const& _nameAndTags,
        -: 1173:                               SourceLineInfo const& _lineInfo):
        1: 1174:        name( _nameAndTags.name.empty() ? makeDefaultName() : _nameAndTags.name ),
        -: 1175:        className( _className ),
        5: 1176:        lineInfo( _lineInfo )
        -: 1177:    {
        1: 1178:        StringRef originalTags = _nameAndTags.tags;
        -: 1179:        // We need to reserve enough space to store all of the tags
        -: 1180:        // (including optional hidden tag and filename tag)
        2: 1181:        auto requiredSize = originalTags.size() + sizeOfExtraTags(_lineInfo.file);
        1: 1182:        backingTags.reserve(requiredSize);
        1: 1183:        backingLCaseTags.reserve(requiredSize);
        -: 1184:
        -: 1185:        // We cannot copy the tags directly, as we need to normalize
        -: 1186:        // some tags, so that [.foo] is copied as [.][foo].
        -: 1187:        size_t tagStart = 0;
        -: 1188:        size_t tagEnd = 0;
        -: 1189:        bool inTag = false;
       23: 1190:        for (size_t idx = 0; idx < originalTags.size(); ++idx) {
        -: 1191:            auto c = originalTags[idx];
       11: 1192:            if (c == '[') {
        1: 1193:                assert(!inTag);
        -: 1194:                inTag = true;
        -: 1195:                tagStart = idx;
        -: 1196:            }
       11: 1197:            if (c == ']') {
        1: 1198:                assert(inTag);
        -: 1199:                inTag = false;
        -: 1200:                tagEnd = idx;
        1: 1201:                assert(tagStart < tagEnd);
        -: 1202:
        -: 1203:                // We need to check the tag for special meanings, copy
        -: 1204:                // it over to backing storage and actually reference the
        -: 1205:                // backing storage in the saved tags
        1: 1206:                StringRef tagStr = originalTags.substr(tagStart+1, tagEnd - tagStart - 1);
        1: 1207:                enforceNotReservedTag(tagStr, lineInfo);
        1: 1208:                properties |= parseSpecialTag(tagStr);
        -: 1209:                // When copying a tag to the backing storage, we need to
        -: 1210:                // check if it is a merged hide tag, such as [.foo], and
        -: 1211:                // if it is, we need to handle it as if it was [foo].
        2: 1212:                if (tagStr.size() > 1 && tagStr[0] == '.') {
    #####: 1213:                    tagStr = tagStr.substr(1, tagStr.size() - 1);
        -: 1214:                }
        -: 1215:                // We skip over dealing with the [.] tag, as we will add
        -: 1216:                // it later unconditionally and then sort and unique all
        -: 1217:                // the tags.
        1: 1218:                internalAppendTag(tagStr);
        -: 1219:            }
        -: 1220:            (void)inTag; // Silence "set-but-unused" warning in release mode.
        -: 1221:        }
        -: 1222:        // Add [.] if relevant
        1: 1223:        if (isHidden()) {
    #####: 1224:            internalAppendTag("."_sr);
        -: 1225:        }
        -: 1226:
        -: 1227:        // Sort and prepare tags
        1: 1228:        toLowerInPlace(backingLCaseTags);
    #####: 1229:        std::sort(begin(tags), end(tags), [](Tag lhs, Tag rhs) { return lhs.lowerCased < rhs.lowerCased; });
        1: 1230:        tags.erase(std::unique(begin(tags), end(tags), [](Tag lhs, Tag rhs) {return lhs.lowerCased == rhs.lowerCased; }),
        2: 1231:                   end(tags));
        1: 1232:    }
        -: 1233:
    #####: 1234:    bool TestCaseInfo::isHidden() const {
        2: 1235:        return applies( properties & TestCaseProperties::IsHidden );
        -: 1236:    }
    #####: 1237:    bool TestCaseInfo::throws() const {
    #####: 1238:        return applies( properties & TestCaseProperties::Throws );
        -: 1239:    }
    #####: 1240:    bool TestCaseInfo::okToFail() const {
    #####: 1241:        return applies( properties & (TestCaseProperties::ShouldFail | TestCaseProperties::MayFail ) );
        -: 1242:    }
    #####: 1243:    bool TestCaseInfo::expectedToFail() const {
        1: 1244:        return applies( properties & (TestCaseProperties::ShouldFail) );
        -: 1245:    }
        -: 1246:
    #####: 1247:    void TestCaseInfo::addFilenameTag() {
    #####: 1248:        std::string combined("#");
    #####: 1249:        combined += extractFilenamePart(lineInfo.file);
    #####: 1250:        internalAppendTag(combined);
    #####: 1251:    }
        -: 1252:
    #####: 1253:    std::string TestCaseInfo::tagsAsString() const {
        -: 1254:        std::string ret;
        -: 1255:        // '[' and ']' per tag
    #####: 1256:        std::size_t full_size = 2 * tags.size();
    #####: 1257:        for (const auto& tag : tags) {
    #####: 1258:            full_size += tag.original.size();
        -: 1259:        }
    #####: 1260:        ret.reserve(full_size);
    #####: 1261:        for (const auto& tag : tags) {
    #####: 1262:            ret.push_back('[');
        -: 1263:            ret += tag.original;
    #####: 1264:            ret.push_back(']');
        -: 1265:        }
        -: 1266:
    #####: 1267:        return ret;
        -: 1268:    }
        -: 1269:
        1: 1270:    void TestCaseInfo::internalAppendTag(StringRef tagStr) {
        1: 1271:        backingTags += '[';
        -: 1272:        const auto backingStart = backingTags.size();
        -: 1273:        backingTags += tagStr;
        -: 1274:        const auto backingEnd = backingTags.size();
        -: 1275:        backingTags += ']';
        1: 1276:        backingLCaseTags += '[';
        -: 1277:        // We append the tag to the lower-case backing storage as-is,
        -: 1278:        // because we will perform the lower casing later, in bulk
        -: 1279:        backingLCaseTags += tagStr;
        -: 1280:        backingLCaseTags += ']';
        4: 1281:        tags.emplace_back(StringRef(backingTags.c_str() + backingStart, backingEnd - backingStart),
        1: 1282:                          StringRef(backingLCaseTags.c_str() + backingStart, backingEnd - backingStart));
        1: 1283:    }
        -: 1284:
        -: 1285:
    #####: 1286:    bool TestCaseHandle::operator == ( TestCaseHandle const& rhs ) const {
    #####: 1287:        return m_invoker == rhs.m_invoker
    #####: 1288:            && m_info->name == rhs.m_info->name
    #####: 1289:            && m_info->className == rhs.m_info->className;
        -: 1290:    }
        -: 1291:
    #####: 1292:    bool TestCaseHandle::operator < ( TestCaseHandle const& rhs ) const {
    #####: 1293:        return m_info->name < rhs.m_info->name;
        -: 1294:    }
        -: 1295:
    #####: 1296:    TestCaseInfo const& TestCaseHandle::getTestCaseInfo() const {
        3: 1297:        return *m_info;
        -: 1298:    }
        -: 1299:
        -: 1300:} // end namespace Catch
        -: 1301:
        -: 1302:
        -: 1303:
        -: 1304:#include <algorithm>
        -: 1305:#include <string>
        -: 1306:#include <vector>
        -: 1307:
        -: 1308:namespace Catch {
        -: 1309:
    #####: 1310:    TestSpec::Pattern::Pattern( std::string const& name )
    #####: 1311:    : m_name( name )
    #####: 1312:    {}
        -: 1313:
        -: 1314:    TestSpec::Pattern::~Pattern() = default;
        -: 1315:
    #####: 1316:    std::string const& TestSpec::Pattern::name() const {
    #####: 1317:        return m_name;
        -: 1318:    }
        -: 1319:
        -: 1320:
    #####: 1321:    TestSpec::NamePattern::NamePattern( std::string const& name, std::string const& filterString )
        -: 1322:    : Pattern( filterString )
    #####: 1323:    , m_wildcardPattern( toLower( name ), CaseSensitive::No )
    #####: 1324:    {}
        -: 1325:
    #####: 1326:    bool TestSpec::NamePattern::matches( TestCaseInfo const& testCase ) const {
    #####: 1327:        return m_wildcardPattern.matches( testCase.name );
        -: 1328:    }
        -: 1329:
        -: 1330:
    #####: 1331:    TestSpec::TagPattern::TagPattern( std::string const& tag, std::string const& filterString )
        -: 1332:    : Pattern( filterString )
    #####: 1333:    , m_tag( toLower( tag ) )
    #####: 1334:    {}
        -: 1335:
    #####: 1336:    bool TestSpec::TagPattern::matches( TestCaseInfo const& testCase ) const {
    #####: 1337:        return std::find_if(begin(testCase.tags),
        -: 1338:                            end(testCase.tags),
    #####: 1339:                            [&](Tag const& tag) {
    #####: 1340:                                return tag.lowerCased == m_tag;
    #####: 1341:                            }) != end(testCase.tags);
        -: 1342:    }
        -: 1343:
    #####: 1344:    bool TestSpec::Filter::matches( TestCaseInfo const& testCase ) const {
    #####: 1345:        bool should_use = !testCase.isHidden();
    #####: 1346:        for (auto const& pattern : m_required) {
        -: 1347:            should_use = true;
    #####: 1348:            if (!pattern->matches(testCase)) {
        -: 1349:                return false;
        -: 1350:            }
        -: 1351:        }
    #####: 1352:        for (auto const& pattern : m_forbidden) {
    #####: 1353:            if (pattern->matches(testCase)) {
        -: 1354:                return false;
        -: 1355:            }
        -: 1356:        }
        -: 1357:        return should_use;
        -: 1358:    }
        -: 1359:
    #####: 1360:    std::string TestSpec::Filter::name() const {
        -: 1361:        std::string name;
    #####: 1362:        for (auto const& p : m_required) {
        -: 1363:            name += p->name();
        -: 1364:        }
    #####: 1365:        for (auto const& p : m_forbidden) {
        -: 1366:            name += p->name();
        -: 1367:        }
    #####: 1368:        return name;
        -: 1369:    }
        -: 1370:
        -: 1371:
    #####: 1372:    bool TestSpec::hasFilters() const {
    #####: 1373:        return !m_filters.empty();
        -: 1374:    }
        -: 1375:
    #####: 1376:    bool TestSpec::matches( TestCaseInfo const& testCase ) const {
    #####: 1377:        return std::any_of( m_filters.begin(), m_filters.end(), [&]( Filter const& f ){ return f.matches( testCase ); } );
        -: 1378:    }
        -: 1379:
        1: 1380:    TestSpec::Matches TestSpec::matchesByFilter( std::vector<TestCaseHandle> const& testCases, IConfig const& config ) const
        -: 1381:    {
        1: 1382:        Matches matches( m_filters.size() );
    #####: 1383:        std::transform( m_filters.begin(), m_filters.end(), matches.begin(), [&]( Filter const& filter ){
        -: 1384:            std::vector<TestCaseHandle const*> currentMatches;
    #####: 1385:            for( auto const& test : testCases )
    #####: 1386:                if( isThrowSafe( test, config ) && filter.matches( test.getTestCaseInfo() ) )
    #####: 1387:                    currentMatches.emplace_back( &test );
    #####: 1388:            return FilterMatch{ filter.name(), currentMatches };
        2: 1389:        } );
        1: 1390:        return matches;
        -: 1391:    }
        -: 1392:
    #####: 1393:    const TestSpec::vectorStrings& TestSpec::getInvalidArgs() const{
    #####: 1394:        return  (m_invalidArgs);
        -: 1395:    }
        -: 1396:
        -: 1397:}
        -: 1398:
        -: 1399:
        -: 1400:
        -: 1401:#include <chrono>
        -: 1402:
        -: 1403:static const uint64_t nanosecondsInSecond = 1000000000;
        -: 1404:
        -: 1405:namespace Catch {
        -: 1406:
    #####: 1407:    auto getCurrentNanosecondsSinceEpoch() -> uint64_t {
        4: 1408:        return std::chrono::duration_cast<std::chrono::nanoseconds>( std::chrono::high_resolution_clock::now().time_since_epoch() ).count();
        -: 1409:    }
        -: 1410:
        -: 1411:    namespace {
    #####: 1412:        auto estimateClockResolution() -> uint64_t {
        -: 1413:            uint64_t sum = 0;
        -: 1414:            static const uint64_t iterations = 1000000;
        -: 1415:
        -: 1416:            auto startTime = getCurrentNanosecondsSinceEpoch();
        -: 1417:
    #####: 1418:            for( std::size_t i = 0; i < iterations; ++i ) {
        -: 1419:
        -: 1420:                uint64_t ticks;
        -: 1421:                uint64_t baseTicks = getCurrentNanosecondsSinceEpoch();
        -: 1422:                do {
        -: 1423:                    ticks = getCurrentNanosecondsSinceEpoch();
    #####: 1424:                } while( ticks == baseTicks );
        -: 1425:
    #####: 1426:                auto delta = ticks - baseTicks;
    #####: 1427:                sum += delta;
        -: 1428:
        -: 1429:                // If we have been calibrating for over 3 seconds -- the clock
        -: 1430:                // is terrible and we should move on.
        -: 1431:                // TBD: How to signal that the measured resolution is probably wrong?
    #####: 1432:                if (ticks > startTime + 3 * nanosecondsInSecond) {
    #####: 1433:                    return sum / ( i + 1u );
        -: 1434:                }
        -: 1435:            }
        -: 1436:
        -: 1437:            // We're just taking the mean, here. To do better we could take the std. dev and exclude outliers
        -: 1438:            // - and potentially do more iterations if there's a high variance.
    #####: 1439:            return sum/iterations;
        -: 1440:        }
        -: 1441:    }
    #####: 1442:    auto getEstimatedClockResolution() -> uint64_t {
    #####: 1443:        static auto s_resolution = estimateClockResolution();
    #####: 1444:        return s_resolution;
        -: 1445:    }
        -: 1446:
    #####: 1447:    void Timer::start() {
    #####: 1448:       m_nanoseconds = getCurrentNanosecondsSinceEpoch();
    #####: 1449:    }
    #####: 1450:    auto Timer::getElapsedNanoseconds() const -> uint64_t {
        1: 1451:        return getCurrentNanosecondsSinceEpoch() - m_nanoseconds;
        -: 1452:    }
    #####: 1453:    auto Timer::getElapsedMicroseconds() const -> uint64_t {
        1: 1454:        return getElapsedNanoseconds()/1000;
        -: 1455:    }
    #####: 1456:    auto Timer::getElapsedMilliseconds() const -> unsigned int {
    #####: 1457:        return static_cast<unsigned int>(getElapsedMicroseconds()/1000);
        -: 1458:    }
    #####: 1459:    auto Timer::getElapsedSeconds() const -> double {
        1: 1460:        return getElapsedMicroseconds()/1000000.0;
        -: 1461:    }
        -: 1462:
        -: 1463:
        -: 1464:} // namespace Catch
        -: 1465:
        -: 1466:
        -: 1467:#if defined(__clang__)
        -: 1468:#    pragma clang diagnostic push
        -: 1469:#    pragma clang diagnostic ignored "-Wexit-time-destructors"
        -: 1470:#    pragma clang diagnostic ignored "-Wglobal-constructors"
        -: 1471:#endif
        -: 1472:
        -: 1473:
        -: 1474:
        -: 1475:#include <cmath>
        -: 1476:#include <iomanip>
        -: 1477:
        -: 1478:namespace Catch {
        -: 1479:
        -: 1480:namespace Detail {
        -: 1481:
        1: 1482:    const std::string unprintableString = "{?}";
        -: 1483:
        -: 1484:    namespace {
        -: 1485:        const int hexThreshold = 255;
        -: 1486:
        -: 1487:        struct Endianness {
        -: 1488:            enum Arch { Big, Little };
        -: 1489:
        -: 1490:            static Arch which() {
        -: 1491:                int one = 1;
        -: 1492:                // If the lowest byte we read is non-zero, we can assume
        -: 1493:                // that little endian format is used.
        -: 1494:                auto value = *reinterpret_cast<char*>(&one);
        -: 1495:                return value ? Little : Big;
        -: 1496:            }
        -: 1497:        };
        -: 1498:
        -: 1499:        template<typename T>
    #####: 1500:        std::string fpToString(T value, int precision) {
    #####: 1501:            if (Catch::isnan(value)) {
    #####: 1502:                return "nan";
        -: 1503:            }
        -: 1504:
    #####: 1505:            ReusableStringStream rss;
        -: 1506:            rss << std::setprecision(precision)
        -: 1507:                << std::fixed
        -: 1508:                << value;
        -: 1509:            std::string d = rss.str();
    #####: 1510:            std::size_t i = d.find_last_not_of('0');
    #####: 1511:            if (i != std::string::npos && i != d.size() - 1) {
    #####: 1512:                if (d[i] == '.')
    #####: 1513:                    i++;
    #####: 1514:                d = d.substr(0, i + 1);
        -: 1515:            }
        -: 1516:            return d;
        -: 1517:        }
        -: 1518:    } // end unnamed namespace
        -: 1519:
    #####: 1520:    std::string rawMemoryToString( const void *object, std::size_t size ) {
        -: 1521:        // Reverse order for little endian architectures
    #####: 1522:        int i = 0, end = static_cast<int>( size ), inc = 1;
        -: 1523:        if( Endianness::which() == Endianness::Little ) {
    #####: 1524:            i = end-1;
        -: 1525:            end = inc = -1;
        -: 1526:        }
        -: 1527:
        -: 1528:        unsigned char const *bytes = static_cast<unsigned char const *>(object);
    #####: 1529:        ReusableStringStream rss;
        -: 1530:        rss << "0x" << std::setfill('0') << std::hex;
    #####: 1531:        for( ; i != end; i += inc )
    #####: 1532:             rss << std::setw(2) << static_cast<unsigned>(bytes[i]);
    #####: 1533:       return rss.str();
        -: 1534:    }
        -: 1535:} // end Detail namespace
        -: 1536:
        -: 1537:
        -: 1538:
        -: 1539://// ======================================================= ////
        -: 1540://
        -: 1541://   Out-of-line defs for full specialization of StringMaker
        -: 1542://
        -: 1543://// ======================================================= ////
        -: 1544:
    #####: 1545:std::string StringMaker<std::string>::convert(const std::string& str) {
    #####: 1546:    if (!getCurrentContext().getConfig()->showInvisibles()) {
    #####: 1547:        return '"' + str + '"';
        -: 1548:    }
        -: 1549:
    #####: 1550:    std::string s("\"");
    #####: 1551:    for (char c : str) {
    #####: 1552:        switch (c) {
        -: 1553:        case '\n':
    #####: 1554:            s.append("\\n");
        -: 1555:            break;
        -: 1556:        case '\t':
    #####: 1557:            s.append("\\t");
        -: 1558:            break;
        -: 1559:        default:
    #####: 1560:            s.push_back(c);
        -: 1561:            break;
        -: 1562:        }
        -: 1563:    }
    #####: 1564:    s.append("\"");
        -: 1565:    return s;
        -: 1566:}
        -: 1567:
        -: 1568:#ifdef CATCH_CONFIG_CPP17_STRING_VIEW
        -: 1569:std::string StringMaker<std::string_view>::convert(std::string_view str) {
        -: 1570:    return ::Catch::Detail::stringify(std::string{ str });
        -: 1571:}
        -: 1572:#endif
        -: 1573:
    #####: 1574:std::string StringMaker<char const*>::convert(char const* str) {
    #####: 1575:    if (str) {
    #####: 1576:        return ::Catch::Detail::stringify(std::string{ str });
        -: 1577:    } else {
    #####: 1578:        return{ "{null string}" };
        -: 1579:    }
        -: 1580:}
    #####: 1581:std::string StringMaker<char*>::convert(char* str) {
    #####: 1582:    if (str) {
    #####: 1583:        return ::Catch::Detail::stringify(std::string{ str });
        -: 1584:    } else {
    #####: 1585:        return{ "{null string}" };
        -: 1586:    }
        -: 1587:}
        -: 1588:
        -: 1589:#ifdef CATCH_CONFIG_WCHAR
    #####: 1590:std::string StringMaker<std::wstring>::convert(const std::wstring& wstr) {
        -: 1591:    std::string s;
    #####: 1592:    s.reserve(wstr.size());
    #####: 1593:    for (auto c : wstr) {
    #####: 1594:        s += (c <= 0xff) ? static_cast<char>(c) : '?';
        -: 1595:    }
    #####: 1596:    return ::Catch::Detail::stringify(s);
        -: 1597:}
        -: 1598:
        -: 1599:# ifdef CATCH_CONFIG_CPP17_STRING_VIEW
        -: 1600:std::string StringMaker<std::wstring_view>::convert(std::wstring_view str) {
        -: 1601:    return StringMaker<std::wstring>::convert(std::wstring(str));
        -: 1602:}
        -: 1603:# endif
        -: 1604:
    #####: 1605:std::string StringMaker<wchar_t const*>::convert(wchar_t const * str) {
    #####: 1606:    if (str) {
    #####: 1607:        return ::Catch::Detail::stringify(std::wstring{ str });
        -: 1608:    } else {
    #####: 1609:        return{ "{null string}" };
        -: 1610:    }
        -: 1611:}
    #####: 1612:std::string StringMaker<wchar_t *>::convert(wchar_t * str) {
    #####: 1613:    if (str) {
    #####: 1614:        return ::Catch::Detail::stringify(std::wstring{ str });
        -: 1615:    } else {
    #####: 1616:        return{ "{null string}" };
        -: 1617:    }
        -: 1618:}
        -: 1619:#endif
        -: 1620:
        -: 1621:#if defined(CATCH_CONFIG_CPP17_BYTE)
        -: 1622:#include <cstddef>
        -: 1623:std::string StringMaker<std::byte>::convert(std::byte value) {
        -: 1624:    return ::Catch::Detail::stringify(std::to_integer<unsigned long long>(value));
        -: 1625:}
        -: 1626:#endif // defined(CATCH_CONFIG_CPP17_BYTE)
        -: 1627:
    #####: 1628:std::string StringMaker<int>::convert(int value) {
    #####: 1629:    return ::Catch::Detail::stringify(static_cast<long long>(value));
        -: 1630:}
    #####: 1631:std::string StringMaker<long>::convert(long value) {
    #####: 1632:    return ::Catch::Detail::stringify(static_cast<long long>(value));
        -: 1633:}
    #####: 1634:std::string StringMaker<long long>::convert(long long value) {
    #####: 1635:    ReusableStringStream rss;
        -: 1636:    rss << value;
    #####: 1637:    if (value > Detail::hexThreshold) {
        -: 1638:        rss << " (0x" << std::hex << value << ')';
        -: 1639:    }
    #####: 1640:    return rss.str();
        -: 1641:}
        -: 1642:
    #####: 1643:std::string StringMaker<unsigned int>::convert(unsigned int value) {
    #####: 1644:    return ::Catch::Detail::stringify(static_cast<unsigned long long>(value));
        -: 1645:}
    #####: 1646:std::string StringMaker<unsigned long>::convert(unsigned long value) {
    #####: 1647:    return ::Catch::Detail::stringify(static_cast<unsigned long long>(value));
        -: 1648:}
    #####: 1649:std::string StringMaker<unsigned long long>::convert(unsigned long long value) {
    #####: 1650:    ReusableStringStream rss;
        -: 1651:    rss << value;
    #####: 1652:    if (value > Detail::hexThreshold) {
        -: 1653:        rss << " (0x" << std::hex << value << ')';
        -: 1654:    }
    #####: 1655:    return rss.str();
        -: 1656:}
        -: 1657:
    #####: 1658:std::string StringMaker<signed char>::convert(signed char value) {
    #####: 1659:    if (value == '\r') {
    #####: 1660:        return "'\\r'";
    #####: 1661:    } else if (value == '\f') {
    #####: 1662:        return "'\\f'";
    #####: 1663:    } else if (value == '\n') {
    #####: 1664:        return "'\\n'";
    #####: 1665:    } else if (value == '\t') {
    #####: 1666:        return "'\\t'";
    #####: 1667:    } else if ('\0' <= value && value < ' ') {
    #####: 1668:        return ::Catch::Detail::stringify(static_cast<unsigned int>(value));
        -: 1669:    } else {
    #####: 1670:        char chstr[] = "' '";
    #####: 1671:        chstr[1] = value;
    #####: 1672:        return chstr;
        -: 1673:    }
        -: 1674:}
    #####: 1675:std::string StringMaker<char>::convert(char c) {
    #####: 1676:    return ::Catch::Detail::stringify(static_cast<signed char>(c));
        -: 1677:}
    #####: 1678:std::string StringMaker<unsigned char>::convert(unsigned char c) {
    #####: 1679:    return ::Catch::Detail::stringify(static_cast<char>(c));
        -: 1680:}
        -: 1681:
        -: 1682:int StringMaker<float>::precision = 5;
        -: 1683:
    #####: 1684:std::string StringMaker<float>::convert(float value) {
    #####: 1685:    return Detail::fpToString(value, precision) + 'f';
        -: 1686:}
        -: 1687:
        -: 1688:int StringMaker<double>::precision = 10;
        -: 1689:
    #####: 1690:std::string StringMaker<double>::convert(double value) {
    #####: 1691:    return Detail::fpToString(value, precision);
        -: 1692:}
        -: 1693:
        -: 1694:} // end namespace Catch
        -: 1695:
        -: 1696:#if defined(__clang__)
        -: 1697:#    pragma clang diagnostic pop
        -: 1698:#endif
        -: 1699:
        -: 1700:
        -: 1701:
        -: 1702:
        -: 1703:namespace Catch {
        -: 1704:
    #####: 1705:    Counts Counts::operator - ( Counts const& other ) const {
        1: 1706:        Counts diff;
        3: 1707:        diff.passed = passed - other.passed;
        3: 1708:        diff.failed = failed - other.failed;
        3: 1709:        diff.failedButOk = failedButOk - other.failedButOk;
    #####: 1710:        return diff;
        -: 1711:    }
        -: 1712:
    #####: 1713:    Counts& Counts::operator += ( Counts const& other ) {
        3: 1714:        passed += other.passed;
        3: 1715:        failed += other.failed;
        3: 1716:        failedButOk += other.failedButOk;
    #####: 1717:        return *this;
        -: 1718:    }
        -: 1719:
    #####: 1720:    std::size_t Counts::total() const {
        4: 1721:        return passed + failed + failedButOk;
        -: 1722:    }
    #####: 1723:    bool Counts::allPassed() const {
        2: 1724:        return failed == 0 && failedButOk == 0;
        -: 1725:    }
    #####: 1726:    bool Counts::allOk() const {
    #####: 1727:        return failed == 0;
        -: 1728:    }
        -: 1729:
    #####: 1730:    Totals Totals::operator - ( Totals const& other ) const {
        1: 1731:        Totals diff;
        1: 1732:        diff.assertions = assertions - other.assertions;
        1: 1733:        diff.testCases = testCases - other.testCases;
    #####: 1734:        return diff;
        -: 1735:    }
        -: 1736:
    #####: 1737:    Totals& Totals::operator += ( Totals const& other ) {
        -: 1738:        assertions += other.assertions;
        -: 1739:        testCases += other.testCases;
    #####: 1740:        return *this;
        -: 1741:    }
        -: 1742:
        1: 1743:    Totals Totals::delta( Totals const& prevTotals ) const {
        -: 1744:        Totals diff = *this - prevTotals;
        1: 1745:        if( diff.assertions.failed > 0 )
    #####: 1746:            ++diff.testCases.failed;
        1: 1747:        else if( diff.assertions.failedButOk > 0 )
    #####: 1748:            ++diff.testCases.failedButOk;
        -: 1749:        else
        1: 1750:            ++diff.testCases.passed;
        1: 1751:        return diff;
        -: 1752:    }
        -: 1753:
        -: 1754:}
        -: 1755:
        -: 1756:
        -: 1757:#include <ostream>
        -: 1758:
        -: 1759:namespace Catch {
        -: 1760:
    #####: 1761:    Version::Version
        -: 1762:        (   unsigned int _majorVersion,
        -: 1763:            unsigned int _minorVersion,
        -: 1764:            unsigned int _patchNumber,
        -: 1765:            char const * const _branchName,
        -: 1766:            unsigned int _buildNumber )
        -: 1767:    :   majorVersion( _majorVersion ),
        -: 1768:        minorVersion( _minorVersion ),
        -: 1769:        patchNumber( _patchNumber ),
        -: 1770:        branchName( _branchName ),
    #####: 1771:        buildNumber( _buildNumber )
    #####: 1772:    {}
        -: 1773:
    #####: 1774:    std::ostream& operator << ( std::ostream& os, Version const& version ) {
    #####: 1775:        os  << version.majorVersion << '.'
    #####: 1776:            << version.minorVersion << '.'
    #####: 1777:            << version.patchNumber;
        -: 1778:        // branchName is never null -> 0th char is \0 if it is empty
    #####: 1779:        if (version.branchName[0]) {
    #####: 1780:            os << '-' << version.branchName
    #####: 1781:               << '.' << version.buildNumber;
        -: 1782:        }
    #####: 1783:        return os;
        -: 1784:    }
        -: 1785:
    #####: 1786:    Version const& libraryVersion() {
    #####: 1787:        static Version version( 3, 0, 0, "preview", 3 );
    #####: 1788:        return version;
        -: 1789:    }
        -: 1790:
        -: 1791:}
        -: 1792:
        -: 1793:
        -: 1794:/** \file
        -: 1795: * This is a special TU that combines what would otherwise be a very
        -: 1796: * small generator-related TUs into one bigger TU.
        -: 1797: *
        -: 1798: * The reason for this is compilation performance improvements by
        -: 1799: * avoiding reparsing headers for many small TUs, instead having this
        -: 1800: * one TU include bit more, but having it all parsed only once.
        -: 1801: *
        -: 1802: * To avoid heavy-tail problem with compilation times, each "subpart"
        -: 1803: * of Catch2 has its own combined TU like this.
        -: 1804: */
        -: 1805:
        -: 1806:////////////////////////////////////////////////////
        -: 1807:// vvv formerly catch_generator_exception.cpp vvv //
        -: 1808:////////////////////////////////////////////////////
        -: 1809:
        -: 1810:
        -: 1811:namespace Catch {
        -: 1812:
    #####: 1813:    const char* GeneratorException::what() const noexcept {
    #####: 1814:        return m_msg;
        -: 1815:    }
        -: 1816:
        -: 1817:} // end namespace Catch
        -: 1818:
        -: 1819:
        -: 1820:///////////////////////////////////////////
        -: 1821:// vvv formerly catch_generators.cpp vvv //
        -: 1822:///////////////////////////////////////////
        -: 1823:
        -: 1824:
        -: 1825:namespace Catch {
        -: 1826:
        -: 1827:    IGeneratorTracker::~IGeneratorTracker() = default;
        -: 1828:
        -: 1829:namespace Generators {
        -: 1830:
        -: 1831:namespace Detail {
        -: 1832:
        -: 1833:    [[noreturn]]
    #####: 1834:    void throw_generator_exception(char const* msg) {
    #####: 1835:        Catch::throw_exception(GeneratorException{ msg });
        -: 1836:    }
        -: 1837:} // end namespace Detail
        -: 1838:
        -: 1839:    GeneratorUntypedBase::~GeneratorUntypedBase() = default;
        -: 1840:
    #####: 1841:    auto acquireGeneratorTracker(StringRef generatorName, SourceLineInfo const& lineInfo ) -> IGeneratorTracker& {
    #####: 1842:        return getResultCapture().acquireGeneratorTracker( generatorName, lineInfo );
        -: 1843:    }
        -: 1844:
        -: 1845:} // namespace Generators
        -: 1846:} // namespace Catch
        -: 1847:
        -: 1848:
        -: 1849:/** \file
        -: 1850: * This is a special TU that combines what would otherwise be a very
        -: 1851: * small interfaces-related TUs into one bigger TU.
        -: 1852: *
        -: 1853: * The reason for this is compilation performance improvements by
        -: 1854: * avoiding reparsing headers for many small TUs, instead having this
        -: 1855: * one TU include bit more, but having it all parsed only once.
        -: 1856: *
        -: 1857: * To avoid heavy-tail problem with compilation times, each "subpart"
        -: 1858: * of Catch2 has its own combined TU like this.
        -: 1859: */
        -: 1860:
        -: 1861:///////////////////////////////////////////////////
        -: 1862:// vvv formerly catch_interfaces_capture.cpp vvv //
        -: 1863:///////////////////////////////////////////////////
        -: 1864:
        -: 1865:
        -: 1866:namespace Catch {
        -: 1867:    IResultCapture::~IResultCapture() = default;
        -: 1868:}
        -: 1869:
        -: 1870:
        -: 1871://////////////////////////////////////////////////
        -: 1872:// vvv formerly catch_interfaces_config.cpp vvv //
        -: 1873://////////////////////////////////////////////////
        -: 1874:
        -: 1875:
        -: 1876:namespace Catch {
        -: 1877:    IConfig::~IConfig() = default;
        -: 1878:}
        -: 1879:
        -: 1880:
        -: 1881://///////////////////////////////////////////////////
        -: 1882:// vvv formerly catch_interfaces_exception.cpp vvv //
        -: 1883://///////////////////////////////////////////////////
        -: 1884:
        -: 1885:
        -: 1886:namespace Catch {
        -: 1887:    IExceptionTranslator::~IExceptionTranslator() = default;
        -: 1888:    IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() = default;
        -: 1889:}
        -: 1890:
        -: 1891:
        -: 1892:////////////////////////////////////////////////////////
        -: 1893:// vvv formerly catch_interfaces_registry_hub.cpp vvv //
        -: 1894:////////////////////////////////////////////////////////
        -: 1895:
        -: 1896:
        -: 1897:namespace Catch {
        -: 1898:    IRegistryHub::~IRegistryHub() = default;
        -: 1899:    IMutableRegistryHub::~IMutableRegistryHub() = default;
        -: 1900:}
        -: 1901:
        -: 1902:
        -: 1903://////////////////////////////////////////////////
        -: 1904:// vvv formerly catch_interfaces_runner.cpp vvv //
        -: 1905://////////////////////////////////////////////////
        -: 1906:
        -: 1907:
        -: 1908:namespace Catch {
        -: 1909:    IRunner::~IRunner() = default;
        -: 1910:}
        -: 1911:
        -: 1912:
        -: 1913:////////////////////////////////////////////////////
        -: 1914:// vvv formerly catch_interfaces_testcase.cpp vvv //
        -: 1915:////////////////////////////////////////////////////
        -: 1916:
        -: 1917:
        -: 1918:namespace Catch {
        -: 1919:    ITestInvoker::~ITestInvoker() = default;
        -: 1920:    ITestCaseRegistry::~ITestCaseRegistry() = default;
        -: 1921:}
        -: 1922:
        -: 1923:
        -: 1924:namespace Catch {
        -: 1925:    IReporterRegistry::~IReporterRegistry() = default;
        -: 1926:}
        -: 1927:
        -: 1928:
        -: 1929:
        -: 1930:namespace Catch {
        -: 1931:    IReporterFactory::~IReporterFactory() = default;
        -: 1932:}
        -: 1933:
        -: 1934:
        -: 1935:
        -: 1936:#include <algorithm>
        -: 1937:#include <iomanip>
        -: 1938:
        -: 1939:namespace Catch {
        -: 1940:
    #####: 1941:    ReporterConfig::ReporterConfig( IConfig const* _fullConfig )
        1: 1942:    :   m_stream( &_fullConfig->stream() ), m_fullConfig( _fullConfig ) {}
        -: 1943:
    #####: 1944:    ReporterConfig::ReporterConfig( IConfig const* _fullConfig, std::ostream& _stream )
    #####: 1945:    :   m_stream( &_stream ), m_fullConfig( _fullConfig ) {}
        -: 1946:
        1: 1947:    std::ostream& ReporterConfig::stream() const { return *m_stream; }
        2: 1948:    IConfig const * ReporterConfig::fullConfig() const { return m_fullConfig; }
        -: 1949:
        -: 1950:
        1: 1951:    TestRunInfo::TestRunInfo( std::string const& _name ) : name( _name ) {}
        -: 1952:
    #####: 1953:    GroupInfo::GroupInfo(  std::string const& _name,
        -: 1954:                           std::size_t _groupIndex,
        -: 1955:                           std::size_t _groupsCount )
        -: 1956:    :   name( _name ),
        -: 1957:        groupIndex( _groupIndex ),
        2: 1958:        groupsCounts( _groupsCount )
    #####: 1959:    {}
        -: 1960:
    #####: 1961:     AssertionStats::AssertionStats( AssertionResult const& _assertionResult,
        -: 1962:                                     std::vector<MessageInfo> const& _infoMessages,
        -: 1963:                                     Totals const& _totals )
        -: 1964:    :   assertionResult( _assertionResult ),
        -: 1965:        infoMessages( _infoMessages ),
    #####: 1966:        totals( _totals )
        -: 1967:    {
    #####: 1968:        assertionResult.m_resultData.lazyExpression.m_transientExpression = _assertionResult.m_resultData.lazyExpression.m_transientExpression;
        -: 1969:
    #####: 1970:        if( assertionResult.hasMessage() ) {
        -: 1971:            // Copy message into messages list.
        -: 1972:            // !TBD This should have been done earlier, somewhere
    #####: 1973:            MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );
    #####: 1974:            builder << assertionResult.getMessage();
    #####: 1975:            builder.m_info.message = builder.m_stream.str();
        -: 1976:
    #####: 1977:            infoMessages.push_back( builder.m_info );
        -: 1978:        }
    #####: 1979:    }
        -: 1980:
    #####: 1981:    SectionStats::SectionStats(  SectionInfo const& _sectionInfo,
        -: 1982:                                 Counts const& _assertions,
        -: 1983:                                 double _durationInSeconds,
        -: 1984:                                 bool _missingAssertions )
        -: 1985:    :   sectionInfo( _sectionInfo ),
        -: 1986:        assertions( _assertions ),
        -: 1987:        durationInSeconds( _durationInSeconds ),
        1: 1988:        missingAssertions( _missingAssertions )
    #####: 1989:    {}
        -: 1990:
        -: 1991:
        1: 1992:    TestCaseStats::TestCaseStats(  TestCaseInfo const& _testInfo,
        -: 1993:                                   Totals const& _totals,
        -: 1994:                                   std::string const& _stdOut,
        -: 1995:                                   std::string const& _stdErr,
        -: 1996:                                   bool _aborting )
        -: 1997:    : testInfo( &_testInfo ),
        -: 1998:        totals( _totals ),
        -: 1999:        stdOut( _stdOut ),
        -: 2000:        stdErr( _stdErr ),
        3: 2001:        aborting( _aborting )
        1: 2002:    {}
        -: 2003:
        -: 2004:
        1: 2005:    TestGroupStats::TestGroupStats( GroupInfo const& _groupInfo,
        -: 2006:                                    Totals const& _totals,
        -: 2007:                                    bool _aborting )
        -: 2008:    :   groupInfo( _groupInfo ),
        -: 2009:        totals( _totals ),
        1: 2010:        aborting( _aborting )
        1: 2011:    {}
        -: 2012:
    #####: 2013:    TestGroupStats::TestGroupStats( GroupInfo const& _groupInfo )
        -: 2014:    :   groupInfo( _groupInfo ),
    #####: 2015:        aborting( false )
    #####: 2016:    {}
        -: 2017:
        -: 2018:
    #####: 2019:    TestRunStats::TestRunStats(   TestRunInfo const& _runInfo,
        -: 2020:                    Totals const& _totals,
        -: 2021:                    bool _aborting )
        -: 2022:    :   runInfo( _runInfo ),
        -: 2023:        totals( _totals ),
        1: 2024:        aborting( _aborting )
    #####: 2025:    {}
        -: 2026:
    #####: 2027:    void IStreamingReporter::fatalErrorEncountered( StringRef ) {}
        -: 2028:
    #####: 2029:    void IStreamingReporter::listReporters(std::vector<ReporterDescription> const& descriptions, IConfig const& config) {
    #####: 2030:        Catch::cout() << "Available reporters:\n";
        -: 2031:        const auto maxNameLen = std::max_element(descriptions.begin(), descriptions.end(),
        -: 2032:            [](ReporterDescription const& lhs, ReporterDescription const& rhs) { return lhs.name.size() < rhs.name.size(); })
        -: 2033:            ->name.size();
        -: 2034:
    #####: 2035:        for (auto const& desc : descriptions) {
    #####: 2036:            if (config.verbosity() == Verbosity::Quiet) {
        -: 2037:                Catch::cout()
        -: 2038:                    << TextFlow::Column(desc.name)
    #####: 2039:                    .indent(2)
    #####: 2040:                    .width(5 + maxNameLen) << '\n';
        -: 2041:            } else {
        -: 2042:                Catch::cout()
    #####: 2043:                    << TextFlow::Column(desc.name + ":")
    #####: 2044:                    .indent(2)
    #####: 2045:                    .width(5 + maxNameLen)
    #####: 2046:                    + TextFlow::Column(desc.description)
    #####: 2047:                    .initialIndent(0)
        -: 2048:                    .indent(2)
    #####: 2049:                    .width(CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen - 8)
        -: 2050:                    << '\n';
        -: 2051:            }
        -: 2052:        }
        -: 2053:        Catch::cout() << std::endl;
    #####: 2054:    }
        -: 2055:
    #####: 2056:    void IStreamingReporter::listTests(std::vector<TestCaseHandle> const& tests, IConfig const& config) {
    #####: 2057:        if (config.hasTestFilters()) {
    #####: 2058:            Catch::cout() << "Matching test cases:\n";
        -: 2059:        } else {
    #####: 2060:            Catch::cout() << "All available test cases:\n";
        -: 2061:        }
        -: 2062:
    #####: 2063:        for (auto const& test : tests) {
        -: 2064:            auto const& testCaseInfo = test.getTestCaseInfo();
        -: 2065:            Colour::Code colour = testCaseInfo.isHidden()
        -: 2066:                ? Colour::SecondaryText
    #####: 2067:                : Colour::None;
        -: 2068:            Colour colourGuard(colour);
        -: 2069:
    #####: 2070:            Catch::cout() << TextFlow::Column(testCaseInfo.name).initialIndent(2).indent(4) << '\n';
    #####: 2071:            if (config.verbosity() >= Verbosity::High) {
    #####: 2072:                Catch::cout() << TextFlow::Column(Catch::Detail::stringify(testCaseInfo.lineInfo)).indent(4) << std::endl;
        -: 2073:            }
    #####: 2074:            if (!testCaseInfo.tags.empty() && config.verbosity() > Verbosity::Quiet) {
    #####: 2075:                Catch::cout() << TextFlow::Column(testCaseInfo.tagsAsString()).indent(6) << '\n';
        -: 2076:            }
        -: 2077:        }
        -: 2078:
    #####: 2079:        if (!config.hasTestFilters()) {
    #####: 2080:            Catch::cout() << pluralise(tests.size(), "test case") << '\n' << std::endl;
        -: 2081:        } else {
    #####: 2082:            Catch::cout() << pluralise(tests.size(), "matching test case") << '\n' << std::endl;
        -: 2083:        }
    #####: 2084:    }
        -: 2085:
    #####: 2086:    void IStreamingReporter::listTags(std::vector<TagInfo> const& tags, IConfig const& config) {
    #####: 2087:        if (config.hasTestFilters()) {
    #####: 2088:            Catch::cout() << "Tags for matching test cases:\n";
        -: 2089:        } else {
    #####: 2090:            Catch::cout() << "All available tags:\n";
        -: 2091:        }
        -: 2092:
    #####: 2093:        for (auto const& tagCount : tags) {
    #####: 2094:            ReusableStringStream rss;
        -: 2095:            rss << "  " << std::setw(2) << tagCount.count << "  ";
        -: 2096:            auto str = rss.str();
    #####: 2097:            auto wrapper = TextFlow::Column(tagCount.all())
    #####: 2098:                .initialIndent(0)
        -: 2099:                .indent(str.size())
        -: 2100:                .width(CATCH_CONFIG_CONSOLE_WIDTH - 10);
    #####: 2101:            Catch::cout() << str << wrapper << '\n';
        -: 2102:        }
    #####: 2103:        Catch::cout() << pluralise(tags.size(), "tag") << '\n' << std::endl;
    #####: 2104:    }
        -: 2105:
        -: 2106:} // end namespace Catch
        -: 2107:
        -: 2108:
        -: 2109:
        -: 2110:namespace Catch {
        -: 2111:
    #####: 2112:    AssertionHandler::AssertionHandler
        -: 2113:        (   StringRef const& macroName,
        -: 2114:            SourceLineInfo const& lineInfo,
        -: 2115:            StringRef capturedExpression,
        -: 2116:            ResultDisposition::Flags resultDisposition )
        -: 2117:    :   m_assertionInfo{ macroName, lineInfo, capturedExpression, resultDisposition },
        8: 2118:        m_resultCapture( getResultCapture() )
    #####: 2119:    {}
        -: 2120:
    #####: 2121:    void AssertionHandler::handleExpr( ITransientExpression const& expr ) {
        4: 2122:        m_resultCapture.handleExpr( m_assertionInfo, expr, m_reaction );
    #####: 2123:    }
    #####: 2124:    void AssertionHandler::handleMessage(ResultWas::OfType resultType, StringRef const& message) {
    #####: 2125:        m_resultCapture.handleMessage( m_assertionInfo, resultType, message, m_reaction );
    #####: 2126:    }
        -: 2127:
    #####: 2128:    auto AssertionHandler::allowThrows() const -> bool {
    #####: 2129:        return getCurrentContext().getConfig()->allowThrows();
        -: 2130:    }
        -: 2131:
        4: 2132:    void AssertionHandler::complete() {
        -: 2133:        setCompleted();
        4: 2134:        if( m_reaction.shouldDebugBreak ) {
        -: 2135:
        -: 2136:            // If you find your debugger stopping you here then go one level up on the
        -: 2137:            // call-stack for the code that caused it (typically a failed assertion)
        -: 2138:
        -: 2139:            // (To go back to the test and change execution, jump over the throw, next)
    #####: 2140:            CATCH_BREAK_INTO_DEBUGGER();
        -: 2141:        }
        4: 2142:        if (m_reaction.shouldThrow) {
        -: 2143:#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
    #####: 2144:            throw Catch::TestFailureException();
        -: 2145:#else
        -: 2146:            CATCH_ERROR( "Test failure requires aborting test!" );
        -: 2147:#endif
        -: 2148:        }
        4: 2149:    }
    #####: 2150:    void AssertionHandler::setCompleted() {
        4: 2151:        m_completed = true;
    #####: 2152:    }
        -: 2153:
    #####: 2154:    void AssertionHandler::handleUnexpectedInflightException() {
    #####: 2155:        m_resultCapture.handleUnexpectedInflightException( m_assertionInfo, Catch::translateActiveException(), m_reaction );
    #####: 2156:    }
        -: 2157:
    #####: 2158:    void AssertionHandler::handleExceptionThrownAsExpected() {
    #####: 2159:        m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
    #####: 2160:    }
    #####: 2161:    void AssertionHandler::handleExceptionNotThrownAsExpected() {
    #####: 2162:        m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
    #####: 2163:    }
        -: 2164:
    #####: 2165:    void AssertionHandler::handleUnexpectedExceptionNotThrown() {
    #####: 2166:        m_resultCapture.handleUnexpectedExceptionNotThrown( m_assertionInfo, m_reaction );
    #####: 2167:    }
        -: 2168:
    #####: 2169:    void AssertionHandler::handleThrowingCallSkipped() {
    #####: 2170:        m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
    #####: 2171:    }
        -: 2172:
        -: 2173:    // This is the overload that takes a string and infers the Equals matcher from it
        -: 2174:    // The more general overload, that takes any string matcher, is in catch_capture_matchers.cpp
    #####: 2175:    void handleExceptionMatchExpr( AssertionHandler& handler, std::string const& str, StringRef const& matcherString  ) {
    #####: 2176:        handleExceptionMatchExpr( handler, Matchers::Equals( str ), matcherString );
    #####: 2177:    }
        -: 2178:
        -: 2179:} // namespace Catch
        -: 2180:
        -: 2181:
        -: 2182:#include <algorithm>
        -: 2183:
        -: 2184:namespace {
        -: 2185:    bool isOptPrefix( char c ) {
        -: 2186:        return c == '-'
        -: 2187:#ifdef CATCH_PLATFORM_WINDOWS
        -: 2188:               || c == '/'
        -: 2189:#endif
        -: 2190:            ;
        -: 2191:    }
        -: 2192:
        -: 2193:    std::string normaliseOpt( std::string const& optName ) {
        -: 2194:#ifdef CATCH_PLATFORM_WINDOWS
        -: 2195:        if ( optName[0] == '/' )
        -: 2196:            return "-" + optName.substr( 1 );
        -: 2197:        else
        -: 2198:#endif
        -: 2199:            return optName;
        -: 2200:    }
        -: 2201:
        -: 2202:} // namespace
        -: 2203:
        -: 2204:namespace Catch {
        -: 2205:    namespace Clara {
        -: 2206:        namespace Detail {
        -: 2207:
        1: 2208:            void TokenStream::loadBuffer() {
        1: 2209:                m_tokenBuffer.clear();
        -: 2210:
        -: 2211:                // Skip any empty strings
        1: 2212:                while ( it != itEnd && it->empty() ) {
        -: 2213:                    ++it;
        -: 2214:                }
        -: 2215:
        1: 2216:                if ( it != itEnd ) {
        -: 2217:                    auto const& next = *it;
    #####: 2218:                    if ( isOptPrefix( next[0] ) ) {
        -: 2219:                        auto delimiterPos = next.find_first_of( " :=" );
    #####: 2220:                        if ( delimiterPos != std::string::npos ) {
    #####: 2221:                            m_tokenBuffer.push_back(
        -: 2222:                                { TokenType::Option,
        -: 2223:                                  next.substr( 0, delimiterPos ) } );
    #####: 2224:                            m_tokenBuffer.push_back(
        -: 2225:                                { TokenType::Argument,
        -: 2226:                                  next.substr( delimiterPos + 1 ) } );
        -: 2227:                        } else {
    #####: 2228:                            if ( next[1] != '-' && next.size() > 2 ) {
    #####: 2229:                                std::string opt = "- ";
    #####: 2230:                                for ( size_t i = 1; i < next.size(); ++i ) {
    #####: 2231:                                    opt[1] = next[i];
    #####: 2232:                                    m_tokenBuffer.push_back(
        -: 2233:                                        { TokenType::Option, opt } );
        -: 2234:                                }
        -: 2235:                            } else {
    #####: 2236:                                m_tokenBuffer.push_back(
        -: 2237:                                    { TokenType::Option, next } );
        -: 2238:                            }
        -: 2239:                        }
        -: 2240:                    } else {
    #####: 2241:                        m_tokenBuffer.push_back(
        -: 2242:                            { TokenType::Argument, next } );
        -: 2243:                    }
        -: 2244:                }
        1: 2245:            }
        -: 2246:
    #####: 2247:            TokenStream::TokenStream( Args const& args ):
        1: 2248:                TokenStream( args.m_args.begin(), args.m_args.end() ) {}
        -: 2249:
        1: 2250:            TokenStream::TokenStream( Iterator it_, Iterator itEnd_ ):
        1: 2251:                it( it_ ), itEnd( itEnd_ ) {
        1: 2252:                loadBuffer();
        1: 2253:            }
        -: 2254:
    #####: 2255:            TokenStream& TokenStream::operator++() {
    #####: 2256:                if ( m_tokenBuffer.size() >= 2 ) {
    #####: 2257:                    m_tokenBuffer.erase( m_tokenBuffer.begin() );
        -: 2258:                } else {
    #####: 2259:                    if ( it != itEnd )
        -: 2260:                        ++it;
    #####: 2261:                    loadBuffer();
        -: 2262:                }
    #####: 2263:                return *this;
        -: 2264:            }
        -: 2265:
    #####: 2266:            ParserResult convertInto( std::string const& source,
        -: 2267:                                      std::string& target ) {
        -: 2268:                target = source;
    #####: 2269:                return ParserResult::ok( ParseResultType::Matched );
        -: 2270:            }
        -: 2271:
    #####: 2272:            ParserResult convertInto( std::string const& source,
        -: 2273:                                      bool& target ) {
        -: 2274:                std::string srcLC = toLower( source );
        -: 2275:
    #####: 2276:                if ( srcLC == "y" || srcLC == "1" || srcLC == "true" ||
    #####: 2277:                     srcLC == "yes" || srcLC == "on" ) {
    #####: 2278:                    target = true;
    #####: 2279:                } else if ( srcLC == "n" || srcLC == "0" || srcLC == "false" ||
    #####: 2280:                            srcLC == "no" || srcLC == "off" ) {
    #####: 2281:                    target = false;
        -: 2282:                } else {
        -: 2283:                    return ParserResult::runtimeError(
    #####: 2284:                        "Expected a boolean value but did not recognise: '" +
    #####: 2285:                        source + "'" );
        -: 2286:                }
        -: 2287:                return ParserResult::ok( ParseResultType::Matched );
        -: 2288:            }
        -: 2289:
    #####: 2290:            size_t ParserBase::cardinality() const { return 1; }
        -: 2291:
        1: 2292:            InternalParseResult ParserBase::parse( Args const& args ) const {
        3: 2293:                return parse( args.exeName(), TokenStream( args ) );
        -: 2294:            }
        -: 2295:
    #####: 2296:            ParseState::ParseState( ParseResultType type,
        -: 2297:                                    TokenStream const& remainingTokens ):
        1: 2298:                m_type( type ), m_remainingTokens( remainingTokens ) {}
        -: 2299:
    #####: 2300:            ParserResult BoundFlagRef::setFlag( bool flag ) {
    #####: 2301:                m_ref = flag;
    #####: 2302:                return ParserResult::ok( ParseResultType::Matched );
        -: 2303:            }
        -: 2304:
        -: 2305:            ResultBase::~ResultBase() = default;
        -: 2306:
    #####: 2307:            bool BoundRef::isContainer() const { return false; }
        -: 2308:
    #####: 2309:            bool BoundRef::isFlag() const { return false; }
        -: 2310:
    #####: 2311:            bool BoundFlagRefBase::isFlag() const { return true; }
        -: 2312:
        -: 2313:} // namespace Detail
        -: 2314:
    #####: 2315:        Detail::InternalParseResult Arg::parse(std::string const&,
        -: 2316:                                               Detail::TokenStream const& tokens) const {
    #####: 2317:            auto validationResult = validate();
    #####: 2318:            if (!validationResult)
    #####: 2319:                return Detail::InternalParseResult(validationResult);
        -: 2320:
        -: 2321:            auto remainingTokens = tokens;
    #####: 2322:            auto const& token = *remainingTokens;
    #####: 2323:            if (token.type != Detail::TokenType::Argument)
        -: 2324:                return Detail::InternalParseResult::ok(Detail::ParseState(
    #####: 2325:                    ParseResultType::NoMatch, remainingTokens));
        -: 2326:
    #####: 2327:            assert(!m_ref->isFlag());
        -: 2328:            auto valueRef =
        -: 2329:                static_cast<Detail::BoundValueRefBase*>(m_ref.get());
        -: 2330:
    #####: 2331:            auto result = valueRef->setValue(remainingTokens->token);
    #####: 2332:            if (!result)
    #####: 2333:                return Detail::InternalParseResult(result);
        -: 2334:            else
        -: 2335:                return Detail::InternalParseResult::ok(Detail::ParseState(
    #####: 2336:                    ParseResultType::Matched, ++remainingTokens));
        -: 2337:        }
        -: 2338:
       10: 2339:        Opt::Opt(bool& ref) :
       30: 2340:            ParserRefImpl(std::make_shared<Detail::BoundFlagRef>(ref)) {}
        -: 2341:
    #####: 2342:        std::vector<Detail::HelpColumns> Opt::getHelpColumns() const {
    #####: 2343:            std::ostringstream oss;
        -: 2344:            bool first = true;
    #####: 2345:            for (auto const& opt : m_optNames) {
    #####: 2346:                if (first)
        -: 2347:                    first = false;
        -: 2348:                else
    #####: 2349:                    oss << ", ";
        -: 2350:                oss << opt;
        -: 2351:            }
    #####: 2352:            if (!m_hint.empty())
        -: 2353:                oss << " <" << m_hint << '>';
    #####: 2354:            return { { oss.str(), m_description } };
        -: 2355:        }
        -: 2356:
    #####: 2357:        bool Opt::isMatch(std::string const& optToken) const {
        -: 2358:            auto normalisedToken = normaliseOpt(optToken);
    #####: 2359:            for (auto const& name : m_optNames) {
    #####: 2360:                if (normaliseOpt(name) == normalisedToken)
        -: 2361:                    return true;
        -: 2362:            }
        -: 2363:            return false;
        -: 2364:        }
        -: 2365:
    #####: 2366:        Detail::InternalParseResult Opt::parse(std::string const&,
        -: 2367:                                       Detail::TokenStream const& tokens) const {
    #####: 2368:            auto validationResult = validate();
    #####: 2369:            if (!validationResult)
    #####: 2370:                return Detail::InternalParseResult(validationResult);
        -: 2371:
        -: 2372:            auto remainingTokens = tokens;
    #####: 2373:            if (remainingTokens &&
    #####: 2374:                remainingTokens->type == Detail::TokenType::Option) {
    #####: 2375:                auto const& token = *remainingTokens;
    #####: 2376:                if (isMatch(token.token)) {
    #####: 2377:                    if (m_ref->isFlag()) {
        -: 2378:                        auto flagRef =
        -: 2379:                            static_cast<Detail::BoundFlagRefBase*>(
        -: 2380:                                m_ref.get());
    #####: 2381:                        auto result = flagRef->setFlag(true);
    #####: 2382:                        if (!result)
    #####: 2383:                            return Detail::InternalParseResult(result);
    #####: 2384:                        if (result.value() ==
        -: 2385:                            ParseResultType::ShortCircuitAll)
        -: 2386:                            return Detail::InternalParseResult::ok(Detail::ParseState(
    #####: 2387:                                result.value(), remainingTokens));
        -: 2388:                    } else {
        -: 2389:                        auto valueRef =
        -: 2390:                            static_cast<Detail::BoundValueRefBase*>(
        -: 2391:                                m_ref.get());
    #####: 2392:                        ++remainingTokens;
    #####: 2393:                        if (!remainingTokens)
        -: 2394:                            return Detail::InternalParseResult::runtimeError(
    #####: 2395:                                "Expected argument following " +
        -: 2396:                                token.token);
    #####: 2397:                        auto const& argToken = *remainingTokens;
    #####: 2398:                        if (argToken.type != Detail::TokenType::Argument)
        -: 2399:                            return Detail::InternalParseResult::runtimeError(
    #####: 2400:                                "Expected argument following " +
        -: 2401:                                token.token);
    #####: 2402:                        auto result = valueRef->setValue(argToken.token);
    #####: 2403:                        if (!result)
    #####: 2404:                            return Detail::InternalParseResult(result);
    #####: 2405:                        if (result.value() ==
        -: 2406:                            ParseResultType::ShortCircuitAll)
        -: 2407:                            return Detail::InternalParseResult::ok(Detail::ParseState(
    #####: 2408:                                result.value(), remainingTokens));
        -: 2409:                    }
        -: 2410:                    return Detail::InternalParseResult::ok(Detail::ParseState(
    #####: 2411:                        ParseResultType::Matched, ++remainingTokens));
        -: 2412:                }
        -: 2413:            }
        -: 2414:            return Detail::InternalParseResult::ok(
    #####: 2415:                Detail::ParseState(ParseResultType::NoMatch, remainingTokens));
        -: 2416:        }
        -: 2417:
    #####: 2418:        Detail::Result Opt::validate() const {
    #####: 2419:            if (m_optNames.empty())
    #####: 2420:                return Detail::Result::logicError("No options supplied to Opt");
    #####: 2421:            for (auto const& name : m_optNames) {
    #####: 2422:                if (name.empty())
        -: 2423:                    return Detail::Result::logicError(
    #####: 2424:                        "Option name cannot be empty");
        -: 2425:#ifdef CATCH_PLATFORM_WINDOWS
        -: 2426:                if (name[0] != '-' && name[0] != '/')
        -: 2427:                    return Detail::Result::logicError(
        -: 2428:                        "Option name must begin with '-' or '/'");
        -: 2429:#else
    #####: 2430:                if (name[0] != '-')
        -: 2431:                    return Detail::Result::logicError(
    #####: 2432:                        "Option name must begin with '-'");
        -: 2433:#endif
        -: 2434:            }
        -: 2435:            return ParserRefImpl::validate();
        -: 2436:        }
        -: 2437:
        3: 2438:        ExeName::ExeName() :
        6: 2439:            m_name(std::make_shared<std::string>("<executable>")) {}
        -: 2440:
        1: 2441:        ExeName::ExeName(std::string& ref) : ExeName() {
        1: 2442:            m_ref = std::make_shared<Detail::BoundValueRef<std::string>>(ref);
        1: 2443:        }
        -: 2444:
        -: 2445:        Detail::InternalParseResult
    #####: 2446:            ExeName::parse(std::string const&,
        -: 2447:                           Detail::TokenStream const& tokens) const {
        -: 2448:            return Detail::InternalParseResult::ok(
    #####: 2449:                Detail::ParseState(ParseResultType::NoMatch, tokens));
        -: 2450:        }
        -: 2451:
        1: 2452:        ParserResult ExeName::set(std::string const& newName) {
        -: 2453:            auto lastSlash = newName.find_last_of("\\/");
        -: 2454:            auto filename = (lastSlash == std::string::npos)
        -: 2455:                ? newName
        2: 2456:                : newName.substr(lastSlash + 1);
        -: 2457:
        -: 2458:            *m_name = filename;
        1: 2459:            if (m_ref)
        1: 2460:                return m_ref->setValue(filename);
        -: 2461:            else
        -: 2462:                return ParserResult::ok(ParseResultType::Matched);
        -: 2463:        }
        -: 2464:
        -: 2465:
        -: 2466:
        -: 2467:
    #####: 2468:        Parser& Parser::operator|=( Parser const& other ) {
        -: 2469:            m_options.insert( m_options.end(),
        -: 2470:                              other.m_options.begin(),
    #####: 2471:                              other.m_options.end() );
        -: 2472:            m_args.insert(
    #####: 2473:                m_args.end(), other.m_args.begin(), other.m_args.end() );
    #####: 2474:            return *this;
        -: 2475:        }
        -: 2476:
    #####: 2477:        std::vector<Detail::HelpColumns> Parser::getHelpColumns() const {
        -: 2478:            std::vector<Detail::HelpColumns> cols;
    #####: 2479:            for ( auto const& o : m_options ) {
    #####: 2480:                auto childCols = o.getHelpColumns();
    #####: 2481:                cols.insert( cols.end(), childCols.begin(), childCols.end() );
        -: 2482:            }
    #####: 2483:            return cols;
        -: 2484:        }
        -: 2485:
    #####: 2486:        void Parser::writeToStream( std::ostream& os ) const {
    #####: 2487:            if ( !m_exeName.name().empty() ) {
        -: 2488:                os << "usage:\n"
        -: 2489:                   << "  " << m_exeName.name() << ' ';
        -: 2490:                bool required = true, first = true;
    #####: 2491:                for ( auto const& arg : m_args ) {
    #####: 2492:                    if ( first )
        -: 2493:                        first = false;
        -: 2494:                    else
        -: 2495:                        os << ' ';
    #####: 2496:                    if ( arg.isOptional() && required ) {
        -: 2497:                        os << '[';
        -: 2498:                        required = false;
        -: 2499:                    }
        -: 2500:                    os << '<' << arg.hint() << '>';
    #####: 2501:                    if ( arg.cardinality() == 0 )
    #####: 2502:                        os << " ... ";
        -: 2503:                }
    #####: 2504:                if ( !required )
        -: 2505:                    os << ']';
    #####: 2506:                if ( !m_options.empty() )
    #####: 2507:                    os << " options";
    #####: 2508:                os << "\n\nwhere options are:\n";
        -: 2509:            }
        -: 2510:
    #####: 2511:            auto rows = getHelpColumns();
        -: 2512:            size_t consoleWidth = CATCH_CONFIG_CONSOLE_WIDTH;
    #####: 2513:            size_t optWidth = 0;
    #####: 2514:            for ( auto const& cols : rows )
    #####: 2515:                optWidth = ( std::max )( optWidth, cols.left.size() + 2 );
        -: 2516:
    #####: 2517:            optWidth = ( std::min )( optWidth, consoleWidth / 2 );
        -: 2518:
    #####: 2519:            for ( auto const& cols : rows ) {
        -: 2520:                auto row = TextFlow::Column( cols.left )
    #####: 2521:                               .width( optWidth )
    #####: 2522:                               .indent( 2 ) +
    #####: 2523:                           TextFlow::Spacer( 4 ) +
        -: 2524:                           TextFlow::Column( cols.right )
    #####: 2525:                               .width( consoleWidth - 7 - optWidth );
    #####: 2526:                os << row << '\n';
        -: 2527:            }
    #####: 2528:        }
        -: 2529:
    #####: 2530:        Detail::Result Parser::validate() const {
    #####: 2531:            for ( auto const& opt : m_options ) {
    #####: 2532:                auto result = opt.validate();
    #####: 2533:                if ( !result )
        -: 2534:                    return result;
        -: 2535:            }
    #####: 2536:            for ( auto const& arg : m_args ) {
    #####: 2537:                auto result = arg.validate();
    #####: 2538:                if ( !result )
        -: 2539:                    return result;
        -: 2540:            }
        -: 2541:            return Detail::Result::ok();
        -: 2542:        }
        -: 2543:
        -: 2544:        Detail::InternalParseResult
        1: 2545:        Parser::parse( std::string const& exeName,
        -: 2546:                       Detail::TokenStream const& tokens ) const {
        -: 2547:
        -: 2548:            struct ParserInfo {
        -: 2549:                ParserBase const* parser = nullptr;
        -: 2550:                size_t count = 0;
        -: 2551:            };
        -: 2552:            std::vector<ParserInfo> parseInfos;
        1: 2553:            parseInfos.reserve( m_options.size() + m_args.size() );
       31: 2554:            for ( auto const& opt : m_options ) {
       60: 2555:                parseInfos.push_back( { &opt, 0 } );
        -: 2556:            }
        2: 2557:            for ( auto const& arg : m_args ) {
        2: 2558:                parseInfos.push_back( { &arg, 0 } );
        -: 2559:            }
        -: 2560:
        2: 2561:            m_exeName.set( exeName );
        -: 2562:
        -: 2563:            auto result = Detail::InternalParseResult::ok(
        2: 2564:                Detail::ParseState( ParseResultType::NoMatch, tokens ) );
        1: 2565:            while ( result.value().remainingTokens() ) {
        -: 2566:                bool tokenParsed = false;
        -: 2567:
    #####: 2568:                for ( auto& parseInfo : parseInfos ) {
    #####: 2569:                    if ( parseInfo.parser->cardinality() == 0 ||
    #####: 2570:                         parseInfo.count < parseInfo.parser->cardinality() ) {
    #####: 2571:                        result = parseInfo.parser->parse(
    #####: 2572:                            exeName, result.value().remainingTokens() );
    #####: 2573:                        if ( !result )
    #####: 2574:                            return result;
    #####: 2575:                        if ( result.value().type() !=
        -: 2576:                             ParseResultType::NoMatch ) {
        -: 2577:                            tokenParsed = true;
    #####: 2578:                            ++parseInfo.count;
    #####: 2579:                            break;
        -: 2580:                        }
        -: 2581:                    }
        -: 2582:                }
        -: 2583:
    #####: 2584:                if ( result.value().type() == ParseResultType::ShortCircuitAll )
    #####: 2585:                    return result;
    #####: 2586:                if ( !tokenParsed )
        -: 2587:                    return Detail::InternalParseResult::runtimeError(
    #####: 2588:                        "Unrecognised token: " +
        -: 2589:                        result.value().remainingTokens()->token );
        -: 2590:            }
        -: 2591:            // !TBD Check missing required options
        1: 2592:            return result;
        -: 2593:        }
        -: 2594:
        1: 2595:        Args::Args(int argc, char const* const* argv) :
        1: 2596:            m_exeName(argv[0]), m_args(argv + 1, argv + argc) {}
        -: 2597:
    #####: 2598:        Args::Args(std::initializer_list<std::string> args) :
        -: 2599:            m_exeName(*args.begin()),
    #####: 2600:            m_args(args.begin() + 1, args.end()) {}
        -: 2601:
        -: 2602:
        1: 2603:        Help::Help( bool& showHelpFlag ):
        -: 2604:            Opt( [&]( bool flag ) {
    #####: 2605:                showHelpFlag = flag;
        -: 2606:                return ParserResult::ok( ParseResultType::ShortCircuitAll );
        1: 2607:            } ) {
        -: 2608:            static_cast<Opt&> ( *this )(
        5: 2609:                "display usage information" )["-?"]["-h"]["--help"]
        -: 2610:                .optional();
        1: 2611:        }
        -: 2612:
        -: 2613:    } // namespace Clara
        -: 2614:} // namespace Catch
        -: 2615:
        -: 2616:
        -: 2617:/** \file
        -: 2618: * This is a special TU that combines what would otherwise be a very
        -: 2619: * small top-level TUs into one bigger TU.
        -: 2620: *
        -: 2621: * The reason for this is compilation performance improvements by
        -: 2622: * avoiding reparsing headers for many small TUs, instead having this
        -: 2623: * one TU include bit more, but having it all parsed only once.
        -: 2624: *
        -: 2625: * To avoid heavy-tail problem with compilation times, each "subpart"
        -: 2626: * of Catch2 has its own combined TU like this.
        -: 2627: */
        -: 2628:
        -: 2629:
        -: 2630:////////////////////////////////////////////////////////
        -: 2631:// vvv formerly catch_tag_alias_autoregistrar.cpp vvv //
        -: 2632:////////////////////////////////////////////////////////
        -: 2633:
        -: 2634:
        -: 2635:namespace Catch {
        -: 2636:
    #####: 2637:    RegistrarForTagAliases::RegistrarForTagAliases(char const* alias, char const* tag, SourceLineInfo const& lineInfo) {
        -: 2638:        CATCH_TRY {
    #####: 2639:            getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);
    =====: 2640:        } CATCH_CATCH_ALL {
        -: 2641:            // Do not throw when constructing global objects, instead register the exception to be processed later
    =====: 2642:            getMutableRegistryHub().registerStartupException();
        -: 2643:        }
    #####: 2644:    }
        -: 2645:
        -: 2646:}
        -: 2647:
        -: 2648:
        -: 2649://////////////////////////////////////////
        -: 2650:// vvv formerly catch_polyfills.cpp vvv //
        -: 2651://////////////////////////////////////////
        -: 2652:
        -: 2653:#include <cmath>
        -: 2654:
        -: 2655:namespace Catch {
        -: 2656:
        -: 2657:#if !defined(CATCH_CONFIG_POLYFILL_ISNAN)
    #####: 2658:    bool isnan(float f) {
    #####: 2659:        return std::isnan(f);
        -: 2660:    }
    #####: 2661:    bool isnan(double d) {
    #####: 2662:        return std::isnan(d);
        -: 2663:    }
        -: 2664:#else
        -: 2665:    // For now we only use this for embarcadero
        -: 2666:    bool isnan(float f) {
        -: 2667:        return std::_isnan(f);
        -: 2668:    }
        -: 2669:    bool isnan(double d) {
        -: 2670:        return std::_isnan(d);
        -: 2671:    }
        -: 2672:#endif
        -: 2673:
        -: 2674:} // end namespace Catch
        -: 2675:
        -: 2676:
        -: 2677:////////////////////////////////////////////////////
        -: 2678:// vvv formerly catch_uncaught_exceptions.cpp vvv //
        -: 2679:////////////////////////////////////////////////////
        -: 2680:
        -: 2681:
        -: 2682:#include <exception>
        -: 2683:
        -: 2684:namespace Catch {
    #####: 2685:    bool uncaught_exceptions() {
        -: 2686:#if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
        -: 2687:        return false;
        -: 2688:#elif defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
        -: 2689:        return std::uncaught_exceptions() > 0;
        -: 2690:#else
    #####: 2691:        return std::uncaught_exception();
        -: 2692:#endif
        -: 2693:  }
        -: 2694:} // end namespace Catch
        -: 2695:
        -: 2696:
        -: 2697:////////////////////////////////////////////
        -: 2698:// vvv formerly catch_errno_guard.cpp vvv //
        -: 2699:////////////////////////////////////////////
        -: 2700:
        -: 2701:#include <cerrno>
        -: 2702:
        -: 2703:namespace Catch {
        1: 2704:        ErrnoGuard::ErrnoGuard():m_oldErrno(errno){}
        1: 2705:        ErrnoGuard::~ErrnoGuard() { errno = m_oldErrno; }
        -: 2706:}
        -: 2707:
        -: 2708:
        -: 2709:///////////////////////////////////////////
        -: 2710:// vvv formerly catch_decomposer.cpp vvv //
        -: 2711:///////////////////////////////////////////
        -: 2712:
        -: 2713:namespace Catch {
        -: 2714:
        -: 2715:    ITransientExpression::~ITransientExpression() = default;
        -: 2716:
    #####: 2717:    void formatReconstructedExpression( std::ostream &os, std::string const& lhs, StringRef op, std::string const& rhs ) {
    #####: 2718:        if( lhs.size() + rhs.size() < 40 &&
    #####: 2719:                lhs.find('\n') == std::string::npos &&
    #####: 2720:                rhs.find('\n') == std::string::npos )
        -: 2721:            os << lhs << ' ' << op << ' ' << rhs;
        -: 2722:        else
        -: 2723:            os << lhs << '\n' << op << '\n' << rhs;
    #####: 2724:    }
        -: 2725:}
        -: 2726:
        -: 2727:
        -: 2728:///////////////////////////////////////////////////////////
        -: 2729:// vvv formerly catch_startup_exception_registry.cpp vvv //
        -: 2730:///////////////////////////////////////////////////////////
        -: 2731:
        -: 2732:namespace Catch {
        -: 2733:#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
    #####: 2734:    void StartupExceptionRegistry::add( std::exception_ptr const& exception ) noexcept {
        -: 2735:        CATCH_TRY {
    #####: 2736:            m_exceptions.push_back(exception);
    =====: 2737:        } CATCH_CATCH_ALL {
        -: 2738:            // If we run out of memory during start-up there's really not a lot more we can do about it
    =====: 2739:            std::terminate();
        -: 2740:        }
    #####: 2741:    }
        -: 2742:
    #####: 2743:    std::vector<std::exception_ptr> const& StartupExceptionRegistry::getExceptions() const noexcept {
    #####: 2744:        return m_exceptions;
        -: 2745:    }
        -: 2746:#endif
        -: 2747:
        -: 2748:} // end namespace Catch
        -: 2749:
        -: 2750:
        -: 2751://////////////////////////////////////////////
        -: 2752:// vvv formerly catch_leak_detector.cpp vvv //
        -: 2753://////////////////////////////////////////////
        -: 2754:
        -: 2755:
        -: 2756:#ifdef CATCH_CONFIG_WINDOWS_CRTDBG
        -: 2757:#include <crtdbg.h>
        -: 2758:
        -: 2759:namespace Catch {
        -: 2760:
        -: 2761:    LeakDetector::LeakDetector() {
        -: 2762:        int flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
        -: 2763:        flag |= _CRTDBG_LEAK_CHECK_DF;
        -: 2764:        flag |= _CRTDBG_ALLOC_MEM_DF;
        -: 2765:        _CrtSetDbgFlag(flag);
        -: 2766:        _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
        -: 2767:        _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
        -: 2768:        // Change this to leaking allocation's number to break there
        -: 2769:        _CrtSetBreakAlloc(-1);
        -: 2770:    }
        -: 2771:}
        -: 2772:
        -: 2773:#else // ^^ Windows crt debug heap enabled // Windows crt debug heap disabled vv
        -: 2774:
    #####: 2775:    Catch::LeakDetector::LeakDetector() {}
        -: 2776:
        -: 2777:#endif // CATCH_CONFIG_WINDOWS_CRTDBG
        -: 2778:
    #####: 2779:Catch::LeakDetector::~LeakDetector() {
    #####: 2780:    Catch::cleanUp();
    #####: 2781:}
        -: 2782:
        -: 2783:
        -: 2784://///////////////////////////////////////////
        -: 2785:// vvv formerly catch_message_info.cpp vvv //
        -: 2786://///////////////////////////////////////////
        -: 2787:
        -: 2788:
        -: 2789:namespace Catch {
        -: 2790:
    #####: 2791:    MessageInfo::MessageInfo(   StringRef const& _macroName,
        -: 2792:                                SourceLineInfo const& _lineInfo,
        -: 2793:                                ResultWas::OfType _type )
        -: 2794:    :   macroName( _macroName ),
        -: 2795:        lineInfo( _lineInfo ),
        -: 2796:        type( _type ),
    #####: 2797:        sequence( ++globalCount )
    #####: 2798:    {}
        -: 2799:
        -: 2800:    // This may need protecting if threading support is added
        -: 2801:    unsigned int MessageInfo::globalCount = 0;
        -: 2802:
        -: 2803:} // end namespace Catch
        -: 2804:
        -: 2805:
        -: 2806:
        -: 2807:
        -: 2808://////////////////////////////////////////
        -: 2809:// vvv formerly catch_lazy_expr.cpp vvv //
        -: 2810://////////////////////////////////////////
        -: 2811:
        -: 2812:namespace Catch {
        -: 2813:
    #####: 2814:    auto operator << (std::ostream& os, LazyExpression const& lazyExpr) -> std::ostream& {
    #####: 2815:        if (lazyExpr.m_isNegated)
    #####: 2816:            os << "!";
        -: 2817:
    #####: 2818:        if (lazyExpr) {
    #####: 2819:            if (lazyExpr.m_isNegated && lazyExpr.m_transientExpression->isBinaryExpression())
    #####: 2820:                os << "(" << *lazyExpr.m_transientExpression << ")";
        -: 2821:            else
        -: 2822:                os << *lazyExpr.m_transientExpression;
        -: 2823:        } else {
    #####: 2824:            os << "{** error - unchecked empty expression requested **}";
        -: 2825:        }
    #####: 2826:        return os;
        -: 2827:    }
        -: 2828:
        -: 2829:} // namespace Catch
        -: 2830:
        -: 2831:
        -: 2832:
        -: 2833:
        -: 2834:#include <fstream>
        -: 2835:#include <ctime>
        -: 2836:
        -: 2837:namespace Catch {
        -: 2838:
        1: 2839:    Clara::Parser makeCommandLineParser( ConfigData& config ) {
        -: 2840:
        -: 2841:        using namespace Clara;
        -: 2842:
    #####: 2843:        auto const setWarning = [&]( std::string const& warning ) {
    #####: 2844:                auto warningSet = [&]() {
    #####: 2845:                    if( warning == "NoAssertions" )
        -: 2846:                        return WarnAbout::NoAssertions;
        -: 2847:
    #####: 2848:                    if ( warning == "NoTests" )
        -: 2849:                        return WarnAbout::NoTests;
        -: 2850:
    #####: 2851:                    return WarnAbout::Nothing;
    #####: 2852:                }();
        -: 2853:
    #####: 2854:                if (warningSet == WarnAbout::Nothing)
    #####: 2855:                    return ParserResult::runtimeError( "Unrecognised warning: '" + warning + "'" );
    #####: 2856:                config.warnings = static_cast<WarnAbout::What>( config.warnings | warningSet );
        -: 2857:                return ParserResult::ok( ParseResultType::Matched );
        1: 2858:            };
    #####: 2859:        auto const loadTestNamesFromFile = [&]( std::string const& filename ) {
    #####: 2860:                std::ifstream f( filename.c_str() );
    #####: 2861:                if( !f.is_open() )
    #####: 2862:                    return ParserResult::runtimeError( "Unable to load input file: '" + filename + "'" );
        -: 2863:
        -: 2864:                std::string line;
    #####: 2865:                while( std::getline( f, line ) ) {
    #####: 2866:                    line = trim(line);
    #####: 2867:                    if( !line.empty() && !startsWith( line, '#' ) ) {
    #####: 2868:                        if( !startsWith( line, '"' ) )
    #####: 2869:                            line = '"' + line + '"';
    #####: 2870:                        config.testsOrTags.push_back( line );
    #####: 2871:                        config.testsOrTags.emplace_back( "," );
        -: 2872:                    }
        -: 2873:                }
        -: 2874:                //Remove comma in the end
    #####: 2875:                if(!config.testsOrTags.empty())
    #####: 2876:                    config.testsOrTags.erase( config.testsOrTags.end()-1 );
        -: 2877:
        -: 2878:                return ParserResult::ok( ParseResultType::Matched );
        1: 2879:            };
    #####: 2880:        auto const setTestOrder = [&]( std::string const& order ) {
    #####: 2881:                if( startsWith( "declared", order ) )
    #####: 2882:                    config.runOrder = TestRunOrder::Declared;
    #####: 2883:                else if( startsWith( "lexical", order ) )
    #####: 2884:                    config.runOrder = TestRunOrder::LexicographicallySorted;
    #####: 2885:                else if( startsWith( "random", order ) )
    #####: 2886:                    config.runOrder = TestRunOrder::Randomized;
        -: 2887:                else
    #####: 2888:                    return ParserResult::runtimeError( "Unrecognised ordering: '" + order + "'" );
        -: 2889:                return ParserResult::ok( ParseResultType::Matched );
        1: 2890:            };
    #####: 2891:        auto const setRngSeed = [&]( std::string const& seed ) {
    #####: 2892:                if( seed != "time" )
    #####: 2893:                    return Clara::Detail::convertInto( seed, config.rngSeed );
    #####: 2894:                config.rngSeed = static_cast<unsigned int>( std::time(nullptr) );
        -: 2895:                return ParserResult::ok( ParseResultType::Matched );
        1: 2896:            };
    #####: 2897:        auto const setColourUsage = [&]( std::string const& useColour ) {
        -: 2898:                    auto mode = toLower( useColour );
        -: 2899:
    #####: 2900:                    if( mode == "yes" )
    #####: 2901:                        config.useColour = UseColour::Yes;
    #####: 2902:                    else if( mode == "no" )
    #####: 2903:                        config.useColour = UseColour::No;
    #####: 2904:                    else if( mode == "auto" )
    #####: 2905:                        config.useColour = UseColour::Auto;
        -: 2906:                    else
    #####: 2907:                        return ParserResult::runtimeError( "colour mode must be one of: auto, yes or no. '" + useColour + "' not recognised" );
        -: 2908:                return ParserResult::ok( ParseResultType::Matched );
        1: 2909:            };
    #####: 2910:        auto const setWaitForKeypress = [&]( std::string const& keypress ) {
        -: 2911:                auto keypressLc = toLower( keypress );
    #####: 2912:                if (keypressLc == "never")
    #####: 2913:                    config.waitForKeypress = WaitForKeypress::Never;
    #####: 2914:                else if( keypressLc == "start" )
    #####: 2915:                    config.waitForKeypress = WaitForKeypress::BeforeStart;
    #####: 2916:                else if( keypressLc == "exit" )
    #####: 2917:                    config.waitForKeypress = WaitForKeypress::BeforeExit;
    #####: 2918:                else if( keypressLc == "both" )
    #####: 2919:                    config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;
        -: 2920:                else
    #####: 2921:                    return ParserResult::runtimeError( "keypress argument must be one of: never, start, exit or both. '" + keypress + "' not recognised" );
        -: 2922:            return ParserResult::ok( ParseResultType::Matched );
        1: 2923:            };
    #####: 2924:        auto const setVerbosity = [&]( std::string const& verbosity ) {
        -: 2925:            auto lcVerbosity = toLower( verbosity );
    #####: 2926:            if( lcVerbosity == "quiet" )
    #####: 2927:                config.verbosity = Verbosity::Quiet;
    #####: 2928:            else if( lcVerbosity == "normal" )
    #####: 2929:                config.verbosity = Verbosity::Normal;
    #####: 2930:            else if( lcVerbosity == "high" )
    #####: 2931:                config.verbosity = Verbosity::High;
        -: 2932:            else
    #####: 2933:                return ParserResult::runtimeError( "Unrecognised verbosity, '" + verbosity + "'" );
        -: 2934:            return ParserResult::ok( ParseResultType::Matched );
        1: 2935:        };
    #####: 2936:        auto const setReporter = [&]( std::string const& reporter ) {
    #####: 2937:            IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();
        -: 2938:
        -: 2939:            auto lcReporter = toLower( reporter );
        -: 2940:            auto result = factories.find( lcReporter );
        -: 2941:
    #####: 2942:            if( factories.end() != result )
    #####: 2943:                config.reporterName = lcReporter;
        -: 2944:            else
    #####: 2945:                return ParserResult::runtimeError( "Unrecognized reporter, '" + reporter + "'. Check available with --list-reporters" );
        -: 2946:            return ParserResult::ok( ParseResultType::Matched );
        1: 2947:        };
        -: 2948:
        -: 2949:        auto cli
        -: 2950:            = ExeName( config.processName )
        3: 2951:            | Help( config.showHelp )
        2: 2952:            | Opt( config.listTests )
        4: 2953:                ["-l"]["--list-tests"]
        2: 2954:                ( "list all/matching test cases" )
        2: 2955:            | Opt( config.listTags )
        4: 2956:                ["-t"]["--list-tags"]
        2: 2957:                ( "list all/matching tags" )
        2: 2958:            | Opt( config.showSuccessfulTests )
        4: 2959:                ["-s"]["--success"]
        2: 2960:                ( "include successful tests in output" )
        2: 2961:            | Opt( config.shouldDebugBreak )
        4: 2962:                ["-b"]["--break"]
        2: 2963:                ( "break into debugger on failure" )
        2: 2964:            | Opt( config.noThrow )
        4: 2965:                ["-e"]["--nothrow"]
        2: 2966:                ( "skip exception tests" )
        2: 2967:            | Opt( config.showInvisibles )
        4: 2968:                ["-i"]["--invisibles"]
        2: 2969:                ( "show invisibles (tabs, newlines)" )
        2: 2970:            | Opt( config.outputFilename, "filename" )
        5: 2971:                ["-o"]["--out"]
        2: 2972:                ( "output filename" )
        2: 2973:            | Opt( setReporter, "name" )
        5: 2974:                ["-r"]["--reporter"]
        2: 2975:                ( "reporter to use (defaults to console)" )
        2: 2976:            | Opt( config.name, "name" )
        5: 2977:                ["-n"]["--name"]
        2: 2978:                ( "suite name" )
        2: 2979:            | Opt( [&]( bool ){ config.abortAfter = 1; } )
        4: 2980:                ["-a"]["--abort"]
        2: 2981:                ( "abort at first failure" )
        2: 2982:            | Opt( [&]( int x ){ config.abortAfter = x; }, "no. failures" )
        5: 2983:                ["-x"]["--abortx"]
        2: 2984:                ( "abort after x failures" )
        2: 2985:            | Opt( setWarning, "warning name" )
        5: 2986:                ["-w"]["--warn"]
        2: 2987:                ( "enable warnings" )
        2: 2988:            | Opt( [&]( bool flag ) { config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; }, "yes|no" )
        5: 2989:                ["-d"]["--durations"]
        2: 2990:                ( "show test durations" )
        2: 2991:            | Opt( config.minDuration, "seconds" )
        5: 2992:                ["-D"]["--min-duration"]
        2: 2993:                ( "show test durations for tests taking at least the given number of seconds" )
        2: 2994:            | Opt( loadTestNamesFromFile, "filename" )
        5: 2995:                ["-f"]["--input-file"]
        2: 2996:                ( "load test names to run from a file" )
        2: 2997:            | Opt( config.filenamesAsTags )
        4: 2998:                ["-#"]["--filenames-as-tags"]
        2: 2999:                ( "adds a tag for the filename" )
        2: 3000:            | Opt( config.sectionsToRun, "section name" )
        5: 3001:                ["-c"]["--section"]
        2: 3002:                ( "specify section to run" )
        2: 3003:            | Opt( setVerbosity, "quiet|normal|high" )
        5: 3004:                ["-v"]["--verbosity"]
        2: 3005:                ( "set output verbosity" )
        2: 3006:            | Opt( config.listReporters )
        3: 3007:                ["--list-reporters"]
        2: 3008:                ( "list all reporters" )
        2: 3009:            | Opt( setTestOrder, "decl|lex|rand" )
        4: 3010:                ["--order"]
        2: 3011:                ( "test case order (defaults to decl)" )
        2: 3012:            | Opt( setRngSeed, "'time'|number" )
        4: 3013:                ["--rng-seed"]
        2: 3014:                ( "set a specific seed for random numbers" )
        2: 3015:            | Opt( setColourUsage, "yes|no" )
        4: 3016:                ["--use-colour"]
        2: 3017:                ( "should output be colourised" )
        2: 3018:            | Opt( config.libIdentify )
        3: 3019:                ["--libidentify"]
        2: 3020:                ( "report name and version according to libidentify standard" )
        2: 3021:            | Opt( setWaitForKeypress, "never|start|exit|both" )
        4: 3022:                ["--wait-for-keypress"]
        2: 3023:                ( "waits for a keypress before exiting" )
        2: 3024:            | Opt( config.benchmarkSamples, "samples" )
        4: 3025:                ["--benchmark-samples"]
        2: 3026:                ( "number of samples to collect (default: 100)" )
        2: 3027:            | Opt( config.benchmarkResamples, "resamples" )
        4: 3028:                ["--benchmark-resamples"]
        2: 3029:                ( "number of resamples for the bootstrap (default: 100000)" )
        2: 3030:            | Opt( config.benchmarkConfidenceInterval, "confidence interval" )
        4: 3031:                ["--benchmark-confidence-interval"]
        2: 3032:                ( "confidence interval for the bootstrap (between 0 and 1, default: 0.95)" )
        2: 3033:            | Opt( config.benchmarkNoAnalysis )
        3: 3034:                ["--benchmark-no-analysis"]
        2: 3035:                ( "perform only measurements; do not perform any analysis" )
        2: 3036:            | Opt( config.benchmarkWarmupTime, "benchmarkWarmupTime" )
        4: 3037:                ["--benchmark-warmup-time"]
        2: 3038:                ( "amount of time in milliseconds spent on warming up each test (default: 100)" )
        -: 3039:            | Arg( config.testsOrTags, "test name|pattern|tags" )
        5: 3040:                ( "which test or tests to use" );
        -: 3041:
        1: 3042:        return cli;
        -: 3043:    }
        -: 3044:
        -: 3045:} // end namespace Catch
        -: 3046:
        -: 3047:
        -: 3048:
        -: 3049:#include <cstring>
        -: 3050:#include <ostream>
        -: 3051:
        -: 3052:namespace Catch {
        -: 3053:
    #####: 3054:    bool SourceLineInfo::operator == ( SourceLineInfo const& other ) const noexcept {
    #####: 3055:        return line == other.line && (file == other.file || std::strcmp(file, other.file) == 0);
        -: 3056:    }
    #####: 3057:    bool SourceLineInfo::operator < ( SourceLineInfo const& other ) const noexcept {
        -: 3058:        // We can assume that the same file will usually have the same pointer.
        -: 3059:        // Thus, if the pointers are the same, there is no point in calling the strcmp
    #####: 3060:        return line < other.line || ( line == other.line && file != other.file && (std::strcmp(file, other.file) < 0));
        -: 3061:    }
        -: 3062:
    #####: 3063:    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info ) {
        -: 3064:#ifndef __GNUG__
        -: 3065:        os << info.file << '(' << info.line << ')';
        -: 3066:#else
    #####: 3067:        os << info.file << ':' << info.line;
        -: 3068:#endif
    #####: 3069:        return os;
        -: 3070:    }
        -: 3071:
        -: 3072:} // end namespace Catch
        -: 3073:
        -: 3074:
        -: 3075:#if defined(__clang__)
        -: 3076:#    pragma clang diagnostic push
        -: 3077:#    pragma clang diagnostic ignored "-Wexit-time-destructors"
        -: 3078:#endif
        -: 3079:
        -: 3080:
        -: 3081:
        -: 3082:#include <ostream>
        -: 3083:
        -: 3084:namespace Catch {
        -: 3085:    namespace {
        -: 3086:
        -: 3087:        struct IColourImpl {
        1: 3088:            virtual ~IColourImpl() = default;
        -: 3089:            virtual void use( Colour::Code _colourCode ) = 0;
        -: 3090:        };
        -: 3091:
    #####: 3092:        struct NoColourImpl : IColourImpl {
    #####: 3093:            void use( Colour::Code ) override {}
        -: 3094:
    #####: 3095:            static IColourImpl* instance() {
    #####: 3096:                static NoColourImpl s_instance;
    #####: 3097:                return &s_instance;
        -: 3098:            }
        -: 3099:        };
        -: 3100:
        -: 3101:    } // anon namespace
        -: 3102:} // namespace Catch
        -: 3103:
        -: 3104:#if !defined( CATCH_CONFIG_COLOUR_NONE ) && !defined( CATCH_CONFIG_COLOUR_WINDOWS ) && !defined( CATCH_CONFIG_COLOUR_ANSI )
        -: 3105:#   ifdef CATCH_PLATFORM_WINDOWS
        -: 3106:#       define CATCH_CONFIG_COLOUR_WINDOWS
        -: 3107:#   else
        -: 3108:#       define CATCH_CONFIG_COLOUR_ANSI
        -: 3109:#   endif
        -: 3110:#endif
        -: 3111:
        -: 3112:
        -: 3113:#if defined ( CATCH_CONFIG_COLOUR_WINDOWS ) /////////////////////////////////////////
        -: 3114:
        -: 3115:namespace Catch {
        -: 3116:namespace {
        -: 3117:
        -: 3118:    class Win32ColourImpl : public IColourImpl {
        -: 3119:    public:
        -: 3120:        Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )
        -: 3121:        {
        -: 3122:            CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
        -: 3123:            GetConsoleScreenBufferInfo( stdoutHandle, &csbiInfo );
        -: 3124:            originalForegroundAttributes = csbiInfo.wAttributes & ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );
        -: 3125:            originalBackgroundAttributes = csbiInfo.wAttributes & ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );
        -: 3126:        }
        -: 3127:
        -: 3128:        void use( Colour::Code _colourCode ) override {
        -: 3129:            switch( _colourCode ) {
        -: 3130:                case Colour::None:      return setTextAttribute( originalForegroundAttributes );
        -: 3131:                case Colour::White:     return setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
        -: 3132:                case Colour::Red:       return setTextAttribute( FOREGROUND_RED );
        -: 3133:                case Colour::Green:     return setTextAttribute( FOREGROUND_GREEN );
        -: 3134:                case Colour::Blue:      return setTextAttribute( FOREGROUND_BLUE );
        -: 3135:                case Colour::Cyan:      return setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );
        -: 3136:                case Colour::Yellow:    return setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );
        -: 3137:                case Colour::Grey:      return setTextAttribute( 0 );
        -: 3138:
        -: 3139:                case Colour::LightGrey:     return setTextAttribute( FOREGROUND_INTENSITY );
        -: 3140:                case Colour::BrightRed:     return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );
        -: 3141:                case Colour::BrightGreen:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );
        -: 3142:                case Colour::BrightWhite:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
        -: 3143:                case Colour::BrightYellow:  return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN );
        -: 3144:
        -: 3145:                case Colour::Bright: CATCH_INTERNAL_ERROR( "not a colour" );
        -: 3146:
        -: 3147:                default:
        -: 3148:                    CATCH_ERROR( "Unknown colour requested" );
        -: 3149:            }
        -: 3150:        }
        -: 3151:
        -: 3152:    private:
        -: 3153:        void setTextAttribute( WORD _textAttribute ) {
        -: 3154:            SetConsoleTextAttribute( stdoutHandle, _textAttribute | originalBackgroundAttributes );
        -: 3155:        }
        -: 3156:        HANDLE stdoutHandle;
        -: 3157:        WORD originalForegroundAttributes;
        -: 3158:        WORD originalBackgroundAttributes;
        -: 3159:    };
        -: 3160:
        -: 3161:    IColourImpl* platformColourInstance() {
        -: 3162:        static Win32ColourImpl s_instance;
        -: 3163:
        -: 3164:        auto const* config = getCurrentContext().getConfig();
        -: 3165:        UseColour colourMode = config?
        -: 3166:            config->useColour() : UseColour::Auto;
        -: 3167:        if( colourMode == UseColour::Auto )
        -: 3168:            colourMode = UseColour::Yes;
        -: 3169:        return colourMode == UseColour::Yes
        -: 3170:            ? &s_instance
        -: 3171:            : NoColourImpl::instance();
        -: 3172:    }
        -: 3173:
        -: 3174:} // end anon namespace
        -: 3175:} // end namespace Catch
        -: 3176:
        -: 3177:#elif defined( CATCH_CONFIG_COLOUR_ANSI ) //////////////////////////////////////
        -: 3178:
        -: 3179:#include <unistd.h>
        -: 3180:
        -: 3181:namespace Catch {
        -: 3182:namespace {
        -: 3183:
        -: 3184:    // use POSIX/ ANSI console terminal codes
        -: 3185:    // Thanks to Adam Strzelecki for original contribution
        -: 3186:    // (http://github.com/nanoant)
        -: 3187:    // https://github.com/philsquared/Catch/pull/131
        2: 3188:    class PosixColourImpl : public IColourImpl {
        -: 3189:    public:
        8: 3190:        void use( Colour::Code _colourCode ) override {
        8: 3191:            switch( _colourCode ) {
        -: 3192:                case Colour::None:
        4: 3193:                case Colour::White:     return setColour( "[0m" );
    #####: 3194:                case Colour::Red:       return setColour( "[0;31m" );
    #####: 3195:                case Colour::Green:     return setColour( "[0;32m" );
    #####: 3196:                case Colour::Blue:      return setColour( "[0;34m" );
    #####: 3197:                case Colour::Cyan:      return setColour( "[0;36m" );
    #####: 3198:                case Colour::Yellow:    return setColour( "[0;33m" );
    #####: 3199:                case Colour::Grey:      return setColour( "[1;30m" );
        -: 3200:
    #####: 3201:                case Colour::LightGrey:     return setColour( "[0;37m" );
        1: 3202:                case Colour::BrightRed:     return setColour( "[1;31m" );
        2: 3203:                case Colour::BrightGreen:   return setColour( "[1;32m" );
    #####: 3204:                case Colour::BrightWhite:   return setColour( "[1;37m" );
        1: 3205:                case Colour::BrightYellow:  return setColour( "[1;33m" );
        -: 3206:
    #####: 3207:                case Colour::Bright: CATCH_INTERNAL_ERROR( "not a colour" );
    #####: 3208:                default: CATCH_INTERNAL_ERROR( "Unknown colour requested" );
        -: 3209:            }
        -: 3210:        }
        1: 3211:        static IColourImpl* instance() {
        1: 3212:            static PosixColourImpl s_instance;
        1: 3213:            return &s_instance;
        -: 3214:        }
        -: 3215:
        -: 3216:    private:
        8: 3217:        void setColour( const char* _escapeCode ) {
        -: 3218:            // The escape sequence must be flushed to console, otherwise if
        -: 3219:            // stdin and stderr are intermixed, we'd get accidentally coloured output.
        8: 3220:            getCurrentContext().getConfig()->stream()
        8: 3221:                << '\033' << _escapeCode << std::flush;
        8: 3222:        }
        -: 3223:    };
        -: 3224:
        -: 3225:    bool useColourOnPlatform() {
        -: 3226:        return
        -: 3227:#if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)
        -: 3228:            !isDebuggerActive() &&
        -: 3229:#endif
        -: 3230:#if !(defined(__DJGPP__) && defined(__STRICT_ANSI__))
        1: 3231:            isatty(STDOUT_FILENO)
        -: 3232:#else
        -: 3233:            false
        -: 3234:#endif
        -: 3235:            ;
        -: 3236:    }
        1: 3237:    IColourImpl* platformColourInstance() {
        -: 3238:        ErrnoGuard guard;
        1: 3239:        auto const* config = getCurrentContext().getConfig();
        -: 3240:        UseColour colourMode = config
        1: 3241:            ? config->useColour()
        2: 3242:            : UseColour::Auto;
        1: 3243:        if( colourMode == UseColour::Auto )
        -: 3244:            colourMode = useColourOnPlatform()
        -: 3245:                ? UseColour::Yes
        1: 3246:                : UseColour::No;
        -: 3247:        return colourMode == UseColour::Yes
        -: 3248:            ? PosixColourImpl::instance()
        2: 3249:            : NoColourImpl::instance();
        -: 3250:    }
        -: 3251:
        -: 3252:} // end anon namespace
        -: 3253:} // end namespace Catch
        -: 3254:
        -: 3255:#else  // not Windows or ANSI ///////////////////////////////////////////////
        -: 3256:
        -: 3257:namespace Catch {
        -: 3258:
        -: 3259:    static IColourImpl* platformColourInstance() { return NoColourImpl::instance(); }
        -: 3260:
        -: 3261:} // end namespace Catch
        -: 3262:
        -: 3263:#endif // Windows/ ANSI/ None
        -: 3264:
        -: 3265:namespace Catch {
        -: 3266:
        4: 3267:    Colour::Colour( Code _colourCode ) { use( _colourCode ); }
    #####: 3268:    Colour::Colour( Colour&& other ) noexcept {
    #####: 3269:        m_moved = other.m_moved;
    #####: 3270:        other.m_moved = true;
    #####: 3271:    }
    #####: 3272:    Colour& Colour::operator=( Colour&& other ) noexcept {
    #####: 3273:        m_moved = other.m_moved;
    #####: 3274:        other.m_moved  = true;
    #####: 3275:        return *this;
        -: 3276:    }
        -: 3277:
        4: 3278:    Colour::~Colour(){ if( !m_moved ) use( None ); }
        -: 3279:
        8: 3280:    void Colour::use( Code _colourCode ) {
        8: 3281:        static IColourImpl* impl = platformColourInstance();
        -: 3282:        // Strictly speaking, this cannot possibly happen.
        -: 3283:        // However, under some conditions it does happen (see #1626),
        -: 3284:        // and this change is small enough that we can let practicality
        -: 3285:        // triumph over purity in this case.
        8: 3286:        if (impl != nullptr) {
        8: 3287:            impl->use( _colourCode );
        -: 3288:        }
        8: 3289:    }
        -: 3290:
    #####: 3291:    std::ostream& operator << ( std::ostream& os, Colour const& ) {
    #####: 3292:        return os;
        -: 3293:    }
        -: 3294:
        -: 3295:} // end namespace Catch
        -: 3296:
        -: 3297:#if defined(__clang__)
        -: 3298:#    pragma clang diagnostic pop
        -: 3299:#endif
        -: 3300:
        -: 3301:
        -: 3302:
        -: 3303:
        -: 3304:namespace Catch {
        -: 3305:
        3: 3306:    class Context : public IMutableContext, private Detail::NonCopyable {
        -: 3307:
        -: 3308:    public: // IContext
        4: 3309:        IResultCapture* getResultCapture() override {
        4: 3310:            return m_resultCapture;
        -: 3311:        }
    #####: 3312:        IRunner* getRunner() override {
    #####: 3313:            return m_runner;
        -: 3314:        }
        -: 3315:
        9: 3316:        IConfig const* getConfig() const override {
        9: 3317:            return m_config;
        -: 3318:        }
        -: 3319:
        -: 3320:        ~Context() override;
        -: 3321:
        -: 3322:    public: // IMutableContext
        1: 3323:        void setResultCapture( IResultCapture* resultCapture ) override {
        1: 3324:            m_resultCapture = resultCapture;
        1: 3325:        }
        1: 3326:        void setRunner( IRunner* runner ) override {
        1: 3327:            m_runner = runner;
        1: 3328:        }
        1: 3329:        void setConfig( IConfig const* config ) override {
        1: 3330:            m_config = config;
        1: 3331:        }
        -: 3332:
        -: 3333:        friend IMutableContext& getCurrentMutableContext();
        -: 3334:
        -: 3335:    private:
        -: 3336:        IConfig const* m_config = nullptr;
        -: 3337:        IRunner* m_runner = nullptr;
        -: 3338:        IResultCapture* m_resultCapture = nullptr;
        -: 3339:    };
        -: 3340:
        -: 3341:    IMutableContext *IMutableContext::currentContext = nullptr;
        -: 3342:
        1: 3343:    void IMutableContext::createContext()
        -: 3344:    {
        2: 3345:        currentContext = new Context();
        1: 3346:    }
        -: 3347:
    #####: 3348:    void cleanUpContext() {
        1: 3349:        delete IMutableContext::currentContext;
        1: 3350:        IMutableContext::currentContext = nullptr;
    #####: 3351:    }
        -: 3352:    IContext::~IContext() = default;
        -: 3353:    IMutableContext::~IMutableContext() = default;
        -: 3354:    Context::~Context() = default;
        -: 3355:
        -: 3356:
    #####: 3357:    SimplePcg32& rng() {
    #####: 3358:        static SimplePcg32 s_rng;
    #####: 3359:        return s_rng;
        -: 3360:    }
        -: 3361:
        -: 3362:}
        -: 3363:
        -: 3364:
        -: 3365:
        -: 3366:#if defined(CATCH_CONFIG_ANDROID_LOGWRITE)
        -: 3367:#include <android/log.h>
        -: 3368:
        -: 3369:    namespace Catch {
        -: 3370:        void writeToDebugConsole( std::string const& text ) {
        -: 3371:            __android_log_write( ANDROID_LOG_DEBUG, "Catch", text.c_str() );
        -: 3372:        }
        -: 3373:    }
        -: 3374:
        -: 3375:#elif defined(CATCH_PLATFORM_WINDOWS)
        -: 3376:
        -: 3377:    namespace Catch {
        -: 3378:        void writeToDebugConsole( std::string const& text ) {
        -: 3379:            ::OutputDebugStringA( text.c_str() );
        -: 3380:        }
        -: 3381:    }
        -: 3382:
        -: 3383:#else
        -: 3384:
        -: 3385:    namespace Catch {
    #####: 3386:        void writeToDebugConsole( std::string const& text ) {
        -: 3387:            // !TBD: Need a version for Mac/ XCode and other IDEs
        -: 3388:            Catch::cout() << text;
    #####: 3389:        }
        -: 3390:    }
        -: 3391:
        -: 3392:#endif // Platform
        -: 3393:
        -: 3394:
        -: 3395:
        -: 3396:#if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)
        -: 3397:
        -: 3398:#  include <cassert>
        -: 3399:#  include <sys/types.h>
        -: 3400:#  include <unistd.h>
        -: 3401:#  include <cstddef>
        -: 3402:#  include <ostream>
        -: 3403:
        -: 3404:#ifdef __apple_build_version__
        -: 3405:    // These headers will only compile with AppleClang (XCode)
        -: 3406:    // For other compilers (Clang, GCC, ... ) we need to exclude them
        -: 3407:#  include <sys/sysctl.h>
        -: 3408:#endif
        -: 3409:
        -: 3410:    namespace Catch {
        -: 3411:        #ifdef __apple_build_version__
        -: 3412:        // The following function is taken directly from the following technical note:
        -: 3413:        // https://developer.apple.com/library/archive/qa/qa1361/_index.html
        -: 3414:
        -: 3415:        // Returns true if the current process is being debugged (either
        -: 3416:        // running under the debugger or has a debugger attached post facto).
        -: 3417:        bool isDebuggerActive(){
        -: 3418:            int                 mib[4];
        -: 3419:            struct kinfo_proc   info;
        -: 3420:            std::size_t         size;
        -: 3421:
        -: 3422:            // Initialize the flags so that, if sysctl fails for some bizarre
        -: 3423:            // reason, we get a predictable result.
        -: 3424:
        -: 3425:            info.kp_proc.p_flag = 0;
        -: 3426:
        -: 3427:            // Initialize mib, which tells sysctl the info we want, in this case
        -: 3428:            // we're looking for information about a specific process ID.
        -: 3429:
        -: 3430:            mib[0] = CTL_KERN;
        -: 3431:            mib[1] = KERN_PROC;
        -: 3432:            mib[2] = KERN_PROC_PID;
        -: 3433:            mib[3] = getpid();
        -: 3434:
        -: 3435:            // Call sysctl.
        -: 3436:
        -: 3437:            size = sizeof(info);
        -: 3438:            if( sysctl(mib, sizeof(mib) / sizeof(*mib), &info, &size, nullptr, 0) != 0 ) {
        -: 3439:                Catch::cerr() << "\n** Call to sysctl failed - unable to determine if debugger is active **\n" << std::endl;
        -: 3440:                return false;
        -: 3441:            }
        -: 3442:
        -: 3443:            // We're being debugged if the P_TRACED flag is set.
        -: 3444:
        -: 3445:            return ( (info.kp_proc.p_flag & P_TRACED) != 0 );
        -: 3446:        }
        -: 3447:        #else
        -: 3448:        bool isDebuggerActive() {
        -: 3449:            // We need to find another way to determine this for non-appleclang compilers on macOS
        -: 3450:            return false;
        -: 3451:        }
        -: 3452:        #endif
        -: 3453:    } // namespace Catch
        -: 3454:
        -: 3455:#elif defined(CATCH_PLATFORM_LINUX)
        -: 3456:    #include <fstream>
        -: 3457:    #include <string>
        -: 3458:
        -: 3459:    namespace Catch{
        -: 3460:        // The standard POSIX way of detecting a debugger is to attempt to
        -: 3461:        // ptrace() the process, but this needs to be done from a child and not
        -: 3462:        // this process itself to still allow attaching to this process later
        -: 3463:        // if wanted, so is rather heavy. Under Linux we have the PID of the
        -: 3464:        // "debugger" (which doesn't need to be gdb, of course, it could also
        -: 3465:        // be strace, for example) in /proc/$PID/status, so just get it from
        -: 3466:        // there instead.
    #####: 3467:        bool isDebuggerActive(){
        -: 3468:            // Libstdc++ has a bug, where std::ifstream sets errno to 0
        -: 3469:            // This way our users can properly assert over errno values
        -: 3470:            ErrnoGuard guard;
    #####: 3471:            std::ifstream in("/proc/self/status");
    #####: 3472:            for( std::string line; std::getline(in, line); ) {
        -: 3473:                static const int PREFIX_LEN = 11;
    #####: 3474:                if( line.compare(0, PREFIX_LEN, "TracerPid:\t") == 0 ) {
        -: 3475:                    // We're traced if the PID is not 0 and no other PID starts
        -: 3476:                    // with 0 digit, so it's enough to check for just a single
        -: 3477:                    // character.
    #####: 3478:                    return line.length() > PREFIX_LEN && line[PREFIX_LEN] != '0';
        -: 3479:                }
        -: 3480:            }
        -: 3481:
    #####: 3482:            return false;
        -: 3483:        }
        -: 3484:    } // namespace Catch
        -: 3485:#elif defined(_MSC_VER)
        -: 3486:    extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
        -: 3487:    namespace Catch {
        -: 3488:        bool isDebuggerActive() {
        -: 3489:            return IsDebuggerPresent() != 0;
        -: 3490:        }
        -: 3491:    }
        -: 3492:#elif defined(__MINGW32__)
        -: 3493:    extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
        -: 3494:    namespace Catch {
        -: 3495:        bool isDebuggerActive() {
        -: 3496:            return IsDebuggerPresent() != 0;
        -: 3497:        }
        -: 3498:    }
        -: 3499:#else
        -: 3500:    namespace Catch {
        -: 3501:       bool isDebuggerActive() { return false; }
        -: 3502:    }
        -: 3503:#endif // Platform
        -: 3504:
        -: 3505:
        -: 3506:
        -: 3507:#include <stdexcept>
        -: 3508:
        -: 3509:
        -: 3510:namespace Catch {
        -: 3511:#if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS) && !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS_CUSTOM_HANDLER)
        -: 3512:    [[noreturn]]
        -: 3513:    void throw_exception(std::exception const& e) {
        -: 3514:        Catch::cerr() << "Catch will terminate because it needed to throw an exception.\n"
        -: 3515:                      << "The message was: " << e.what() << '\n';
        -: 3516:        std::terminate();
        -: 3517:    }
        -: 3518:#endif
        -: 3519:
        -: 3520:    [[noreturn]]
    #####: 3521:    void throw_logic_error(std::string const& msg) {
    #####: 3522:        throw_exception(std::logic_error(msg));
        -: 3523:    }
        -: 3524:
        -: 3525:    [[noreturn]]
    #####: 3526:    void throw_domain_error(std::string const& msg) {
    #####: 3527:        throw_exception(std::domain_error(msg));
        -: 3528:    }
        -: 3529:
        -: 3530:    [[noreturn]]
    #####: 3531:    void throw_runtime_error(std::string const& msg) {
    #####: 3532:        throw_exception(std::runtime_error(msg));
        -: 3533:    }
        -: 3534:
        -: 3535:
        -: 3536:
        -: 3537:} // namespace Catch;
        -: 3538:
        -: 3539:
        -: 3540:
        -: 3541:#include <cassert>
        -: 3542:
        -: 3543:namespace Catch {
        -: 3544:
        1: 3545:    IMutableEnumValuesRegistry::~IMutableEnumValuesRegistry() {}
        -: 3546:
        -: 3547:    namespace Detail {
        -: 3548:
        -: 3549:        namespace {
        -: 3550:            // Extracts the actual name part of an enum instance
        -: 3551:            // In other words, it returns the Blue part of Bikeshed::Colour::Blue
    #####: 3552:            StringRef extractInstanceName(StringRef enumInstance) {
        -: 3553:                // Find last occurence of ":"
        -: 3554:                size_t name_start = enumInstance.size();
    #####: 3555:                while (name_start > 0 && enumInstance[name_start - 1] != ':') {
    #####: 3556:                    --name_start;
        -: 3557:                }
    #####: 3558:                return enumInstance.substr(name_start, enumInstance.size() - name_start);
        -: 3559:            }
        -: 3560:        }
        -: 3561:
    #####: 3562:        std::vector<StringRef> parseEnums( StringRef enums ) {
    #####: 3563:            auto enumValues = splitStringRef( enums, ',' );
        -: 3564:            std::vector<StringRef> parsed;
    #####: 3565:            parsed.reserve( enumValues.size() );
    #####: 3566:            for( auto const& enumValue : enumValues ) {
    #####: 3567:                parsed.push_back(trim(extractInstanceName(enumValue)));
        -: 3568:            }
    #####: 3569:            return parsed;
        -: 3570:        }
        -: 3571:
    #####: 3572:        EnumInfo::~EnumInfo() {}
        -: 3573:
    #####: 3574:        StringRef EnumInfo::lookup( int value ) const {
    #####: 3575:            for( auto const& valueToName : m_values ) {
    #####: 3576:                if( valueToName.first == value )
    #####: 3577:                    return valueToName.second;
        -: 3578:            }
        -: 3579:            return "{** unexpected enum value **}"_sr;
        -: 3580:        }
        -: 3581:
    #####: 3582:        Catch::Detail::unique_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> const& values ) {
    #####: 3583:            auto enumInfo = Catch::Detail::make_unique<EnumInfo>();
    #####: 3584:            enumInfo->m_name = enumName;
    #####: 3585:            enumInfo->m_values.reserve( values.size() );
        -: 3586:
    #####: 3587:            const auto valueNames = Catch::Detail::parseEnums( allValueNames );
    #####: 3588:            assert( valueNames.size() == values.size() );
        -: 3589:            std::size_t i = 0;
    #####: 3590:            for( auto value : values )
    #####: 3591:                enumInfo->m_values.emplace_back(value, valueNames[i++]);
        -: 3592:
    #####: 3593:            return enumInfo;
        -: 3594:        }
        -: 3595:
    #####: 3596:        EnumInfo const& EnumValuesRegistry::registerEnum( StringRef enumName, StringRef allValueNames, std::vector<int> const& values ) {
    #####: 3597:            m_enumInfos.push_back(makeEnumInfo(enumName, allValueNames, values));
    #####: 3598:            return *m_enumInfos.back();
        -: 3599:        }
        -: 3600:
        -: 3601:    } // Detail
        -: 3602:} // Catch
        -: 3603:
        -: 3604:
        -: 3605:
        -: 3606:
        -: 3607:namespace Catch {
        -: 3608:
        2: 3609:    ExceptionTranslatorRegistry::~ExceptionTranslatorRegistry() {
    #####: 3610:    }
        -: 3611:
    #####: 3612:    void ExceptionTranslatorRegistry::registerTranslator( const IExceptionTranslator* translator ) {
    #####: 3613:        m_translators.push_back( Detail::unique_ptr<const IExceptionTranslator>( translator ) );
    #####: 3614:    }
        -: 3615:
        -: 3616:#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
    #####: 3617:    std::string ExceptionTranslatorRegistry::translateActiveException() const {
        -: 3618:        try {
        -: 3619:            // Compiling a mixed mode project with MSVC means that CLR
        -: 3620:            // exceptions will be caught in (...) as well. However, these
        -: 3621:            // do not fill-in std::current_exception and thus lead to crash
        -: 3622:            // when attempting rethrow.
        -: 3623:            // /EHa switch also causes structured exceptions to be caught
        -: 3624:            // here, but they fill-in current_exception properly, so
        -: 3625:            // at worst the output should be a little weird, instead of
        -: 3626:            // causing a crash.
    #####: 3627:            if (std::current_exception() == nullptr) {
    #####: 3628:                return "Non C++ exception. Possibly a CLR exception.";
        -: 3629:            }
    #####: 3630:            return tryTranslators();
        -: 3631:        }
    =====: 3632:        catch( TestFailureException& ) {
    =====: 3633:            std::rethrow_exception(std::current_exception());
        -: 3634:        }
    =====: 3635:        catch( std::exception& ex ) {
    =====: 3636:            return ex.what();
        -: 3637:        }
    =====: 3638:        catch( std::string& msg ) {
        -: 3639:            return msg;
        -: 3640:        }
    =====: 3641:        catch( const char* msg ) {
    =====: 3642:            return msg;
        -: 3643:        }
    =====: 3644:        catch(...) {
    =====: 3645:            return "Unknown exception";
        -: 3646:        }
        -: 3647:    }
        -: 3648:
    #####: 3649:    std::string ExceptionTranslatorRegistry::tryTranslators() const {
    #####: 3650:        if (m_translators.empty()) {
    #####: 3651:            std::rethrow_exception(std::current_exception());
        -: 3652:        } else {
    #####: 3653:            return m_translators[0]->translate(m_translators.begin() + 1, m_translators.end());
        -: 3654:        }
        -: 3655:    }
        -: 3656:
        -: 3657:#else // ^^ Exceptions are enabled // Exceptions are disabled vv
        -: 3658:    std::string ExceptionTranslatorRegistry::translateActiveException() const {
        -: 3659:        CATCH_INTERNAL_ERROR("Attempted to translate active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!");
        -: 3660:    }
        -: 3661:
        -: 3662:    std::string ExceptionTranslatorRegistry::tryTranslators() const {
        -: 3663:        CATCH_INTERNAL_ERROR("Attempted to use exception translators under CATCH_CONFIG_DISABLE_EXCEPTIONS!");
        -: 3664:    }
        -: 3665:#endif
        -: 3666:
        -: 3667:
        -: 3668:}
        -: 3669:
        -: 3670:
        -: 3671:
        -: 3672:
        -: 3673:#if defined(__GNUC__)
        -: 3674:#    pragma GCC diagnostic push
        -: 3675:#    pragma GCC diagnostic ignored "-Wmissing-field-initializers"
        -: 3676:#endif
        -: 3677:
        -: 3678:#if defined( CATCH_CONFIG_WINDOWS_SEH ) || defined( CATCH_CONFIG_POSIX_SIGNALS )
        -: 3679:
        -: 3680:namespace {
        -: 3681:    // Report the error condition
    #####: 3682:    void reportFatal( char const * const message ) {
    #####: 3683:        Catch::getCurrentContext().getResultCapture()->handleFatalErrorCondition( message );
    #####: 3684:    }
        -: 3685:}
        -: 3686:
        -: 3687:#endif // signals/SEH handling
        -: 3688:
        -: 3689:#if defined( CATCH_CONFIG_WINDOWS_SEH )
        -: 3690:
        -: 3691:namespace Catch {
        -: 3692:    struct SignalDefs { DWORD id; const char* name; };
        -: 3693:
        -: 3694:    // There is no 1-1 mapping between signals and windows exceptions.
        -: 3695:    // Windows can easily distinguish between SO and SigSegV,
        -: 3696:    // but SigInt, SigTerm, etc are handled differently.
        -: 3697:    static SignalDefs signalDefs[] = {
        -: 3698:        { static_cast<DWORD>(EXCEPTION_ILLEGAL_INSTRUCTION),  "SIGILL - Illegal instruction signal" },
        -: 3699:        { static_cast<DWORD>(EXCEPTION_STACK_OVERFLOW), "SIGSEGV - Stack overflow" },
        -: 3700:        { static_cast<DWORD>(EXCEPTION_ACCESS_VIOLATION), "SIGSEGV - Segmentation violation signal" },
        -: 3701:        { static_cast<DWORD>(EXCEPTION_INT_DIVIDE_BY_ZERO), "Divide by zero error" },
        -: 3702:    };
        -: 3703:
        -: 3704:    LONG CALLBACK FatalConditionHandler::handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) {
        -: 3705:        for (auto const& def : signalDefs) {
        -: 3706:            if (ExceptionInfo->ExceptionRecord->ExceptionCode == def.id) {
        -: 3707:                reportFatal(def.name);
        -: 3708:            }
        -: 3709:        }
        -: 3710:        // If its not an exception we care about, pass it along.
        -: 3711:        // This stops us from eating debugger breaks etc.
        -: 3712:        return EXCEPTION_CONTINUE_SEARCH;
        -: 3713:    }
        -: 3714:
        -: 3715:    FatalConditionHandler::FatalConditionHandler() {
        -: 3716:        isSet = true;
        -: 3717:        // 32k seems enough for Catch to handle stack overflow,
        -: 3718:        // but the value was found experimentally, so there is no strong guarantee
        -: 3719:        guaranteeSize = 32 * 1024;
        -: 3720:        exceptionHandlerHandle = nullptr;
        -: 3721:        // Register as first handler in current chain
        -: 3722:        exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);
        -: 3723:        // Pass in guarantee size to be filled
        -: 3724:        SetThreadStackGuarantee(&guaranteeSize);
        -: 3725:    }
        -: 3726:
        -: 3727:    void FatalConditionHandler::reset() {
        -: 3728:        if (isSet) {
        -: 3729:            RemoveVectoredExceptionHandler(exceptionHandlerHandle);
        -: 3730:            SetThreadStackGuarantee(&guaranteeSize);
        -: 3731:            exceptionHandlerHandle = nullptr;
        -: 3732:            isSet = false;
        -: 3733:        }
        -: 3734:    }
        -: 3735:
        -: 3736:bool FatalConditionHandler::isSet = false;
        -: 3737:ULONG FatalConditionHandler::guaranteeSize = 0;
        -: 3738:PVOID FatalConditionHandler::exceptionHandlerHandle = nullptr;
        -: 3739:
        -: 3740:
        -: 3741:} // namespace Catch
        -: 3742:
        -: 3743:#elif defined( CATCH_CONFIG_POSIX_SIGNALS )
        -: 3744:
        -: 3745:namespace Catch {
        -: 3746:
        -: 3747:    struct SignalDefs {
        -: 3748:        int id;
        -: 3749:        const char* name;
        -: 3750:    };
        -: 3751:
        -: 3752:    // 32kb for the alternate stack seems to be sufficient. However, this value
        -: 3753:    // is experimentally determined, so that's not guaranteed.
        -: 3754:    static constexpr std::size_t sigStackSize = 32768 >= MINSIGSTKSZ ? 32768 : MINSIGSTKSZ;
        -: 3755:
        -: 3756:    static SignalDefs signalDefs[] = {
        -: 3757:        { SIGINT,  "SIGINT - Terminal interrupt signal" },
        -: 3758:        { SIGILL,  "SIGILL - Illegal instruction signal" },
        -: 3759:        { SIGFPE,  "SIGFPE - Floating point error signal" },
        -: 3760:        { SIGSEGV, "SIGSEGV - Segmentation violation signal" },
        -: 3761:        { SIGTERM, "SIGTERM - Termination request signal" },
        -: 3762:        { SIGABRT, "SIGABRT - Abort (abnormal termination) signal" }
        -: 3763:    };
        -: 3764:
        -: 3765:
    #####: 3766:    void FatalConditionHandler::handleSignal( int sig ) {
        -: 3767:        char const * name = "<unknown signal>";
    #####: 3768:        for (auto const& def : signalDefs) {
    #####: 3769:            if (sig == def.id) {
    #####: 3770:                name = def.name;
    #####: 3771:                break;
        -: 3772:            }
        -: 3773:        }
    #####: 3774:        reset();
    #####: 3775:        reportFatal(name);
    #####: 3776:        raise( sig );
    #####: 3777:    }
        -: 3778:
        1: 3779:    FatalConditionHandler::FatalConditionHandler() {
        1: 3780:        isSet = true;
        -: 3781:        stack_t sigStack;
        1: 3782:        sigStack.ss_sp = altStackMem;
        1: 3783:        sigStack.ss_size = sigStackSize;
        1: 3784:        sigStack.ss_flags = 0;
        1: 3785:        sigaltstack(&sigStack, &oldSigStack);
        1: 3786:        struct sigaction sa = { };
        -: 3787:
        1: 3788:        sa.sa_handler = handleSignal;
        1: 3789:        sa.sa_flags = SA_ONSTACK;
       13: 3790:        for (std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i) {
        6: 3791:            sigaction(signalDefs[i].id, &sa, &oldSigActions[i]);
        -: 3792:        }
        1: 3793:    }
        -: 3794:
        1: 3795:    void FatalConditionHandler::reset() {
        1: 3796:        if( isSet ) {
        -: 3797:            // Set signals back to previous values -- hopefully nobody overwrote them in the meantime
       13: 3798:            for( std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i ) {
        6: 3799:                sigaction(signalDefs[i].id, &oldSigActions[i], nullptr);
        -: 3800:            }
        -: 3801:            // Return the old stack
        1: 3802:            sigaltstack(&oldSigStack, nullptr);
        1: 3803:            isSet = false;
        -: 3804:        }
        1: 3805:    }
        -: 3806:
        -: 3807:    bool FatalConditionHandler::isSet = false;
        -: 3808:    struct sigaction FatalConditionHandler::oldSigActions[sizeof(signalDefs)/sizeof(SignalDefs)] = {};
        -: 3809:    stack_t FatalConditionHandler::oldSigStack = {};
        -: 3810:    char FatalConditionHandler::altStackMem[sigStackSize] = {};
        -: 3811:
        -: 3812:
        -: 3813:} // namespace Catch
        -: 3814:
        -: 3815:#endif // signals/SEH handling
        -: 3816:
        -: 3817:#if defined(__GNUC__)
        -: 3818:#    pragma GCC diagnostic pop
        -: 3819:#endif
        -: 3820:
        -: 3821:
        -: 3822:
        -: 3823:
        -: 3824:
        -: 3825:namespace Catch {
        -: 3826:    namespace {
        -: 3827:
    #####: 3828:        void listTests(IStreamingReporter& reporter, IConfig const& config) {
    #####: 3829:            auto const& testSpec = config.testSpec();
    #####: 3830:            auto matchedTestCases = filterTests(getAllTestCasesSorted(config), testSpec, config);
    #####: 3831:            reporter.listTests(matchedTestCases, config);
    #####: 3832:        }
        -: 3833:
    #####: 3834:        void listTags(IStreamingReporter& reporter, IConfig const& config) {
    #####: 3835:            auto const& testSpec = config.testSpec();
    #####: 3836:            std::vector<TestCaseHandle> matchedTestCases = filterTests(getAllTestCasesSorted(config), testSpec, config);
        -: 3837:
        -: 3838:            std::map<StringRef, TagInfo> tagCounts;
    #####: 3839:            for (auto const& testCase : matchedTestCases) {
    #####: 3840:                for (auto const& tagName : testCase.getTestCaseInfo().tags) {
    #####: 3841:                    auto it = tagCounts.find(tagName.lowerCased);
    #####: 3842:                    if (it == tagCounts.end())
    #####: 3843:                        it = tagCounts.insert(std::make_pair(tagName.lowerCased, TagInfo())).first;
        -: 3844:                    it->second.add(tagName.original);
        -: 3845:                }
        -: 3846:            }
        -: 3847:
    #####: 3848:            std::vector<TagInfo> infos; infos.reserve(tagCounts.size());
    #####: 3849:            for (auto& tagc : tagCounts) {
    #####: 3850:                infos.push_back(std::move(tagc.second));
        -: 3851:            }
        -: 3852:
    #####: 3853:            reporter.listTags(infos, config);
    #####: 3854:        }
        -: 3855:
    #####: 3856:        void listReporters(IStreamingReporter& reporter, IConfig const& config) {
    #####: 3857:            std::vector<ReporterDescription> descriptions;
        -: 3858:
    #####: 3859:            IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();
    #####: 3860:            descriptions.reserve(factories.size());
    #####: 3861:            for (auto const& fac : factories) {
    #####: 3862:                descriptions.push_back({ fac.first, fac.second->getDescription() });
        -: 3863:            }
        -: 3864:
    #####: 3865:            reporter.listReporters(descriptions, config);
    #####: 3866:        }
        -: 3867:
        -: 3868:    } // end anonymous namespace
        -: 3869:
    #####: 3870:    void TagInfo::add( StringRef spelling ) {
    #####: 3871:        ++count;
        -: 3872:        spellings.insert( spelling );
    #####: 3873:    }
        -: 3874:
    #####: 3875:    std::string TagInfo::all() const {
        -: 3876:        // 2 per tag for brackets '[' and ']'
    #####: 3877:        size_t size =  spellings.size() * 2;
    #####: 3878:        for (auto const& spelling : spellings) {
    #####: 3879:            size += spelling.size();
        -: 3880:        }
        -: 3881:
    #####: 3882:        std::string out; out.reserve(size);
    #####: 3883:        for (auto const& spelling : spellings) {
        -: 3884:            out += '[';
        -: 3885:            out += spelling;
        -: 3886:            out += ']';
        -: 3887:        }
    #####: 3888:        return out;
        -: 3889:    }
        -: 3890:
        1: 3891:    bool list( IStreamingReporter& reporter, Config const& config ) {
        -: 3892:        bool listed = false;
        1: 3893:        if (config.listTests()) {
        -: 3894:            listed = true;
    #####: 3895:            listTests(reporter, config);
        -: 3896:        }
        1: 3897:        if (config.listTags()) {
        -: 3898:            listed = true;
    #####: 3899:            listTags(reporter, config);
        -: 3900:        }
        1: 3901:        if (config.listReporters()) {
        -: 3902:            listed = true;
    #####: 3903:            listReporters(reporter, config);
        -: 3904:        }
        1: 3905:        return listed;
        -: 3906:    }
        -: 3907:
        -: 3908:} // end namespace Catch
        -: 3909:
        -: 3910:
        -: 3911:
        -: 3912:namespace Catch {
        -: 3913:    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION
        -: 3914:    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS
        1: 3915:    LeakDetector leakDetector;
        -: 3916:    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -: 3917:}
        -: 3918:
        -: 3919:#if defined(CATCH_CONFIG_WCHAR) && defined(CATCH_PLATFORM_WINDOWS) && defined(_UNICODE) && !defined(DO_NOT_USE_WMAIN)
        -: 3920:// Standard C/C++ Win32 Unicode wmain entry point
        -: 3921:extern "C" int wmain (int argc, wchar_t * argv[], wchar_t * []) {
        -: 3922:#else
        -: 3923:// Standard C/C++ main entry point
        1: 3924:int main (int argc, char * argv[]) {
        -: 3925:#endif
        -: 3926:
        -: 3927:    // We want to force the linker not to discard the global variable
        -: 3928:    // and its constructor, as it (optionally) registers leak detector
        -: 3929:    (void)&Catch::leakDetector;
        -: 3930:
        1: 3931:    return Catch::Session().run( argc, argv );
        -: 3932:}
        -: 3933:
        -: 3934:
        -: 3935:
        -: 3936:#include <cstdio>
        -: 3937:#include <cstring>
        -: 3938:#include <sstream>
        -: 3939:
        -: 3940:#if defined(CATCH_CONFIG_NEW_CAPTURE)
        -: 3941:    #if defined(_MSC_VER)
        -: 3942:    #include <io.h>      //_dup and _dup2
        -: 3943:    #define dup _dup
        -: 3944:    #define dup2 _dup2
        -: 3945:    #define fileno _fileno
        -: 3946:    #else
        -: 3947:    #include <unistd.h>  // dup and dup2
        -: 3948:    #endif
        -: 3949:#endif
        -: 3950:
        -: 3951:
        -: 3952:namespace Catch {
        -: 3953:
    #####: 3954:    RedirectedStream::RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream )
        -: 3955:    :   m_originalStream( originalStream ),
        -: 3956:        m_redirectionStream( redirectionStream ),
    #####: 3957:        m_prevBuf( m_originalStream.rdbuf() )
        -: 3958:    {
    #####: 3959:        m_originalStream.rdbuf( m_redirectionStream.rdbuf() );
    #####: 3960:    }
        -: 3961:
    #####: 3962:    RedirectedStream::~RedirectedStream() {
    #####: 3963:        m_originalStream.rdbuf( m_prevBuf );
    #####: 3964:    }
        -: 3965:
    #####: 3966:    RedirectedStdOut::RedirectedStdOut() : m_cout( Catch::cout(), m_rss.get() ) {}
    #####: 3967:    auto RedirectedStdOut::str() const -> std::string { return m_rss.str(); }
        -: 3968:
    #####: 3969:    RedirectedStdErr::RedirectedStdErr()
        -: 3970:    :   m_cerr( Catch::cerr(), m_rss.get() ),
    #####: 3971:        m_clog( Catch::clog(), m_rss.get() )
    #####: 3972:    {}
    #####: 3973:    auto RedirectedStdErr::str() const -> std::string { return m_rss.str(); }
        -: 3974:
    #####: 3975:    RedirectedStreams::RedirectedStreams(std::string& redirectedCout, std::string& redirectedCerr)
        -: 3976:    :   m_redirectedCout(redirectedCout),
    #####: 3977:        m_redirectedCerr(redirectedCerr)
    #####: 3978:    {}
        -: 3979:
    #####: 3980:    RedirectedStreams::~RedirectedStreams() {
    #####: 3981:        m_redirectedCout += m_redirectedStdOut.str();
    #####: 3982:        m_redirectedCerr += m_redirectedStdErr.str();
    #####: 3983:    }
        -: 3984:
        -: 3985:#if defined(CATCH_CONFIG_NEW_CAPTURE)
        -: 3986:
        -: 3987:#if defined(_MSC_VER)
        -: 3988:    TempFile::TempFile() {
        -: 3989:        if (tmpnam_s(m_buffer)) {
        -: 3990:            CATCH_RUNTIME_ERROR("Could not get a temp filename");
        -: 3991:        }
        -: 3992:        if (fopen_s(&m_file, m_buffer, "w+")) {
        -: 3993:            char buffer[100];
        -: 3994:            if (strerror_s(buffer, errno)) {
        -: 3995:                CATCH_RUNTIME_ERROR("Could not translate errno to a string");
        -: 3996:            }
        -: 3997:            CATCH_RUNTIME_ERROR("Could not open the temp file: '" << m_buffer << "' because: " << buffer);
        -: 3998:        }
        -: 3999:    }
        -: 4000:#else
        -: 4001:    TempFile::TempFile() {
        -: 4002:        m_file = std::tmpfile();
        -: 4003:        if (!m_file) {
        -: 4004:            CATCH_RUNTIME_ERROR("Could not create a temp file.");
        -: 4005:        }
        -: 4006:    }
        -: 4007:
        -: 4008:#endif
        -: 4009:
        -: 4010:    TempFile::~TempFile() {
        -: 4011:         // TBD: What to do about errors here?
        -: 4012:         std::fclose(m_file);
        -: 4013:         // We manually create the file on Windows only, on Linux
        -: 4014:         // it will be autodeleted
        -: 4015:#if defined(_MSC_VER)
        -: 4016:         std::remove(m_buffer);
        -: 4017:#endif
        -: 4018:    }
        -: 4019:
        -: 4020:
        -: 4021:    FILE* TempFile::getFile() {
        -: 4022:        return m_file;
        -: 4023:    }
        -: 4024:
        -: 4025:    std::string TempFile::getContents() {
        -: 4026:        std::stringstream sstr;
        -: 4027:        char buffer[100] = {};
        -: 4028:        std::rewind(m_file);
        -: 4029:        while (std::fgets(buffer, sizeof(buffer), m_file)) {
        -: 4030:            sstr << buffer;
        -: 4031:        }
        -: 4032:        return sstr.str();
        -: 4033:    }
        -: 4034:
        -: 4035:    OutputRedirect::OutputRedirect(std::string& stdout_dest, std::string& stderr_dest) :
        -: 4036:        m_originalStdout(dup(1)),
        -: 4037:        m_originalStderr(dup(2)),
        -: 4038:        m_stdoutDest(stdout_dest),
        -: 4039:        m_stderrDest(stderr_dest) {
        -: 4040:        dup2(fileno(m_stdoutFile.getFile()), 1);
        -: 4041:        dup2(fileno(m_stderrFile.getFile()), 2);
        -: 4042:    }
        -: 4043:
        -: 4044:    OutputRedirect::~OutputRedirect() {
        -: 4045:        Catch::cout() << std::flush;
        -: 4046:        fflush(stdout);
        -: 4047:        // Since we support overriding these streams, we flush cerr
        -: 4048:        // even though std::cerr is unbuffered
        -: 4049:        Catch::cerr() << std::flush;
        -: 4050:        Catch::clog() << std::flush;
        -: 4051:        fflush(stderr);
        -: 4052:
        -: 4053:        dup2(m_originalStdout, 1);
        -: 4054:        dup2(m_originalStderr, 2);
        -: 4055:
        -: 4056:        m_stdoutDest += m_stdoutFile.getContents();
        -: 4057:        m_stderrDest += m_stderrFile.getContents();
        -: 4058:    }
        -: 4059:
        -: 4060:#endif // CATCH_CONFIG_NEW_CAPTURE
        -: 4061:
        -: 4062:} // namespace Catch
        -: 4063:
        -: 4064:#if defined(CATCH_CONFIG_NEW_CAPTURE)
        -: 4065:    #if defined(_MSC_VER)
        -: 4066:    #undef dup
        -: 4067:    #undef dup2
        -: 4068:    #undef fileno
        -: 4069:    #endif
        -: 4070:#endif
        -: 4071:
        -: 4072:
        -: 4073:
        -: 4074:namespace Catch {
        -: 4075:
        -: 4076:namespace {
        -: 4077:
        -: 4078:#if defined(_MSC_VER)
        -: 4079:#pragma warning(push)
        -: 4080:#pragma warning(disable:4146) // we negate uint32 during the rotate
        -: 4081:#endif
        -: 4082:        // Safe rotr implementation thanks to John Regehr
        -: 4083:        uint32_t rotate_right(uint32_t val, uint32_t count) {
        -: 4084:            const uint32_t mask = 31;
    #####: 4085:            count &= mask;
    #####: 4086:            return (val >> count) | (val << (-count & mask));
        -: 4087:        }
        -: 4088:
        -: 4089:#if defined(_MSC_VER)
        -: 4090:#pragma warning(pop)
        -: 4091:#endif
        -: 4092:
        -: 4093:}
        -: 4094:
        -: 4095:
    #####: 4096:    SimplePcg32::SimplePcg32(result_type seed_) {
        -: 4097:        seed(seed_);
    #####: 4098:    }
        -: 4099:
        -: 4100:
    #####: 4101:    void SimplePcg32::seed(result_type seed_) {
    #####: 4102:        m_state = 0;
        -: 4103:        (*this)();
    #####: 4104:        m_state += seed_;
        -: 4105:        (*this)();
    #####: 4106:    }
        -: 4107:
    #####: 4108:    void SimplePcg32::discard(uint64_t skip) {
        -: 4109:        // We could implement this to run in O(log n) steps, but this
        -: 4110:        // should suffice for our use case.
    #####: 4111:        for (uint64_t s = 0; s < skip; ++s) {
        -: 4112:            static_cast<void>((*this)());
        -: 4113:        }
    #####: 4114:    }
        -: 4115:
    #####: 4116:    SimplePcg32::result_type SimplePcg32::operator()() {
        -: 4117:        // prepare the output value
    #####: 4118:        const uint32_t xorshifted = static_cast<uint32_t>(((m_state >> 18u) ^ m_state) >> 27u);
    #####: 4119:        const auto output = rotate_right(xorshifted, m_state >> 59u);
        -: 4120:
        -: 4121:        // advance state
    #####: 4122:        m_state = m_state * 6364136223846793005ULL + s_inc;
        -: 4123:
    #####: 4124:        return output;
        -: 4125:    }
        -: 4126:
    #####: 4127:    bool operator==(SimplePcg32 const& lhs, SimplePcg32 const& rhs) {
    #####: 4128:        return lhs.m_state == rhs.m_state;
        -: 4129:    }
        -: 4130:
    #####: 4131:    bool operator!=(SimplePcg32 const& lhs, SimplePcg32 const& rhs) {
    #####: 4132:        return lhs.m_state != rhs.m_state;
        -: 4133:    }
        -: 4134:}
        -: 4135:
        -: 4136:
        -: 4137:
        -: 4138:
        -: 4139:namespace Catch {
        -: 4140:
        2: 4141:    ReporterRegistry::ReporterRegistry() {
        -: 4142:        // Because it is impossible to move out of initializer list,
        -: 4143:        // we have to add the elements manually
        2: 4144:        m_factories["automake"] = Detail::make_unique<ReporterFactory<AutomakeReporter>>();
        2: 4145:        m_factories["compact"] = Detail::make_unique<ReporterFactory<CompactReporter>>();
        2: 4146:        m_factories["console"] = Detail::make_unique<ReporterFactory<ConsoleReporter>>();
        2: 4147:        m_factories["junit"] = Detail::make_unique<ReporterFactory<JunitReporter>>();
        2: 4148:        m_factories["sonarqube"] = Detail::make_unique<ReporterFactory<SonarQubeReporter>>();
        2: 4149:        m_factories["tap"] = Detail::make_unique<ReporterFactory<TAPReporter>>();
        2: 4150:        m_factories["teamcity"] = Detail::make_unique<ReporterFactory<TeamCityReporter>>();
        2: 4151:        m_factories["xml"] = Detail::make_unique<ReporterFactory<XmlReporter>>();
        1: 4152:    }
        -: 4153:
        -: 4154:    ReporterRegistry::~ReporterRegistry() = default;
        -: 4155:
        -: 4156:
        1: 4157:    IStreamingReporterPtr ReporterRegistry::create( std::string const& name, IConfig const* config ) const {
        -: 4158:        auto it =  m_factories.find( name );
        1: 4159:        if( it == m_factories.end() )
        -: 4160:            return nullptr;
        2: 4161:        return it->second->create( ReporterConfig( config ) );
        -: 4162:    }
        -: 4163:
    #####: 4164:    void ReporterRegistry::registerReporter( std::string const& name, IReporterFactoryPtr factory ) {
    #####: 4165:        m_factories.emplace(name, std::move(factory));
    #####: 4166:    }
    #####: 4167:    void ReporterRegistry::registerListener( IReporterFactoryPtr factory ) {
    #####: 4168:        m_listeners.push_back( std::move(factory) );
    #####: 4169:    }
        -: 4170:
    #####: 4171:    IReporterRegistry::FactoryMap const& ReporterRegistry::getFactories() const {
    #####: 4172:        return m_factories;
        -: 4173:    }
        1: 4174:    IReporterRegistry::Listeners const& ReporterRegistry::getListeners() const {
        1: 4175:        return m_listeners;
        -: 4176:    }
        -: 4177:
        -: 4178:}
        -: 4179:
        -: 4180:
        -: 4181:
        -: 4182:namespace Catch {
        -: 4183:
    #####: 4184:    bool isOk( ResultWas::OfType resultType ) {
    #####: 4185:        return ( resultType & ResultWas::FailureBit ) == 0;
        -: 4186:    }
    #####: 4187:    bool isJustInfo( int flags ) {
    #####: 4188:        return flags == ResultWas::Info;
        -: 4189:    }
        -: 4190:
    #####: 4191:    ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {
    #####: 4192:        return static_cast<ResultDisposition::Flags>( static_cast<int>( lhs ) | static_cast<int>( rhs ) );
        -: 4193:    }
        -: 4194:
    #####: 4195:    bool shouldContinueOnFailure( int flags )    { return ( flags & ResultDisposition::ContinueOnFailure ) != 0; }
    #####: 4196:    bool shouldSuppressFailure( int flags )      { return ( flags & ResultDisposition::SuppressFail ) != 0; }
        -: 4197:
        -: 4198:} // end namespace Catch
        -: 4199:
        -: 4200:
        -: 4201:
        -: 4202:
        -: 4203:#include <cassert>
        -: 4204:#include <algorithm>
        -: 4205:
        -: 4206:namespace Catch {
        -: 4207:
        -: 4208:    namespace Generators {
        -: 4209:        struct GeneratorTracker : TestCaseTracking::TrackerBase, IGeneratorTracker {
        -: 4210:            GeneratorBasePtr m_generator;
        -: 4211:
        -: 4212:            GeneratorTracker( TestCaseTracking::NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )
    #####: 4213:            :   TrackerBase( nameAndLocation, ctx, parent )
        -: 4214:            {}
        -: 4215:            ~GeneratorTracker();
        -: 4216:
    #####: 4217:            static GeneratorTracker& acquire( TrackerContext& ctx, TestCaseTracking::NameAndLocation const& nameAndLocation ) {
    #####: 4218:                std::shared_ptr<GeneratorTracker> tracker;
        -: 4219:
        -: 4220:                ITracker& currentTracker = ctx.currentTracker();
        -: 4221:                // Under specific circumstances, the generator we want
        -: 4222:                // to acquire is also the current tracker. If this is
        -: 4223:                // the case, we have to avoid looking through current
        -: 4224:                // tracker's children, and instead return the current
        -: 4225:                // tracker.
        -: 4226:                // A case where this check is important is e.g.
        -: 4227:                //     for (int i = 0; i < 5; ++i) {
        -: 4228:                //         int n = GENERATE(1, 2);
        -: 4229:                //     }
        -: 4230:                //
        -: 4231:                // without it, the code above creates 5 nested generators.
    #####: 4232:                if (currentTracker.nameAndLocation() == nameAndLocation) {
    #####: 4233:                    auto thisTracker = currentTracker.parent().findChild(nameAndLocation);
    #####: 4234:                    assert(thisTracker);
    #####: 4235:                    assert(thisTracker->isGeneratorTracker());
        -: 4236:                    tracker = std::static_pointer_cast<GeneratorTracker>(thisTracker);
    #####: 4237:                } else if ( TestCaseTracking::ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
    #####: 4238:                    assert( childTracker );
    #####: 4239:                    assert( childTracker->isGeneratorTracker() );
        -: 4240:                    tracker = std::static_pointer_cast<GeneratorTracker>( childTracker );
        -: 4241:                } else {
    #####: 4242:                    tracker = std::make_shared<GeneratorTracker>( nameAndLocation, ctx, &currentTracker );
    #####: 4243:                    currentTracker.addChild( tracker );
        -: 4244:                }
        -: 4245:
    #####: 4246:                if( !tracker->isComplete() ) {
        -: 4247:                    tracker->open();
        -: 4248:                }
        -: 4249:
    #####: 4250:                return *tracker;
        -: 4251:            }
        -: 4252:
        -: 4253:            // TrackerBase interface
    #####: 4254:            bool isGeneratorTracker() const override { return true; }
    #####: 4255:            auto hasGenerator() const -> bool override {
    #####: 4256:                return !!m_generator;
        -: 4257:            }
    #####: 4258:            void close() override {
    #####: 4259:                TrackerBase::close();
        -: 4260:                // If a generator has a child (it is followed by a section)
        -: 4261:                // and none of its children have started, then we must wait
        -: 4262:                // until later to start consuming its values.
        -: 4263:                // This catches cases where `GENERATE` is placed between two
        -: 4264:                // `SECTION`s.
        -: 4265:                // **The check for m_children.empty cannot be removed**.
        -: 4266:                // doing so would break `GENERATE` _not_ followed by `SECTION`s.
        -: 4267:                const bool should_wait_for_child =
    #####: 4268:                    !m_children.empty() &&
    #####: 4269:                    std::find_if( m_children.begin(),
        -: 4270:                                  m_children.end(),
        -: 4271:                                  []( TestCaseTracking::ITrackerPtr tracker ) {
    #####: 4272:                                      return tracker->hasStarted();
    #####: 4273:                                  } ) == m_children.end();
        -: 4274:
        -: 4275:                // This check is a bit tricky, because m_generator->next()
        -: 4276:                // has a side-effect, where it consumes generator's current
        -: 4277:                // value, but we do not want to invoke the side-effect if
        -: 4278:                // this generator is still waiting for any child to start.
    #####: 4279:                if ( should_wait_for_child ||
    #####: 4280:                     ( m_runState == CompletedSuccessfully &&
    #####: 4281:                       m_generator->next() ) ) {
    #####: 4282:                    m_children.clear();
    #####: 4283:                    m_runState = Executing;
        -: 4284:                }
    #####: 4285:            }
        -: 4286:
        -: 4287:            // IGeneratorTracker interface
    #####: 4288:            auto getGenerator() const -> GeneratorBasePtr const& override {
    #####: 4289:                return m_generator;
        -: 4290:            }
    #####: 4291:            void setGenerator( GeneratorBasePtr&& generator ) override {
        -: 4292:                m_generator = std::move( generator );
    #####: 4293:            }
        -: 4294:        };
    #####: 4295:        GeneratorTracker::~GeneratorTracker() {}
        -: 4296:    }
        -: 4297:
        1: 4298:    RunContext::RunContext(IConfig const* _config, IStreamingReporterPtr&& reporter)
        2: 4299:    :   m_runInfo(_config->name()),
        -: 4300:        m_context(getCurrentMutableContext()),
        -: 4301:        m_config(_config),
        -: 4302:        m_reporter(std::move(reporter)),
        -: 4303:        m_lastAssertionInfo{ StringRef(), SourceLineInfo("",0), StringRef(), ResultDisposition::Normal },
        6: 4304:        m_includeSuccessfulResults( m_config->includeSuccessfulResults() || m_reporter->getPreferences().shouldReportAllAssertions )
        -: 4305:    {
        1: 4306:        m_context.setRunner(this);
        1: 4307:        m_context.setResultCapture(this);
        1: 4308:        m_reporter->testRunStarting(m_runInfo);
        1: 4309:    }
        -: 4310:
        3: 4311:    RunContext::~RunContext() {
        3: 4312:        m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, aborting()));
        1: 4313:    }
        -: 4314:
        1: 4315:    void RunContext::testGroupStarting(std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount) {
        3: 4316:        m_reporter->testGroupStarting(GroupInfo(testSpec, groupIndex, groupsCount));
        1: 4317:    }
        -: 4318:
        1: 4319:    void RunContext::testGroupEnded(std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount) {
        4: 4320:        m_reporter->testGroupEnded(TestGroupStats(GroupInfo(testSpec, groupIndex, groupsCount), totals, aborting()));
        1: 4321:    }
        -: 4322:
        1: 4323:    Totals RunContext::runTest(TestCaseHandle const& testCase) {
        1: 4324:        Totals prevTotals = m_totals;
        -: 4325:
        -: 4326:        std::string redirectedCout;
        -: 4327:        std::string redirectedCerr;
        -: 4328:
        -: 4329:        auto const& testInfo = testCase.getTestCaseInfo();
        -: 4330:
        1: 4331:        m_reporter->testCaseStarting(testInfo);
        -: 4332:
        1: 4333:        m_activeTestCase = &testCase;
        -: 4334:
        -: 4335:
        1: 4336:        ITracker& rootTracker = m_trackerContext.startRun();
        1: 4337:        assert(rootTracker.isSectionTracker());
        1: 4338:        static_cast<SectionTracker&>(rootTracker).addInitialFilters(m_config->getSectionsToRun());
        1: 4339:        do {
        -: 4340:            m_trackerContext.startCycle();
        2: 4341:            m_testCaseTracker = &SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(testInfo.name, testInfo.lineInfo));
        1: 4342:            runCurrentTest(redirectedCout, redirectedCerr);
        1: 4343:        } while (!m_testCaseTracker->isSuccessfullyCompleted() && !aborting());
        -: 4344:
        1: 4345:        Totals deltaTotals = m_totals.delta(prevTotals);
        1: 4346:        if (testInfo.expectedToFail() && deltaTotals.testCases.passed > 0) {
    #####: 4347:            deltaTotals.assertions.failed++;
    #####: 4348:            deltaTotals.testCases.passed--;
    #####: 4349:            deltaTotals.testCases.failed++;
        -: 4350:        }
        -: 4351:        m_totals.testCases += deltaTotals.testCases;
        2: 4352:        m_reporter->testCaseEnded(TestCaseStats(testInfo,
        -: 4353:                                  deltaTotals,
        -: 4354:                                  redirectedCout,
        -: 4355:                                  redirectedCerr,
        2: 4356:                                  aborting()));
        -: 4357:
        1: 4358:        m_activeTestCase = nullptr;
        1: 4359:        m_testCaseTracker = nullptr;
        -: 4360:
        1: 4361:        return deltaTotals;
        -: 4362:    }
        -: 4363:
        -: 4364:
    #####: 4365:    void RunContext::assertionEnded(AssertionResult const & result) {
    #####: 4366:        if (result.getResultType() == ResultWas::Ok) {
    #####: 4367:            m_totals.assertions.passed++;
    #####: 4368:            m_lastAssertionPassed = true;
    #####: 4369:        } else if (!result.isOk()) {
    #####: 4370:            m_lastAssertionPassed = false;
    #####: 4371:            if( m_activeTestCase->getTestCaseInfo().okToFail() )
    #####: 4372:                m_totals.assertions.failedButOk++;
        -: 4373:            else
    #####: 4374:                m_totals.assertions.failed++;
        -: 4375:        }
        -: 4376:        else {
    #####: 4377:            m_lastAssertionPassed = true;
        -: 4378:        }
        -: 4379:
        -: 4380:        // We have no use for the return value (whether messages should be cleared), because messages were made scoped
        -: 4381:        // and should be let to clear themselves out.
    #####: 4382:        static_cast<void>(m_reporter->assertionEnded(AssertionStats(result, m_messages, m_totals)));
        -: 4383:
    #####: 4384:        if (result.getResultType() != ResultWas::Warning)
        -: 4385:            m_messageScopes.clear();
        -: 4386:
        -: 4387:        // Reset working state
        -: 4388:        resetAssertionInfo();
    #####: 4389:        m_lastResult = result;
    #####: 4390:    }
    #####: 4391:    void RunContext::resetAssertionInfo() {
        4: 4392:        m_lastAssertionInfo.macroName = StringRef();
        4: 4393:        m_lastAssertionInfo.capturedExpression = "{Unknown expression after the reported line}"_sr;
    #####: 4394:    }
        -: 4395:
    #####: 4396:    bool RunContext::sectionStarted(SectionInfo const & sectionInfo, Counts & assertions) {
    #####: 4397:        ITracker& sectionTracker = SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(sectionInfo.name, sectionInfo.lineInfo));
    #####: 4398:        if (!sectionTracker.isOpen())
        -: 4399:            return false;
    #####: 4400:        m_activeSections.push_back(&sectionTracker);
        -: 4401:
    #####: 4402:        m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;
        -: 4403:
    #####: 4404:        m_reporter->sectionStarting(sectionInfo);
        -: 4405:
    #####: 4406:        assertions = m_totals.assertions;
        -: 4407:
    #####: 4408:        return true;
        -: 4409:    }
    #####: 4410:    auto RunContext::acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const& lineInfo ) -> IGeneratorTracker& {
        -: 4411:        using namespace Generators;
        -: 4412:        GeneratorTracker& tracker = GeneratorTracker::acquire(m_trackerContext,
    #####: 4413:                                                              TestCaseTracking::NameAndLocation( static_cast<std::string>(generatorName), lineInfo ) );
    #####: 4414:        m_lastAssertionInfo.lineInfo = lineInfo;
    #####: 4415:        return tracker;
        -: 4416:    }
        -: 4417:
        1: 4418:    bool RunContext::testForMissingAssertions(Counts& assertions) {
        1: 4419:        if (assertions.total() != 0)
        -: 4420:            return false;
    #####: 4421:        if (!m_config->warnAboutMissingAssertions())
        -: 4422:            return false;
    #####: 4423:        if (m_trackerContext.currentTracker().hasChildren())
        -: 4424:            return false;
    #####: 4425:        m_totals.assertions.failed++;
    #####: 4426:        assertions.failed++;
    #####: 4427:        return true;
        -: 4428:    }
        -: 4429:
    #####: 4430:    void RunContext::sectionEnded(SectionEndInfo const & endInfo) {
        -: 4431:        Counts assertions = m_totals.assertions - endInfo.prevAssertions;
    #####: 4432:        bool missingAssertions = testForMissingAssertions(assertions);
        -: 4433:
    #####: 4434:        if (!m_activeSections.empty()) {
    #####: 4435:            m_activeSections.back()->close();
        -: 4436:            m_activeSections.pop_back();
        -: 4437:        }
        -: 4438:
    #####: 4439:        m_reporter->sectionEnded(SectionStats(endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions));
    #####: 4440:        m_messages.clear();
        -: 4441:        m_messageScopes.clear();
    #####: 4442:    }
        -: 4443:
    #####: 4444:    void RunContext::sectionEndedEarly(SectionEndInfo const & endInfo) {
    #####: 4445:        if (m_unfinishedSections.empty())
    #####: 4446:            m_activeSections.back()->fail();
        -: 4447:        else
    #####: 4448:            m_activeSections.back()->close();
        -: 4449:        m_activeSections.pop_back();
        -: 4450:
    #####: 4451:        m_unfinishedSections.push_back(endInfo);
    #####: 4452:    }
        -: 4453:
    #####: 4454:    void RunContext::benchmarkPreparing(std::string const& name) {
    #####: 4455:        m_reporter->benchmarkPreparing(name);
    #####: 4456:    }
    #####: 4457:    void RunContext::benchmarkStarting( BenchmarkInfo const& info ) {
    #####: 4458:        m_reporter->benchmarkStarting( info );
    #####: 4459:    }
    #####: 4460:    void RunContext::benchmarkEnded( BenchmarkStats<> const& stats ) {
    #####: 4461:        m_reporter->benchmarkEnded( stats );
    #####: 4462:    }
    #####: 4463:    void RunContext::benchmarkFailed(std::string const & error) {
    #####: 4464:        m_reporter->benchmarkFailed(error);
    #####: 4465:    }
        -: 4466:
    #####: 4467:    void RunContext::pushScopedMessage(MessageInfo const & message) {
    #####: 4468:        m_messages.push_back(message);
    #####: 4469:    }
        -: 4470:
    #####: 4471:    void RunContext::popScopedMessage(MessageInfo const & message) {
    #####: 4472:        m_messages.erase(std::remove(m_messages.begin(), m_messages.end(), message), m_messages.end());
    #####: 4473:    }
        -: 4474:
    #####: 4475:    void RunContext::emplaceUnscopedMessage( MessageBuilder const& builder ) {
    #####: 4476:        m_messageScopes.emplace_back( builder );
    #####: 4477:    }
        -: 4478:
    #####: 4479:    std::string RunContext::getCurrentTestName() const {
    #####: 4480:        return m_activeTestCase
        -: 4481:            ? m_activeTestCase->getTestCaseInfo().name
    #####: 4482:            : std::string();
        -: 4483:    }
        -: 4484:
    #####: 4485:    const AssertionResult * RunContext::getLastResult() const {
    #####: 4486:        return &(*m_lastResult);
        -: 4487:    }
        -: 4488:
    #####: 4489:    void RunContext::exceptionEarlyReported() {
    #####: 4490:        m_shouldReportUnexpected = false;
    #####: 4491:    }
        -: 4492:
    #####: 4493:    void RunContext::handleFatalErrorCondition( StringRef message ) {
        -: 4494:        // First notify reporter that bad things happened
    #####: 4495:        m_reporter->fatalErrorEncountered(message);
        -: 4496:
        -: 4497:        // Don't rebuild the result -- the stringification itself can cause more fatal errors
        -: 4498:        // Instead, fake a result data.
    #####: 4499:        AssertionResultData tempResult( ResultWas::FatalErrorCondition, { false } );
    #####: 4500:        tempResult.message = static_cast<std::string>(message);
        -: 4501:        AssertionResult result(m_lastAssertionInfo, tempResult);
        -: 4502:
    #####: 4503:        assertionEnded(result);
        -: 4504:
    #####: 4505:        handleUnfinishedSections();
        -: 4506:
        -: 4507:        // Recreate section for test case (as we will lose the one that was in scope)
    #####: 4508:        auto const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
    #####: 4509:        SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);
        -: 4510:
        -: 4511:        Counts assertions;
        -: 4512:        assertions.failed = 1;
        -: 4513:        SectionStats testCaseSectionStats(testCaseSection, assertions, 0, false);
    #####: 4514:        m_reporter->sectionEnded(testCaseSectionStats);
        -: 4515:
    #####: 4516:        auto const& testInfo = m_activeTestCase->getTestCaseInfo();
        -: 4517:
    #####: 4518:        Totals deltaTotals;
    #####: 4519:        deltaTotals.testCases.failed = 1;
    #####: 4520:        deltaTotals.assertions.failed = 1;
    #####: 4521:        m_reporter->testCaseEnded(TestCaseStats(testInfo,
        -: 4522:                                  deltaTotals,
        -: 4523:                                  std::string(),
        -: 4524:                                  std::string(),
    #####: 4525:                                  false));
    #####: 4526:        m_totals.testCases.failed++;
    #####: 4527:        testGroupEnded(std::string(), m_totals, 1, 1);
    #####: 4528:        m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, false));
    #####: 4529:    }
        -: 4530:
    #####: 4531:    bool RunContext::lastAssertionPassed() {
    #####: 4532:         return m_lastAssertionPassed;
        -: 4533:    }
        -: 4534:
        4: 4535:    void RunContext::assertionPassed() {
        4: 4536:        m_lastAssertionPassed = true;
        4: 4537:        ++m_totals.assertions.passed;
        -: 4538:        resetAssertionInfo();
        -: 4539:        m_messageScopes.clear();
        4: 4540:    }
        -: 4541:
        2: 4542:    bool RunContext::aborting() const {
        4: 4543:        return m_totals.assertions.failed >= static_cast<std::size_t>(m_config->abortAfter());
        -: 4544:    }
        -: 4545:
        1: 4546:    void RunContext::runCurrentTest(std::string & redirectedCout, std::string & redirectedCerr) {
        1: 4547:        auto const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
        1: 4548:        SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);
        1: 4549:        m_reporter->sectionStarting(testCaseSection);
        1: 4550:        Counts prevAssertions = m_totals.assertions;
        -: 4551:        double duration = 0;
        1: 4552:        m_shouldReportUnexpected = true;
        1: 4553:        m_lastAssertionInfo = { "TEST_CASE"_sr, testCaseInfo.lineInfo, StringRef(), ResultDisposition::Normal };
        -: 4554:
        1: 4555:        seedRng(*m_config);
        -: 4556:
        -: 4557:        Timer timer;
        -: 4558:        CATCH_TRY {
        1: 4559:            if (m_reporter->getPreferences().shouldRedirectStdOut) {
        -: 4560:#if !defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)
    #####: 4561:                RedirectedStreams redirectedStreams(redirectedCout, redirectedCerr);
        -: 4562:
        -: 4563:                timer.start();
    #####: 4564:                invokeActiveTestCase();
        -: 4565:#else
        -: 4566:                OutputRedirect r(redirectedCout, redirectedCerr);
        -: 4567:                timer.start();
        -: 4568:                invokeActiveTestCase();
        -: 4569:#endif
        -: 4570:            } else {
        -: 4571:                timer.start();
        1: 4572:                invokeActiveTestCase();
        -: 4573:            }
        -: 4574:            duration = timer.getElapsedSeconds();
    =====: 4575:        } CATCH_CATCH_ANON (TestFailureException&) {
        -: 4576:            // This just means the test was aborted due to failure
    =====: 4577:        } CATCH_CATCH_ALL {
        -: 4578:            // Under CATCH_CONFIG_FAST_COMPILE, unexpected exceptions under REQUIRE assertions
        -: 4579:            // are reported without translation at the point of origin.
    =====: 4580:            if( m_shouldReportUnexpected ) {
    =====: 4581:                AssertionReaction dummyReaction;
    =====: 4582:                handleUnexpectedInflightException( m_lastAssertionInfo, translateActiveException(), dummyReaction );
        -: 4583:            }
        -: 4584:        }
        -: 4585:        Counts assertions = m_totals.assertions - prevAssertions;
        1: 4586:        bool missingAssertions = testForMissingAssertions(assertions);
        -: 4587:
        1: 4588:        m_testCaseTracker->close();
        1: 4589:        handleUnfinishedSections();
        1: 4590:        m_messages.clear();
        -: 4591:        m_messageScopes.clear();
        -: 4592:
        -: 4593:        SectionStats testCaseSectionStats(testCaseSection, assertions, duration, missingAssertions);
        1: 4594:        m_reporter->sectionEnded(testCaseSectionStats);
        1: 4595:    }
        -: 4596:
        1: 4597:    void RunContext::invokeActiveTestCase() {
        -: 4598:        // We need to register a handler for signals/structured exceptions
        -: 4599:        // before running the tests themselves, or the binary can crash
        -: 4600:        // without failed test being reported.
        1: 4601:        FatalConditionHandler _;
        1: 4602:        m_activeTestCase->invoke();
        1: 4603:    }
        -: 4604:
        1: 4605:    void RunContext::handleUnfinishedSections() {
        -: 4606:        // If sections ended prematurely due to an exception we stored their
        -: 4607:        // infos here so we can tear them down outside the unwind process.
        1: 4608:        for (auto it = m_unfinishedSections.rbegin(),
        -: 4609:             itEnd = m_unfinishedSections.rend();
        -: 4610:             it != itEnd;
        -: 4611:             ++it)
    #####: 4612:            sectionEnded(*it);
        1: 4613:        m_unfinishedSections.clear();
        1: 4614:    }
        -: 4615:
        4: 4616:    void RunContext::handleExpr(
        -: 4617:        AssertionInfo const& info,
        -: 4618:        ITransientExpression const& expr,
        -: 4619:        AssertionReaction& reaction
        -: 4620:    ) {
        4: 4621:        m_reporter->assertionStarting( info );
        -: 4622:
        4: 4623:        bool negated = isFalseTest( info.resultDisposition );
        -: 4624:        bool result = expr.getResult() != negated;
        -: 4625:
        4: 4626:        if( result ) {
        4: 4627:            if (!m_includeSuccessfulResults) {
        4: 4628:                assertionPassed();
        -: 4629:            }
        -: 4630:            else {
    #####: 4631:                reportExpr(info, ResultWas::Ok, &expr, negated);
        -: 4632:            }
        -: 4633:        }
        -: 4634:        else {
    #####: 4635:            reportExpr(info, ResultWas::ExpressionFailed, &expr, negated );
    #####: 4636:            populateReaction( reaction );
        -: 4637:        }
        4: 4638:    }
    #####: 4639:    void RunContext::reportExpr(
        -: 4640:            AssertionInfo const &info,
        -: 4641:            ResultWas::OfType resultType,
        -: 4642:            ITransientExpression const *expr,
        -: 4643:            bool negated ) {
        -: 4644:
    #####: 4645:        m_lastAssertionInfo = info;
    #####: 4646:        AssertionResultData data( resultType, LazyExpression( negated ) );
        -: 4647:
        -: 4648:        AssertionResult assertionResult{ info, data };
    #####: 4649:        assertionResult.m_resultData.lazyExpression.m_transientExpression = expr;
        -: 4650:
    #####: 4651:        assertionEnded( assertionResult );
    #####: 4652:    }
        -: 4653:
    #####: 4654:    void RunContext::handleMessage(
        -: 4655:            AssertionInfo const& info,
        -: 4656:            ResultWas::OfType resultType,
        -: 4657:            StringRef const& message,
        -: 4658:            AssertionReaction& reaction
        -: 4659:    ) {
    #####: 4660:        m_reporter->assertionStarting( info );
        -: 4661:
    #####: 4662:        m_lastAssertionInfo = info;
        -: 4663:
    #####: 4664:        AssertionResultData data( resultType, LazyExpression( false ) );
    #####: 4665:        data.message = static_cast<std::string>(message);
        -: 4666:        AssertionResult assertionResult{ m_lastAssertionInfo, data };
    #####: 4667:        assertionEnded( assertionResult );
    #####: 4668:        if( !assertionResult.isOk() )
    #####: 4669:            populateReaction( reaction );
    #####: 4670:    }
    #####: 4671:    void RunContext::handleUnexpectedExceptionNotThrown(
        -: 4672:            AssertionInfo const& info,
        -: 4673:            AssertionReaction& reaction
        -: 4674:    ) {
    #####: 4675:        handleNonExpr(info, Catch::ResultWas::DidntThrowException, reaction);
    #####: 4676:    }
        -: 4677:
    #####: 4678:    void RunContext::handleUnexpectedInflightException(
        -: 4679:            AssertionInfo const& info,
        -: 4680:            std::string const& message,
        -: 4681:            AssertionReaction& reaction
        -: 4682:    ) {
    #####: 4683:        m_lastAssertionInfo = info;
        -: 4684:
    #####: 4685:        AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );
        -: 4686:        data.message = message;
        -: 4687:        AssertionResult assertionResult{ info, data };
    #####: 4688:        assertionEnded( assertionResult );
    #####: 4689:        populateReaction( reaction );
    #####: 4690:    }
        -: 4691:
    #####: 4692:    void RunContext::populateReaction( AssertionReaction& reaction ) {
    #####: 4693:        reaction.shouldDebugBreak = m_config->shouldDebugBreak();
    #####: 4694:        reaction.shouldThrow = aborting() || (m_lastAssertionInfo.resultDisposition & ResultDisposition::Normal);
    #####: 4695:    }
        -: 4696:
    #####: 4697:    void RunContext::handleIncomplete(
        -: 4698:            AssertionInfo const& info
        -: 4699:    ) {
    #####: 4700:        m_lastAssertionInfo = info;
        -: 4701:
    #####: 4702:        AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );
        -: 4703:        data.message = "Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE";
        -: 4704:        AssertionResult assertionResult{ info, data };
    #####: 4705:        assertionEnded( assertionResult );
    #####: 4706:    }
    #####: 4707:    void RunContext::handleNonExpr(
        -: 4708:            AssertionInfo const &info,
        -: 4709:            ResultWas::OfType resultType,
        -: 4710:            AssertionReaction &reaction
        -: 4711:    ) {
    #####: 4712:        m_lastAssertionInfo = info;
        -: 4713:
    #####: 4714:        AssertionResultData data( resultType, LazyExpression( false ) );
        -: 4715:        AssertionResult assertionResult{ info, data };
    #####: 4716:        assertionEnded( assertionResult );
        -: 4717:
    #####: 4718:        if( !assertionResult.isOk() )
    #####: 4719:            populateReaction( reaction );
    #####: 4720:    }
        -: 4721:
        -: 4722:
        4: 4723:    IResultCapture& getResultCapture() {
        4: 4724:        if (auto* capture = getCurrentContext().getResultCapture())
        4: 4725:            return *capture;
        -: 4726:        else
    #####: 4727:            CATCH_INTERNAL_ERROR("No result capture instance");
        -: 4728:    }
        -: 4729:
        2: 4730:    void seedRng(IConfig const& config) {
        2: 4731:        if (config.rngSeed() != 0) {
    #####: 4732:            std::srand(config.rngSeed());
    #####: 4733:            rng().seed(config.rngSeed());
        -: 4734:        }
        2: 4735:    }
        -: 4736:
    #####: 4737:    unsigned int rngSeed() {
    #####: 4738:        return getCurrentContext().getConfig()->rngSeed();
        -: 4739:    }
        -: 4740:
        -: 4741:}
        -: 4742:
        -: 4743:
        -: 4744:
        -: 4745:#include <utility>
        -: 4746:
        -: 4747:namespace Catch {
        -: 4748:
    #####: 4749:    Section::Section( SectionInfo&& info ):
        -: 4750:        m_info( std::move( info ) ),
        -: 4751:        m_sectionIncluded(
    #####: 4752:            getResultCapture().sectionStarted( m_info, m_assertions ) ) {
        -: 4753:        // Non-"included" sections will not use the timing information
        -: 4754:        // anyway, so don't bother with the potential syscall.
    #####: 4755:        if (m_sectionIncluded) {
        -: 4756:            m_timer.start();
        -: 4757:        }
    #####: 4758:    }
        -: 4759:
    #####: 4760:    Section::~Section() {
    #####: 4761:        if( m_sectionIncluded ) {
    #####: 4762:            SectionEndInfo endInfo{ m_info, m_assertions, m_timer.getElapsedSeconds() };
    #####: 4763:            if( uncaught_exceptions() )
    #####: 4764:                getResultCapture().sectionEndedEarly( endInfo );
        -: 4765:            else
    #####: 4766:                getResultCapture().sectionEnded( endInfo );
        -: 4767:        }
    #####: 4768:    }
        -: 4769:
        -: 4770:    // This indicates whether the section should be executed or not
    #####: 4771:    Section::operator bool() const {
    #####: 4772:        return m_sectionIncluded;
        -: 4773:    }
        -: 4774:
        -: 4775:
        -: 4776:} // end namespace Catch
        -: 4777:
        -: 4778:
        -: 4779:
        -: 4780:#include <vector>
        -: 4781:
        -: 4782:namespace Catch {
        -: 4783:
        -: 4784:    namespace {
        3: 4785:        static auto getSingletons() -> std::vector<ISingleton*>*& {
        -: 4786:            static std::vector<ISingleton*>* g_singletons = nullptr;
        3: 4787:            if( !g_singletons )
        2: 4788:                g_singletons = new std::vector<ISingleton*>();
        3: 4789:            return g_singletons;
        -: 4790:        }
        -: 4791:    }
        -: 4792:
        2: 4793:    ISingleton::~ISingleton() {}
        -: 4794:
    #####: 4795:    void addSingleton(ISingleton* singleton ) {
        2: 4796:        getSingletons()->push_back( singleton );
    #####: 4797:    }
        1: 4798:    void cleanupSingletons() {
        1: 4799:        auto& singletons = getSingletons();
        4: 4800:        for( auto singleton : *singletons )
        2: 4801:            delete singleton;
        2: 4802:        delete singletons;
        1: 4803:        singletons = nullptr;
        1: 4804:    }
        -: 4805:
        -: 4806:} // namespace Catch
        -: 4807:
        -: 4808:
        -: 4809:
        -: 4810:#include <cstdio>
        -: 4811:#include <iostream>
        -: 4812:#include <fstream>
        -: 4813:#include <sstream>
        -: 4814:#include <vector>
        -: 4815:
        -: 4816:namespace Catch {
        -: 4817:
        -: 4818:    Catch::IStream::~IStream() = default;
        -: 4819:
        -: 4820:namespace Detail {
        -: 4821:    namespace {
        -: 4822:        template<typename WriterF, std::size_t bufferSize=256>
        -: 4823:        class StreamBufImpl : public std::streambuf {
        -: 4824:            char data[bufferSize];
        -: 4825:            WriterF m_writer;
        -: 4826:
        -: 4827:        public:
    #####: 4828:            StreamBufImpl() {
    #####: 4829:                setp( data, data + sizeof(data) );
        -: 4830:            }
        -: 4831:
    #####: 4832:            ~StreamBufImpl() noexcept {
    #####: 4833:                StreamBufImpl::sync();
    #####: 4834:            }
        -: 4835:
        -: 4836:        private:
    #####: 4837:            int overflow( int c ) override {
    #####: 4838:                sync();
        -: 4839:
    #####: 4840:                if( c != EOF ) {
    #####: 4841:                    if( pbase() == epptr() )
    #####: 4842:                        m_writer( std::string( 1, static_cast<char>( c ) ) );
        -: 4843:                    else
    #####: 4844:                        sputc( static_cast<char>( c ) );
        -: 4845:                }
    #####: 4846:                return 0;
        -: 4847:            }
        -: 4848:
    #####: 4849:            int sync() override {
    #####: 4850:                if( pbase() != pptr() ) {
    #####: 4851:                    m_writer( std::string( pbase(), static_cast<std::string::size_type>( pptr() - pbase() ) ) );
        -: 4852:                    setp( pbase(), epptr() );
        -: 4853:                }
    #####: 4854:                return 0;
        -: 4855:            }
        -: 4856:        };
        -: 4857:
        -: 4858:        ///////////////////////////////////////////////////////////////////////////
        -: 4859:
        -: 4860:        struct OutputDebugWriter {
        -: 4861:
        -: 4862:            void operator()( std::string const&str ) {
        -: 4863:                writeToDebugConsole( str );
        -: 4864:            }
        -: 4865:        };
        -: 4866:
        -: 4867:        ///////////////////////////////////////////////////////////////////////////
        -: 4868:
        -: 4869:        class FileStream : public IStream {
        -: 4870:            mutable std::ofstream m_ofs;
        -: 4871:        public:
    #####: 4872:            FileStream( StringRef filename ) {
    #####: 4873:                m_ofs.open( filename.c_str() );
    #####: 4874:                CATCH_ENFORCE( !m_ofs.fail(), "Unable to open file: '" << filename << "'" );
    #####: 4875:            }
    #####: 4876:            ~FileStream() override = default;
        -: 4877:        public: // IStream
    #####: 4878:            std::ostream& stream() const override {
    #####: 4879:                return m_ofs;
        -: 4880:            }
        -: 4881:        };
        -: 4882:
        -: 4883:        ///////////////////////////////////////////////////////////////////////////
        -: 4884:
        -: 4885:        class CoutStream : public IStream {
        -: 4886:            mutable std::ostream m_os;
        -: 4887:        public:
        -: 4888:            // Store the streambuf from cout up-front because
        -: 4889:            // cout may get redirected when running tests
        2: 4890:            CoutStream() : m_os( Catch::cout().rdbuf() ) {}
        2: 4891:            ~CoutStream() override = default;
        -: 4892:
        -: 4893:        public: // IStream
        9: 4894:            std::ostream& stream() const override { return m_os; }
        -: 4895:        };
        -: 4896:
        -: 4897:        ///////////////////////////////////////////////////////////////////////////
        -: 4898:
        -: 4899:        class DebugOutStream : public IStream {
        -: 4900:            Detail::unique_ptr<StreamBufImpl<OutputDebugWriter>> m_streamBuf;
        -: 4901:            mutable std::ostream m_os;
        -: 4902:        public:
    #####: 4903:            DebugOutStream()
        -: 4904:            :   m_streamBuf( Detail::make_unique<StreamBufImpl<OutputDebugWriter>>() ),
    #####: 4905:                m_os( m_streamBuf.get() )
    #####: 4906:            {}
        -: 4907:
    #####: 4908:            ~DebugOutStream() override = default;
        -: 4909:
        -: 4910:        public: // IStream
    #####: 4911:            std::ostream& stream() const override { return m_os; }
        -: 4912:        };
        -: 4913:
        -: 4914:    } // unnamed namespace
        -: 4915:} // namespace Detail
        -: 4916:
        -: 4917:    ///////////////////////////////////////////////////////////////////////////
        -: 4918:
        1: 4919:    auto makeStream( StringRef const &filename ) -> IStream const* {
        1: 4920:        if( filename.empty() )
        1: 4921:            return new Detail::CoutStream();
    #####: 4922:        else if( filename[0] == '%' ) {
    #####: 4923:            if( filename == "%debug" )
    #####: 4924:                return new Detail::DebugOutStream();
        -: 4925:            else
    #####: 4926:                CATCH_ERROR( "Unrecognised stream: '" << filename << "'" );
        -: 4927:        }
        -: 4928:        else
    #####: 4929:            return new Detail::FileStream( filename );
        -: 4930:    }
        -: 4931:
        -: 4932:
        -: 4933:    // This class encapsulates the idea of a pool of ostringstreams that can be reused.
        4: 4934:    struct StringStreams {
        -: 4935:        std::vector<Detail::unique_ptr<std::ostringstream>> m_streams;
        -: 4936:        std::vector<std::size_t> m_unused;
        -: 4937:        std::ostringstream m_referenceStream; // Used for copy state/ flags from
        -: 4938:
        1: 4939:        auto add() -> std::size_t {
        1: 4940:            if( m_unused.empty() ) {
        3: 4941:                m_streams.push_back( Detail::unique_ptr<std::ostringstream>( new std::ostringstream ) );
        1: 4942:                return m_streams.size()-1;
        -: 4943:            }
        -: 4944:            else {
    #####: 4945:                auto index = m_unused.back();
        -: 4946:                m_unused.pop_back();
    #####: 4947:                return index;
        -: 4948:            }
        -: 4949:        }
        -: 4950:
        1: 4951:        void release( std::size_t index ) {
        2: 4952:            m_streams[index]->copyfmt( m_referenceStream ); // Restore initial flags and other state
        1: 4953:            m_unused.push_back(index);
        1: 4954:        }
        -: 4955:    };
        -: 4956:
        1: 4957:    ReusableStringStream::ReusableStringStream()
        1: 4958:    :   m_index( Singleton<StringStreams>::getMutable().add() ),
        2: 4959:        m_oss( Singleton<StringStreams>::getMutable().m_streams[m_index].get() )
        1: 4960:    {}
        -: 4961:
        2: 4962:    ReusableStringStream::~ReusableStringStream() {
        2: 4963:        static_cast<std::ostringstream*>( m_oss )->str("");
        1: 4964:        m_oss->clear();
        2: 4965:        Singleton<StringStreams>::getMutable().release( m_index );
        1: 4966:    }
        -: 4967:
    #####: 4968:    std::string ReusableStringStream::str() const {
    #####: 4969:        return static_cast<std::ostringstream*>( m_oss )->str();
        -: 4970:    }
        -: 4971:
    #####: 4972:    void ReusableStringStream::str( std::string const& str ) {
    #####: 4973:        static_cast<std::ostringstream*>( m_oss )->str( str );
    #####: 4974:    }
        -: 4975:
        -: 4976:
        -: 4977:    ///////////////////////////////////////////////////////////////////////////
        -: 4978:
        -: 4979:
        -: 4980:#ifndef CATCH_CONFIG_NOSTDOUT // If you #define this you must implement these functions
    #####: 4981:    std::ostream& cout() { return std::cout; }
    #####: 4982:    std::ostream& cerr() { return std::cerr; }
    #####: 4983:    std::ostream& clog() { return std::clog; }
        -: 4984:#endif
        -: 4985:}
        -: 4986:
        -: 4987:
        -: 4988:
        -: 4989:#include <algorithm>
        -: 4990:#include <ostream>
        -: 4991:#include <cstring>
        -: 4992:#include <cctype>
        -: 4993:#include <vector>
        -: 4994:
        -: 4995:namespace Catch {
        -: 4996:
        -: 4997:    namespace {
       11: 4998:        char toLowerCh(char c) {
       11: 4999:            return static_cast<char>( std::tolower( static_cast<unsigned char>(c) ) );
        -: 5000:        }
        -: 5001:    }
        -: 5002:
    #####: 5003:    bool startsWith( std::string const& s, std::string const& prefix ) {
    #####: 5004:        return s.size() >= prefix.size() && std::equal(prefix.begin(), prefix.end(), s.begin());
        -: 5005:    }
    #####: 5006:    bool startsWith( std::string const& s, char prefix ) {
        1: 5007:        return !s.empty() && s[0] == prefix;
        -: 5008:    }
    #####: 5009:    bool endsWith( std::string const& s, std::string const& suffix ) {
    #####: 5010:        return s.size() >= suffix.size() && std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());
        -: 5011:    }
    #####: 5012:    bool endsWith( std::string const& s, char suffix ) {
    #####: 5013:        return !s.empty() && s[s.size()-1] == suffix;
        -: 5014:    }
    #####: 5015:    bool contains( std::string const& s, std::string const& infix ) {
    #####: 5016:        return s.find( infix ) != std::string::npos;
        -: 5017:    }
        1: 5018:    void toLowerInPlace( std::string& s ) {
        -: 5019:        std::transform( s.begin(), s.end(), s.begin(), toLowerCh );
        1: 5020:    }
    #####: 5021:    std::string toLower( std::string const& s ) {
        -: 5022:        std::string lc = s;
    #####: 5023:        toLowerInPlace( lc );
    #####: 5024:        return lc;
        -: 5025:    }
        2: 5026:    std::string trim( std::string const& str ) {
        -: 5027:        static char const* whitespaceChars = "\n\r\t ";
        2: 5028:        std::string::size_type start = str.find_first_not_of( whitespaceChars );
        2: 5029:        std::string::size_type end = str.find_last_not_of( whitespaceChars );
        -: 5030:
        4: 5031:        return start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();
        -: 5032:    }
        -: 5033:
    #####: 5034:    StringRef trim(StringRef ref) {
        -: 5035:        const auto is_ws = [](char c) {
    #####: 5036:            return c == ' ' || c == '\t' || c == '\n' || c == '\r';
        -: 5037:        };
        -: 5038:        size_t real_begin = 0;
    #####: 5039:        while (real_begin < ref.size() && is_ws(ref[real_begin])) { ++real_begin; }
        -: 5040:        size_t real_end = ref.size();
    #####: 5041:        while (real_end > real_begin && is_ws(ref[real_end - 1])) { --real_end; }
        -: 5042:
    #####: 5043:        return ref.substr(real_begin, real_end - real_begin);
        -: 5044:    }
        -: 5045:
    #####: 5046:    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis ) {
        -: 5047:        bool replaced = false;
        -: 5048:        std::size_t i = str.find( replaceThis );
    #####: 5049:        while( i != std::string::npos ) {
        -: 5050:            replaced = true;
    #####: 5051:            str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );
    #####: 5052:            if( i < str.size()-withThis.size() )
    #####: 5053:                i = str.find( replaceThis, i+withThis.size() );
        -: 5054:            else
        -: 5055:                i = std::string::npos;
        -: 5056:        }
    #####: 5057:        return replaced;
        -: 5058:    }
        -: 5059:
    #####: 5060:    std::vector<StringRef> splitStringRef( StringRef str, char delimiter ) {
        -: 5061:        std::vector<StringRef> subStrings;
        -: 5062:        std::size_t start = 0;
    #####: 5063:        for(std::size_t pos = 0; pos < str.size(); ++pos ) {
    #####: 5064:            if( str[pos] == delimiter ) {
    #####: 5065:                if( pos - start > 1 )
    #####: 5066:                    subStrings.push_back( str.substr( start, pos-start ) );
    #####: 5067:                start = pos+1;
        -: 5068:            }
        -: 5069:        }
    #####: 5070:        if( start < str.size() )
    #####: 5071:            subStrings.push_back( str.substr( start, str.size()-start ) );
    #####: 5072:        return subStrings;
        -: 5073:    }
        -: 5074:
    #####: 5075:    pluralise::pluralise( std::size_t count, std::string const& label )
        -: 5076:    :   m_count( count ),
        2: 5077:        m_label( label )
    #####: 5078:    {}
        -: 5079:
        2: 5080:    std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser ) {
        2: 5081:        os << pluraliser.m_count << ' ' << pluraliser.m_label;
        2: 5082:        if( pluraliser.m_count != 1 )
        -: 5083:            os << 's';
        2: 5084:        return os;
        -: 5085:    }
        -: 5086:
        -: 5087:}
        -: 5088:
        -: 5089:
        -: 5090:
        -: 5091:#include <algorithm>
        -: 5092:#include <ostream>
        -: 5093:#include <cstring>
        -: 5094:#include <cstdint>
        -: 5095:
        -: 5096:namespace Catch {
    #####: 5097:    StringRef::StringRef( char const* rawChars ) noexcept
        1: 5098:    : StringRef( rawChars, static_cast<StringRef::size_type>(std::strlen(rawChars) ) )
    #####: 5099:    {}
        -: 5100:
    #####: 5101:    auto StringRef::c_str() const -> char const* {
    #####: 5102:        CATCH_ENFORCE(isNullTerminated(), "Called StringRef::c_str() on a non-null-terminated instance");
    #####: 5103:        return m_start;
        -: 5104:    }
        -: 5105:
    #####: 5106:    auto StringRef::operator == ( StringRef const& other ) const noexcept -> bool {
    #####: 5107:        return m_size == other.m_size
       10: 5108:            && (std::memcmp( m_start, other.m_start, m_size ) == 0);
        -: 5109:    }
        -: 5110:
    #####: 5111:    bool StringRef::operator<(StringRef const& rhs) const noexcept {
    #####: 5112:        if (m_size < rhs.m_size) {
    #####: 5113:            return strncmp(m_start, rhs.m_start, m_size) <= 0;
        -: 5114:        }
    #####: 5115:        return strncmp(m_start, rhs.m_start, rhs.m_size) < 0;
        -: 5116:    }
        -: 5117:
    #####: 5118:    auto operator << ( std::ostream& os, StringRef const& str ) -> std::ostream& {
    #####: 5119:        return os.write(str.data(), str.size());
        -: 5120:    }
        -: 5121:
    #####: 5122:    std::string operator+(StringRef lhs, StringRef rhs) {
        -: 5123:        std::string ret;
    #####: 5124:        ret.reserve(lhs.size() + rhs.size());
        -: 5125:        ret += lhs;
        -: 5126:        ret += rhs;
    #####: 5127:        return ret;
        -: 5128:    }
        -: 5129:
    #####: 5130:    auto operator+=( std::string& lhs, StringRef const& rhs ) -> std::string& {
        2: 5131:        lhs.append(rhs.data(), rhs.size());
    #####: 5132:        return lhs;
        -: 5133:    }
        -: 5134:
        -: 5135:} // namespace Catch
        -: 5136:
        -: 5137:
        -: 5138:
        -: 5139:namespace Catch {
        -: 5140:
        2: 5141:    TagAliasRegistry::~TagAliasRegistry() {}
        -: 5142:
    #####: 5143:    TagAlias const* TagAliasRegistry::find( std::string const& alias ) const {
        -: 5144:        auto it = m_registry.find( alias );
    #####: 5145:        if( it != m_registry.end() )
    #####: 5146:            return &(it->second);
        -: 5147:        else
        -: 5148:            return nullptr;
        -: 5149:    }
        -: 5150:
    #####: 5151:    std::string TagAliasRegistry::expandAliases( std::string const& unexpandedTestSpec ) const {
        -: 5152:        std::string expandedTestSpec = unexpandedTestSpec;
    #####: 5153:        for( auto const& registryKvp : m_registry ) {
        -: 5154:            std::size_t pos = expandedTestSpec.find( registryKvp.first );
    #####: 5155:            if( pos != std::string::npos ) {
    #####: 5156:                expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +
    #####: 5157:                                    registryKvp.second.tag +
    #####: 5158:                                    expandedTestSpec.substr( pos + registryKvp.first.size() );
        -: 5159:            }
        -: 5160:        }
    #####: 5161:        return expandedTestSpec;
        -: 5162:    }
        -: 5163:
    #####: 5164:    void TagAliasRegistry::add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) {
    #####: 5165:        CATCH_ENFORCE( startsWith(alias, "[@") && endsWith(alias, ']'),
        -: 5166:                      "error: tag alias, '" << alias << "' is not of the form [@alias name].\n" << lineInfo );
        -: 5167:
    #####: 5168:        CATCH_ENFORCE( m_registry.insert(std::make_pair(alias, TagAlias(tag, lineInfo))).second,
        -: 5169:                      "error: tag alias, '" << alias << "' already registered.\n"
        -: 5170:                      << "\tFirst seen at: " << find(alias)->lineInfo << "\n"
        -: 5171:                      << "\tRedefined at: " << lineInfo );
    #####: 5172:    }
        -: 5173:
        1: 5174:    ITagAliasRegistry::~ITagAliasRegistry() {}
        -: 5175:
    #####: 5176:    ITagAliasRegistry const& ITagAliasRegistry::get() {
        1: 5177:        return getRegistryHub().getTagAliasRegistry();
        -: 5178:    }
        -: 5179:
        -: 5180:} // end namespace Catch
        -: 5181:
        -: 5182:
        -: 5183:
        -: 5184:
        -: 5185:#include <algorithm>
        -: 5186:#include <set>
        -: 5187:
        -: 5188:namespace Catch {
        -: 5189:
        -: 5190:namespace {
        -: 5191:    struct HashTest {
    #####: 5192:        explicit HashTest(SimplePcg32& rng_inst) {
    #####: 5193:            basis = rng_inst();
    #####: 5194:            basis <<= 32;
    #####: 5195:            basis |= rng_inst();
    #####: 5196:        }
        -: 5197:
        -: 5198:        uint64_t basis;
        -: 5199:
        -: 5200:        uint64_t operator()(TestCaseInfo const& t) const {
        -: 5201:            // Modified FNV-1a hash
        -: 5202:            static constexpr uint64_t prime = 1099511628211;
    #####: 5203:            uint64_t hash = basis;
    #####: 5204:            for (const char c : t.name) {
    #####: 5205:                hash ^= c;
    #####: 5206:                hash *= prime;
        -: 5207:            }
        -: 5208:            return hash;
        -: 5209:        }
        -: 5210:    };
        -: 5211:} // end anonymous namespace
        -: 5212:
        1: 5213:    std::vector<TestCaseHandle> sortTests( IConfig const& config, std::vector<TestCaseHandle> const& unsortedTestCases ) {
        1: 5214:        switch (config.runOrder()) {
        -: 5215:        case TestRunOrder::Declared:
        1: 5216:            return unsortedTestCases;
        -: 5217:
        -: 5218:        case TestRunOrder::LexicographicallySorted: {
    #####: 5219:            std::vector<TestCaseHandle> sorted = unsortedTestCases;
        -: 5220:            std::sort(sorted.begin(), sorted.end());
        -: 5221:            return sorted;
        -: 5222:        }
        -: 5223:        case TestRunOrder::Randomized: {
    #####: 5224:            seedRng(config);
    #####: 5225:            HashTest h(rng());
        -: 5226:            std::vector<std::pair<uint64_t, TestCaseHandle>> indexed_tests;
    #####: 5227:            indexed_tests.reserve(unsortedTestCases.size());
        -: 5228:
    #####: 5229:            for (auto const& handle : unsortedTestCases) {
    #####: 5230:                indexed_tests.emplace_back(h(handle.getTestCaseInfo()), handle);
        -: 5231:            }
        -: 5232:
        -: 5233:            std::sort(indexed_tests.begin(), indexed_tests.end());
        -: 5234:
        -: 5235:            std::vector<TestCaseHandle> randomized;
    #####: 5236:            randomized.reserve(indexed_tests.size());
        -: 5237:
    #####: 5238:            for (auto const& indexed : indexed_tests) {
    #####: 5239:                randomized.push_back(indexed.second);
        -: 5240:            }
        -: 5241:
        -: 5242:            return randomized;
        -: 5243:        }
        -: 5244:        }
        -: 5245:
    #####: 5246:        CATCH_INTERNAL_ERROR("Unknown test order value!");
        -: 5247:    }
        -: 5248:
    #####: 5249:    bool isThrowSafe( TestCaseHandle const& testCase, IConfig const& config ) {
    #####: 5250:        return !testCase.getTestCaseInfo().throws() || config.allowThrows();
        -: 5251:    }
        -: 5252:
    #####: 5253:    bool matchTest( TestCaseHandle const& testCase, TestSpec const& testSpec, IConfig const& config ) {
    #####: 5254:        return testSpec.matches( testCase.getTestCaseInfo() ) && isThrowSafe( testCase, config );
        -: 5255:    }
        -: 5256:
        1: 5257:    void enforceNoDuplicateTestCases( std::vector<TestCaseHandle> const& functions ) {
        -: 5258:        std::set<TestCaseHandle> seenFunctions;
        2: 5259:        for( auto const& function : functions ) {
        -: 5260:            auto prev = seenFunctions.insert( function );
        1: 5261:            CATCH_ENFORCE( prev.second,
        -: 5262:                    "error: TEST_CASE( \"" << function.getTestCaseInfo().name << "\" ) already defined.\n"
        -: 5263:                    << "\tFirst seen at " << prev.first->getTestCaseInfo().lineInfo << "\n"
        -: 5264:                    << "\tRedefined at " << function.getTestCaseInfo().lineInfo );
        -: 5265:        }
        1: 5266:    }
        -: 5267:
    #####: 5268:    std::vector<TestCaseHandle> filterTests( std::vector<TestCaseHandle> const& testCases, TestSpec const& testSpec, IConfig const& config ) {
        -: 5269:        std::vector<TestCaseHandle> filtered;
    #####: 5270:        filtered.reserve( testCases.size() );
    #####: 5271:        for (auto const& testCase : testCases) {
    #####: 5272:            if ((!testSpec.hasFilters() && !testCase.getTestCaseInfo().isHidden()) ||
    #####: 5273:                (testSpec.hasFilters() && matchTest(testCase, testSpec, config))) {
    #####: 5274:                filtered.push_back(testCase);
        -: 5275:            }
        -: 5276:        }
    #####: 5277:        return filtered;
        -: 5278:    }
        1: 5279:    std::vector<TestCaseHandle> const& getAllTestCasesSorted( IConfig const& config ) {
        1: 5280:        return getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );
        -: 5281:    }
        -: 5282:
        1: 5283:    void TestRegistry::registerTest(Detail::unique_ptr<TestCaseInfo> testInfo, Detail::unique_ptr<ITestInvoker> testInvoker) {
        2: 5284:        m_handles.emplace_back(testInfo.get(), testInvoker.get());
        2: 5285:        m_viewed_test_infos.push_back(testInfo.get());
        1: 5286:        m_owned_test_infos.push_back(std::move(testInfo));
        1: 5287:        m_invokers.push_back(std::move(testInvoker));
        1: 5288:    }
        -: 5289:
    #####: 5290:    std::vector<TestCaseInfo*> const& TestRegistry::getAllInfos() const {
    #####: 5291:        return m_viewed_test_infos;
        -: 5292:    }
        -: 5293:
    #####: 5294:    std::vector<TestCaseHandle> const& TestRegistry::getAllTests() const {
    #####: 5295:        return m_handles;
        -: 5296:    }
        1: 5297:    std::vector<TestCaseHandle> const& TestRegistry::getAllTestsSorted( IConfig const& config ) const {
        1: 5298:        if( m_sortedFunctions.empty() )
        1: 5299:            enforceNoDuplicateTestCases( m_handles );
        -: 5300:
        1: 5301:        if(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) {
        2: 5302:            m_sortedFunctions = sortTests( config, m_handles );
        1: 5303:            m_currentSortOrder = config.runOrder();
        -: 5304:        }
        1: 5305:        return m_sortedFunctions;
        -: 5306:    }
        -: 5307:
        -: 5308:
        -: 5309:
        -: 5310:    ///////////////////////////////////////////////////////////////////////////
        1: 5311:    void TestInvokerAsFunction::invoke() const {
        1: 5312:        m_testAsFunction();
        1: 5313:    }
        -: 5314:
        1: 5315:    std::string extractClassName( StringRef const& classOrQualifiedMethodName ) {
        -: 5316:        std::string className(classOrQualifiedMethodName);
        1: 5317:        if( startsWith( className, '&' ) )
        -: 5318:        {
        -: 5319:            std::size_t lastColons = className.rfind( "::" );
    #####: 5320:            std::size_t penultimateColons = className.rfind( "::", lastColons-1 );
    #####: 5321:            if( penultimateColons == std::string::npos )
        -: 5322:                penultimateColons = 1;
    #####: 5323:            className = className.substr( penultimateColons, lastColons-penultimateColons );
        -: 5324:        }
        1: 5325:        return className;
        -: 5326:    }
        -: 5327:
        -: 5328:} // end namespace Catch
        -: 5329:
        -: 5330:
        -: 5331:
        -: 5332:
        -: 5333:#include <algorithm>
        -: 5334:#include <cassert>
        -: 5335:#include <memory>
        -: 5336:
        -: 5337:#if defined(__clang__)
        -: 5338:#    pragma clang diagnostic push
        -: 5339:#    pragma clang diagnostic ignored "-Wexit-time-destructors"
        -: 5340:#endif
        -: 5341:
        -: 5342:namespace Catch {
        -: 5343:namespace TestCaseTracking {
        -: 5344:
    #####: 5345:    NameAndLocation::NameAndLocation( std::string const& _name, SourceLineInfo const& _location )
        -: 5346:    :   name( _name ),
        2: 5347:        location( _location )
    #####: 5348:    {}
        -: 5349:
        -: 5350:
        -: 5351:    ITracker::~ITracker() = default;
        -: 5352:
    #####: 5353:    void ITracker::addChild( ITrackerPtr const& child ) {
        1: 5354:        m_children.push_back( child );
    #####: 5355:    }
        -: 5356:
        1: 5357:    ITrackerPtr ITracker::findChild( NameAndLocation const& nameAndLocation ) {
        -: 5358:        auto it = std::find_if(
        -: 5359:            m_children.begin(),
        -: 5360:            m_children.end(),
    #####: 5361:            [&nameAndLocation]( ITrackerPtr const& tracker ) {
    #####: 5362:                return tracker->nameAndLocation().location ==
    #####: 5363:                           nameAndLocation.location &&
    #####: 5364:                       tracker->nameAndLocation().name == nameAndLocation.name;
    #####: 5365:            } );
        2: 5366:        return ( it != m_children.end() ) ? *it : nullptr;
        -: 5367:    }
        -: 5368:
        -: 5369:
        -: 5370:
        1: 5371:    ITracker& TrackerContext::startRun() {
        -: 5372:        using namespace std::string_literals;
        4: 5373:        m_rootTracker = std::make_shared<SectionTracker>( NameAndLocation( "{root}"s, CATCH_INTERNAL_LINEINFO ), *this, nullptr );
        1: 5374:        m_currentTracker = nullptr;
        1: 5375:        m_runState = Executing;
        1: 5376:        return *m_rootTracker;
        -: 5377:    }
        -: 5378:
    #####: 5379:    void TrackerContext::endRun() {
        -: 5380:        m_rootTracker.reset();
    #####: 5381:        m_currentTracker = nullptr;
    #####: 5382:        m_runState = NotStarted;
    #####: 5383:    }
        -: 5384:
    #####: 5385:    void TrackerContext::startCycle() {
        1: 5386:        m_currentTracker = m_rootTracker.get();
        1: 5387:        m_runState = Executing;
    #####: 5388:    }
    #####: 5389:    void TrackerContext::completeCycle() {
        1: 5390:        m_runState = CompletedCycle;
    #####: 5391:    }
        -: 5392:
    #####: 5393:    bool TrackerContext::completedCycle() const {
        1: 5394:        return m_runState == CompletedCycle;
        -: 5395:    }
    #####: 5396:    ITracker& TrackerContext::currentTracker() {
        2: 5397:        return *m_currentTracker;
        -: 5398:    }
    #####: 5399:    void TrackerContext::setCurrentTracker( ITracker* tracker ) {
        2: 5400:        m_currentTracker = tracker;
    #####: 5401:    }
        -: 5402:
        -: 5403:
    #####: 5404:    TrackerBase::TrackerBase( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent ):
        -: 5405:        ITracker(nameAndLocation),
        -: 5406:        m_ctx( ctx ),
        2: 5407:        m_parent( parent )
    #####: 5408:    {}
        -: 5409:
    #####: 5410:    bool TrackerBase::isComplete() const {
        1: 5411:        return m_runState == CompletedSuccessfully || m_runState == Failed;
        -: 5412:    }
        1: 5413:    bool TrackerBase::isSuccessfullyCompleted() const {
        1: 5414:        return m_runState == CompletedSuccessfully;
        -: 5415:    }
    #####: 5416:    bool TrackerBase::isOpen() const {
    #####: 5417:        return m_runState != NotStarted && !isComplete();
        -: 5418:    }
        -: 5419:
    #####: 5420:    ITracker& TrackerBase::parent() {
    #####: 5421:        assert( m_parent ); // Should always be non-null except for root
    #####: 5422:        return *m_parent;
        -: 5423:    }
        -: 5424:
        1: 5425:    void TrackerBase::openChild() {
        1: 5426:        if( m_runState != ExecutingChildren ) {
        1: 5427:            m_runState = ExecutingChildren;
        1: 5428:            if( m_parent )
    #####: 5429:                m_parent->openChild();
        -: 5430:        }
        1: 5431:    }
        -: 5432:
    #####: 5433:    bool TrackerBase::isSectionTracker() const { return false; }
    #####: 5434:    bool TrackerBase::isGeneratorTracker() const { return false; }
        -: 5435:
    #####: 5436:    void TrackerBase::open() {
        1: 5437:        m_runState = Executing;
        -: 5438:        moveToThis();
        1: 5439:        if( m_parent )
        1: 5440:            m_parent->openChild();
    #####: 5441:    }
        -: 5442:
        1: 5443:    void TrackerBase::close() {
        -: 5444:
        -: 5445:        // Close any still open children (e.g. generators)
        2: 5446:        while( &m_ctx.currentTracker() != this )
    #####: 5447:            m_ctx.currentTracker().close();
        -: 5448:
        1: 5449:        switch( m_runState ) {
        -: 5450:            case NeedsAnotherRun:
        -: 5451:                break;
        -: 5452:
        -: 5453:            case Executing:
        1: 5454:                m_runState = CompletedSuccessfully;
        1: 5455:                break;
        -: 5456:            case ExecutingChildren:
    #####: 5457:                if( std::all_of(m_children.begin(), m_children.end(), [](ITrackerPtr const& t){ return t->isComplete(); }) )
    #####: 5458:                    m_runState = CompletedSuccessfully;
        -: 5459:                break;
        -: 5460:
        -: 5461:            case NotStarted:
        -: 5462:            case CompletedSuccessfully:
        -: 5463:            case Failed:
    #####: 5464:                CATCH_INTERNAL_ERROR( "Illogical state: " << m_runState );
        -: 5465:
        -: 5466:            default:
    #####: 5467:                CATCH_INTERNAL_ERROR( "Unknown state: " << m_runState );
        -: 5468:        }
        -: 5469:        moveToParent();
        -: 5470:        m_ctx.completeCycle();
        1: 5471:    }
    #####: 5472:    void TrackerBase::fail() {
    #####: 5473:        m_runState = Failed;
    #####: 5474:        if( m_parent )
    #####: 5475:            m_parent->markAsNeedingAnotherRun();
        -: 5476:        moveToParent();
        -: 5477:        m_ctx.completeCycle();
    #####: 5478:    }
    #####: 5479:    void TrackerBase::markAsNeedingAnotherRun() {
    #####: 5480:        m_runState = NeedsAnotherRun;
    #####: 5481:    }
        -: 5482:
    #####: 5483:    void TrackerBase::moveToParent() {
        1: 5484:        assert( m_parent );
        1: 5485:        m_ctx.setCurrentTracker( m_parent );
    #####: 5486:    }
    #####: 5487:    void TrackerBase::moveToThis() {
        1: 5488:        m_ctx.setCurrentTracker( this );
    #####: 5489:    }
        -: 5490:
        2: 5491:    SectionTracker::SectionTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )
        -: 5492:    :   TrackerBase( nameAndLocation, ctx, parent ),
        4: 5493:        m_trimmed_name(trim(nameAndLocation.name))
        -: 5494:    {
        2: 5495:        if( parent ) {
        1: 5496:            while( !parent->isSectionTracker() )
    #####: 5497:                parent = &parent->parent();
        -: 5498:
        -: 5499:            SectionTracker& parentSection = static_cast<SectionTracker&>( *parent );
        1: 5500:            addNextFilters( parentSection.m_filters );
        -: 5501:        }
        2: 5502:    }
        -: 5503:
        1: 5504:    bool SectionTracker::isComplete() const {
        -: 5505:        bool complete = true;
        -: 5506:
        1: 5507:        if (m_filters.empty()
    #####: 5508:            || m_filters[0] == ""
        1: 5509:            || std::find(m_filters.begin(), m_filters.end(), m_trimmed_name) != m_filters.end()) {
        -: 5510:            complete = TrackerBase::isComplete();
        -: 5511:        }
        1: 5512:        return complete;
        -: 5513:    }
        -: 5514:
        2: 5515:    bool SectionTracker::isSectionTracker() const { return true; }
        -: 5516:
        1: 5517:    SectionTracker& SectionTracker::acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation ) {
        1: 5518:        std::shared_ptr<SectionTracker> section;
        -: 5519:
        -: 5520:        ITracker& currentTracker = ctx.currentTracker();
        1: 5521:        if( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
    #####: 5522:            assert( childTracker );
    #####: 5523:            assert( childTracker->isSectionTracker() );
        -: 5524:            section = std::static_pointer_cast<SectionTracker>( childTracker );
        -: 5525:        }
        -: 5526:        else {
        2: 5527:            section = std::make_shared<SectionTracker>( nameAndLocation, ctx, &currentTracker );
        1: 5528:            currentTracker.addChild( section );
        -: 5529:        }
        1: 5530:        if( !ctx.completedCycle() )
        1: 5531:            section->tryOpen();
        1: 5532:        return *section;
        -: 5533:    }
        -: 5534:
        1: 5535:    void SectionTracker::tryOpen() {
        1: 5536:        if( !isComplete() )
        -: 5537:            open();
        1: 5538:    }
        -: 5539:
        1: 5540:    void SectionTracker::addInitialFilters( std::vector<std::string> const& filters ) {
        1: 5541:        if( !filters.empty() ) {
    #####: 5542:            m_filters.reserve( m_filters.size() + filters.size() + 2 );
    #####: 5543:            m_filters.emplace_back(""); // Root - should never be consulted
    #####: 5544:            m_filters.emplace_back(""); // Test Case - not a section filter
    #####: 5545:            m_filters.insert( m_filters.end(), filters.begin(), filters.end() );
        -: 5546:        }
        1: 5547:    }
        1: 5548:    void SectionTracker::addNextFilters( std::vector<std::string> const& filters ) {
        1: 5549:        if( filters.size() > 1 )
    #####: 5550:            m_filters.insert( m_filters.end(), filters.begin()+1, filters.end() );
        1: 5551:    }
        -: 5552:
        -: 5553:} // namespace TestCaseTracking
        -: 5554:
        -: 5555:using TestCaseTracking::ITracker;
        -: 5556:using TestCaseTracking::TrackerContext;
        -: 5557:using TestCaseTracking::SectionTracker;
        -: 5558:
        -: 5559:} // namespace Catch
        -: 5560:
        -: 5561:#if defined(__clang__)
        -: 5562:#    pragma clang diagnostic pop
        -: 5563:#endif
        -: 5564:
        -: 5565:
        -: 5566:
        -: 5567:namespace Catch {
        -: 5568:
    #####: 5569:    Detail::unique_ptr<ITestInvoker> makeTestInvoker( void(*testAsFunction)() ) {
        1: 5570:        return Detail::unique_ptr<ITestInvoker>( new TestInvokerAsFunction( testAsFunction ));
        -: 5571:    }
        -: 5572:
        1: 5573:    AutoReg::AutoReg( Detail::unique_ptr<ITestInvoker> invoker, SourceLineInfo const& lineInfo, StringRef const& classOrMethod, NameAndTags const& nameAndTags ) noexcept {
        -: 5574:        CATCH_TRY {
        -: 5575:            getMutableRegistryHub()
        -: 5576:                    .registerTest(
        2: 5577:                        makeTestCaseInfo(
        2: 5578:                            extractClassName( classOrMethod ),
        -: 5579:                            nameAndTags,
        -: 5580:                            lineInfo),
        -: 5581:                        std::move(invoker)
        2: 5582:                    );
    =====: 5583:        } CATCH_CATCH_ALL {
        -: 5584:            // Do not throw when constructing global objects, instead register the exception to be processed later
    =====: 5585:            getMutableRegistryHub().registerStartupException();
        -: 5586:        }
        1: 5587:    }
        -: 5588:}
        -: 5589:
        -: 5590:
        -: 5591:
        -: 5592:
        -: 5593:
        -: 5594:namespace Catch {
        -: 5595:
        2: 5596:    TestSpecParser::TestSpecParser( ITagAliasRegistry const& tagAliases ) : m_tagAliases( &tagAliases ) {}
        -: 5597:
    #####: 5598:    TestSpecParser& TestSpecParser::parse( std::string const& arg ) {
    #####: 5599:        m_mode = None;
    #####: 5600:        m_exclusion = false;
    #####: 5601:        m_arg = m_tagAliases->expandAliases( arg );
        -: 5602:        m_escapeChars.clear();
    #####: 5603:        m_substring.reserve(m_arg.size());
    #####: 5604:        m_patternName.reserve(m_arg.size());
    #####: 5605:        m_realPatternPos = 0;
        -: 5606:
    #####: 5607:        for( m_pos = 0; m_pos < m_arg.size(); ++m_pos )
        -: 5608:          //if visitChar fails
    #####: 5609:           if( !visitChar( m_arg[m_pos] ) ){
    #####: 5610:               m_testSpec.m_invalidArgs.push_back(arg);
    #####: 5611:               break;
        -: 5612:           }
    #####: 5613:        endMode();
    #####: 5614:        return *this;
        -: 5615:    }
        1: 5616:    TestSpec TestSpecParser::testSpec() {
        1: 5617:        addFilter();
        1: 5618:        return std::move(m_testSpec);
        -: 5619:    }
    #####: 5620:    bool TestSpecParser::visitChar( char c ) {
    #####: 5621:        if( (m_mode != EscapedName) && (c == '\\') ) {
        -: 5622:            escape();
    #####: 5623:            addCharToPattern(c);
    #####: 5624:            return true;
    #####: 5625:        }else if((m_mode != EscapedName) && (c == ',') )  {
    #####: 5626:            return separate();
        -: 5627:        }
        -: 5628:
    #####: 5629:        switch( m_mode ) {
        -: 5630:        case None:
    #####: 5631:            if( processNoneChar( c ) )
        -: 5632:                return true;
        -: 5633:            break;
        -: 5634:        case Name:
    #####: 5635:            processNameChar( c );
    #####: 5636:            break;
        -: 5637:        case EscapedName:
    #####: 5638:            endMode();
    #####: 5639:            addCharToPattern(c);
    #####: 5640:            return true;
        -: 5641:        default:
        -: 5642:        case Tag:
        -: 5643:        case QuotedName:
    #####: 5644:            if( processOtherChar( c ) )
        -: 5645:                return true;
        -: 5646:            break;
        -: 5647:        }
        -: 5648:
    #####: 5649:        m_substring += c;
    #####: 5650:        if( !isControlChar( c ) ) {
    #####: 5651:            m_patternName += c;
    #####: 5652:            m_realPatternPos++;
        -: 5653:        }
        -: 5654:        return true;
        -: 5655:    }
        -: 5656:    // Two of the processing methods return true to signal the caller to return
        -: 5657:    // without adding the given character to the current pattern strings
    #####: 5658:    bool TestSpecParser::processNoneChar( char c ) {
    #####: 5659:        switch( c ) {
        -: 5660:        case ' ':
        -: 5661:            return true;
        -: 5662:        case '~':
    #####: 5663:            m_exclusion = true;
    #####: 5664:            return false;
        -: 5665:        case '[':
        -: 5666:            startNewMode( Tag );
    #####: 5667:            return false;
        -: 5668:        case '"':
        -: 5669:            startNewMode( QuotedName );
    #####: 5670:            return false;
        -: 5671:        default:
        -: 5672:            startNewMode( Name );
    #####: 5673:            return false;
        -: 5674:        }
        -: 5675:    }
    #####: 5676:    void TestSpecParser::processNameChar( char c ) {
    #####: 5677:        if( c == '[' ) {
    #####: 5678:            if( m_substring == "exclude:" )
    #####: 5679:                m_exclusion = true;
        -: 5680:            else
    #####: 5681:                endMode();
        -: 5682:            startNewMode( Tag );
        -: 5683:        }
    #####: 5684:    }
    #####: 5685:    bool TestSpecParser::processOtherChar( char c ) {
    #####: 5686:        if( !isControlChar( c ) )
        -: 5687:            return false;
    #####: 5688:        m_substring += c;
    #####: 5689:        endMode();
    #####: 5690:        return true;
        -: 5691:    }
    #####: 5692:    void TestSpecParser::startNewMode( Mode mode ) {
    #####: 5693:        m_mode = mode;
    #####: 5694:    }
    #####: 5695:    void TestSpecParser::endMode() {
    #####: 5696:        switch( m_mode ) {
        -: 5697:        case Name:
        -: 5698:        case QuotedName:
    #####: 5699:            return addNamePattern();
        -: 5700:        case Tag:
    #####: 5701:            return addTagPattern();
        -: 5702:        case EscapedName:
        -: 5703:            revertBackToLastMode();
        -: 5704:            return;
        -: 5705:        case None:
        -: 5706:        default:
        -: 5707:            return startNewMode( None );
        -: 5708:        }
        -: 5709:    }
    #####: 5710:    void TestSpecParser::escape() {
        -: 5711:        saveLastMode();
    #####: 5712:        m_mode = EscapedName;
    #####: 5713:        m_escapeChars.push_back(m_realPatternPos);
    #####: 5714:    }
    #####: 5715:    bool TestSpecParser::isControlChar( char c ) const {
    #####: 5716:        switch( m_mode ) {
        -: 5717:            default:
        -: 5718:                return false;
        -: 5719:            case None:
    #####: 5720:                return c == '~';
        -: 5721:            case Name:
    #####: 5722:                return c == '[';
        -: 5723:            case EscapedName:
    #####: 5724:                return true;
        -: 5725:            case QuotedName:
    #####: 5726:                return c == '"';
        -: 5727:            case Tag:
    #####: 5728:                return c == '[' || c == ']';
        -: 5729:        }
        -: 5730:    }
        -: 5731:
        1: 5732:    void TestSpecParser::addFilter() {
        1: 5733:        if( !m_currentFilter.m_required.empty() || !m_currentFilter.m_forbidden.empty() ) {
    #####: 5734:            m_testSpec.m_filters.push_back( std::move(m_currentFilter) );
    #####: 5735:            m_currentFilter = TestSpec::Filter();
        -: 5736:        }
        1: 5737:    }
        -: 5738:
    #####: 5739:    void TestSpecParser::saveLastMode() {
    #####: 5740:      lastMode = m_mode;
    #####: 5741:    }
        -: 5742:
    #####: 5743:    void TestSpecParser::revertBackToLastMode() {
    #####: 5744:      m_mode = lastMode;
    #####: 5745:    }
        -: 5746:
    #####: 5747:    bool TestSpecParser::separate() {
    #####: 5748:      if( (m_mode==QuotedName) || (m_mode==Tag) ){
        -: 5749:         //invalid argument, signal failure to previous scope.
    #####: 5750:         m_mode = None;
    #####: 5751:         m_pos = m_arg.size();
        -: 5752:         m_substring.clear();
        -: 5753:         m_patternName.clear();
    #####: 5754:         m_realPatternPos = 0;
    #####: 5755:         return false;
        -: 5756:      }
    #####: 5757:      endMode();
    #####: 5758:      addFilter();
    #####: 5759:      return true; //success
        -: 5760:    }
        -: 5761:
    #####: 5762:    std::string TestSpecParser::preprocessPattern() {
        -: 5763:        std::string token = m_patternName;
    #####: 5764:        for (std::size_t i = 0; i < m_escapeChars.size(); ++i)
    #####: 5765:            token = token.substr(0, m_escapeChars[i] - i) + token.substr(m_escapeChars[i] - i + 1);
        -: 5766:        m_escapeChars.clear();
    #####: 5767:        if (startsWith(token, "exclude:")) {
    #####: 5768:            m_exclusion = true;
    #####: 5769:            token = token.substr(8);
        -: 5770:        }
        -: 5771:
        -: 5772:        m_patternName.clear();
    #####: 5773:        m_realPatternPos = 0;
        -: 5774:
    #####: 5775:        return token;
        -: 5776:    }
        -: 5777:
    #####: 5778:    void TestSpecParser::addNamePattern() {
    #####: 5779:        auto token = preprocessPattern();
        -: 5780:
    #####: 5781:        if (!token.empty()) {
    #####: 5782:            if (m_exclusion) {
    #####: 5783:                m_currentFilter.m_forbidden.emplace_back(Detail::make_unique<TestSpec::NamePattern>(token, m_substring));
        -: 5784:            } else {
    #####: 5785:                m_currentFilter.m_required.emplace_back(Detail::make_unique<TestSpec::NamePattern>(token, m_substring));
        -: 5786:            }
        -: 5787:        }
        -: 5788:        m_substring.clear();
    #####: 5789:        m_exclusion = false;
    #####: 5790:        m_mode = None;
    #####: 5791:    }
        -: 5792:
    #####: 5793:    void TestSpecParser::addTagPattern() {
    #####: 5794:        auto token = preprocessPattern();
        -: 5795:
    #####: 5796:        if (!token.empty()) {
        -: 5797:            // If the tag pattern is the "hide and tag" shorthand (e.g. [.foo])
        -: 5798:            // we have to create a separate hide tag and shorten the real one
    #####: 5799:            if (token.size() > 1 && token[0] == '.') {
        -: 5800:                token.erase(token.begin());
    #####: 5801:                if (m_exclusion) {
    #####: 5802:                    m_currentFilter.m_forbidden.emplace_back(Detail::make_unique<TestSpec::TagPattern>(".", m_substring));
    #####: 5803:                    m_currentFilter.m_forbidden.emplace_back(Detail::make_unique<TestSpec::TagPattern>(token, m_substring));
        -: 5804:                } else {
    #####: 5805:                    m_currentFilter.m_required.emplace_back(Detail::make_unique<TestSpec::TagPattern>(".", m_substring));
    #####: 5806:                    m_currentFilter.m_required.emplace_back(Detail::make_unique<TestSpec::TagPattern>(token, m_substring));
        -: 5807:                }
        -: 5808:            }
    #####: 5809:            if (m_exclusion) {
    #####: 5810:                m_currentFilter.m_forbidden.emplace_back(Detail::make_unique<TestSpec::TagPattern>(token, m_substring));
        -: 5811:            } else {
    #####: 5812:                m_currentFilter.m_required.emplace_back(Detail::make_unique<TestSpec::TagPattern>(token, m_substring));
        -: 5813:            }
        -: 5814:        }
        -: 5815:        m_substring.clear();
    #####: 5816:        m_exclusion = false;
    #####: 5817:        m_mode = None;
    #####: 5818:    }
        -: 5819:
    #####: 5820:    TestSpec parseTestSpec( std::string const& arg ) {
    #####: 5821:        return TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();
        -: 5822:    }
        -: 5823:
        -: 5824:} // namespace Catch
        -: 5825:
        -: 5826:
        -: 5827:#include <cstring>
        -: 5828:#include <ostream>
        -: 5829:
        -: 5830:namespace {
        -: 5831:    bool isWhitespace( char c ) {
    #####: 5832:        return c == ' ' || c == '\t' || c == '\n' || c == '\r';
        -: 5833:    }
        -: 5834:
        -: 5835:    bool isBreakableBefore( char c ) {
        -: 5836:        static const char chars[] = "[({<|";
    #####: 5837:        return std::memchr( chars, c, sizeof( chars ) - 1 ) != nullptr;
        -: 5838:    }
        -: 5839:
        -: 5840:    bool isBreakableAfter( char c ) {
        -: 5841:        static const char chars[] = "])}>.,:;*+-=&/\\";
    #####: 5842:        return std::memchr( chars, c, sizeof( chars ) - 1 ) != nullptr;
        -: 5843:    }
        -: 5844:
    #####: 5845:    bool isBoundary( std::string const& line, size_t at ) {
    #####: 5846:        assert( at > 0 );
    #####: 5847:        assert( at <= line.size() );
        -: 5848:
    #####: 5849:        return at == line.size() ||
    #####: 5850:               ( isWhitespace( line[at] ) && !isWhitespace( line[at - 1] ) ) ||
    #####: 5851:               isBreakableBefore( line[at] ) ||
    #####: 5852:               isBreakableAfter( line[at - 1] );
        -: 5853:    }
        -: 5854:
        -: 5855:} // namespace
        -: 5856:
        -: 5857:namespace Catch {
        -: 5858:    namespace TextFlow {
        -: 5859:
    #####: 5860:        void Column::iterator::calcLength() {
    #####: 5861:            m_suffix = false;
    #####: 5862:            auto width = m_column.m_width - indent();
    #####: 5863:            m_end = m_pos;
    #####: 5864:            std::string const& current_line = m_column.m_string;
    #####: 5865:            if ( current_line[m_pos] == '\n' ) {
    #####: 5866:                ++m_end;
        -: 5867:            }
    #####: 5868:            while ( m_end < current_line.size() &&
    #####: 5869:                    current_line[m_end] != '\n' ) {
    #####: 5870:                ++m_end;
        -: 5871:            }
        -: 5872:
    #####: 5873:            if ( m_end < m_pos + width ) {
    #####: 5874:                m_len = m_end - m_pos;
        -: 5875:            } else {
        -: 5876:                size_t len = width;
    #####: 5877:                while ( len > 0 && !isBoundary( current_line, m_pos + len ) ) {
    #####: 5878:                    --len;
        -: 5879:                }
    #####: 5880:                while ( len > 0 &&
    #####: 5881:                        isWhitespace( current_line[m_pos + len - 1] ) ) {
    #####: 5882:                    --len;
        -: 5883:                }
        -: 5884:
    #####: 5885:                if ( len > 0 ) {
    #####: 5886:                    m_len = len;
        -: 5887:                } else {
    #####: 5888:                    m_suffix = true;
    #####: 5889:                    m_len = width - 1;
        -: 5890:                }
        -: 5891:            }
    #####: 5892:        }
        -: 5893:
    #####: 5894:        size_t Column::iterator::indent() const {
        -: 5895:            auto initial =
    #####: 5896:                m_pos == 0 ? m_column.m_initialIndent : std::string::npos;
    #####: 5897:            return initial == std::string::npos ? m_column.m_indent : initial;
        -: 5898:        }
        -: 5899:
        -: 5900:        std::string
    #####: 5901:        Column::iterator::addIndentAndSuffix( size_t position,
        -: 5902:                                              size_t length ) const {
        -: 5903:            std::string ret;
        -: 5904:            const auto desired_indent = indent();
    #####: 5905:            ret.reserve( desired_indent + length + m_suffix );
        -: 5906:            ret.append( desired_indent, ' ' );
    #####: 5907:            ret.append( m_column.m_string, position, length );
    #####: 5908:            if ( m_suffix ) {
    #####: 5909:                ret.push_back( '-' );
        -: 5910:            }
        -: 5911:
    #####: 5912:            return ret;
        -: 5913:        }
        -: 5914:
    #####: 5915:        Column::iterator::iterator( Column const& column ): m_column( column ) {
    #####: 5916:            assert( m_column.m_width > m_column.m_indent );
    #####: 5917:            assert( m_column.m_initialIndent == std::string::npos ||
    #####: 5918:                    m_column.m_width > m_column.m_initialIndent );
    #####: 5919:            calcLength();
    #####: 5920:            if ( m_len == 0 ) {
    #####: 5921:                m_pos = m_column.m_string.size();
        -: 5922:            }
    #####: 5923:        }
        -: 5924:
    #####: 5925:        std::string Column::iterator::operator*() const {
    #####: 5926:            assert( m_pos <= m_end );
    #####: 5927:            return addIndentAndSuffix( m_pos, m_len );
        -: 5928:        }
        -: 5929:
    #####: 5930:        Column::iterator& Column::iterator::operator++() {
    #####: 5931:            m_pos += m_len;
    #####: 5932:            std::string const& current_line = m_column.m_string;
    #####: 5933:            if ( m_pos < current_line.size() && current_line[m_pos] == '\n' ) {
    #####: 5934:                m_pos += 1;
        -: 5935:            } else {
    #####: 5936:                while ( m_pos < current_line.size() &&
    #####: 5937:                        isWhitespace( current_line[m_pos] ) ) {
    #####: 5938:                    ++m_pos;
        -: 5939:                }
        -: 5940:            }
        -: 5941:
    #####: 5942:            if ( m_pos != current_line.size() ) {
    #####: 5943:                calcLength();
        -: 5944:            }
    #####: 5945:            return *this;
        -: 5946:        }
        -: 5947:
    #####: 5948:        Column::iterator Column::iterator::operator++( int ) {
    #####: 5949:            iterator prev( *this );
    #####: 5950:            operator++();
    #####: 5951:            return prev;
        -: 5952:        }
        -: 5953:
    #####: 5954:        std::ostream& operator<<( std::ostream& os, Column const& col ) {
        -: 5955:            bool first = true;
    #####: 5956:            for ( auto line : col ) {
    #####: 5957:                if ( first ) {
        -: 5958:                    first = false;
        -: 5959:                } else {
        -: 5960:                    os << '\n';
        -: 5961:                }
        -: 5962:                os << line;
        -: 5963:            }
    #####: 5964:            return os;
        -: 5965:        }
        -: 5966:
    #####: 5967:        Column Spacer( size_t spaceWidth ) {
    #####: 5968:            Column ret{ "" };
        -: 5969:            ret.width( spaceWidth );
    #####: 5970:            return ret;
        -: 5971:        }
        -: 5972:
    #####: 5973:        Columns::iterator::iterator( Columns const& columns, EndTag ):
    #####: 5974:            m_columns( columns.m_columns ), m_activeIterators( 0 ) {
        -: 5975:
    #####: 5976:            m_iterators.reserve( m_columns.size() );
    #####: 5977:            for ( auto const& col : m_columns ) {
    #####: 5978:                m_iterators.push_back( col.end() );
        -: 5979:            }
    #####: 5980:        }
        -: 5981:
    #####: 5982:        Columns::iterator::iterator( Columns const& columns ):
        -: 5983:            m_columns( columns.m_columns ),
    #####: 5984:            m_activeIterators( m_columns.size() ) {
        -: 5985:
    #####: 5986:            m_iterators.reserve( m_columns.size() );
    #####: 5987:            for ( auto const& col : m_columns ) {
    #####: 5988:                m_iterators.push_back( col.begin() );
        -: 5989:            }
    #####: 5990:        }
        -: 5991:
    #####: 5992:        std::string Columns::iterator::operator*() const {
        -: 5993:            std::string row, padding;
        -: 5994:
    #####: 5995:            for ( size_t i = 0; i < m_columns.size(); ++i ) {
        -: 5996:                const auto width = m_columns[i].width();
    #####: 5997:                if ( m_iterators[i] != m_columns[i].end() ) {
    #####: 5998:                    std::string col = *m_iterators[i];
        -: 5999:                    row += padding;
        -: 6000:                    row += col;
        -: 6001:
        -: 6002:                    padding.clear();
    #####: 6003:                    if ( col.size() < width ) {
    #####: 6004:                        padding.append( width - col.size(), ' ' );
        -: 6005:                    }
        -: 6006:                } else {
        -: 6007:                    padding.append( width, ' ' );
        -: 6008:                }
        -: 6009:            }
    #####: 6010:            return row;
        -: 6011:        }
        -: 6012:
    #####: 6013:        Columns::iterator& Columns::iterator::operator++() {
    #####: 6014:            for ( size_t i = 0; i < m_columns.size(); ++i ) {
    #####: 6015:                if ( m_iterators[i] != m_columns[i].end() ) {
    #####: 6016:                    ++m_iterators[i];
        -: 6017:                }
        -: 6018:            }
    #####: 6019:            return *this;
        -: 6020:        }
        -: 6021:
    #####: 6022:        Columns::iterator Columns::iterator::operator++( int ) {
        -: 6023:            iterator prev( *this );
    #####: 6024:            operator++();
    #####: 6025:            return prev;
        -: 6026:        }
        -: 6027:
    #####: 6028:        std::ostream& operator<<( std::ostream& os, Columns const& cols ) {
        -: 6029:            bool first = true;
    #####: 6030:            for ( auto line : cols ) {
    #####: 6031:                if ( first ) {
        -: 6032:                    first = false;
        -: 6033:                } else {
        -: 6034:                    os << '\n';
        -: 6035:                }
        -: 6036:                os << line;
        -: 6037:            }
    #####: 6038:            return os;
        -: 6039:        }
        -: 6040:
    #####: 6041:        Columns Column::operator+( Column const& other ) {
        -: 6042:            Columns cols;
        -: 6043:            cols += *this;
        -: 6044:            cols += other;
    #####: 6045:            return cols;
        -: 6046:        }
        -: 6047:
    #####: 6048:        Columns& Columns::operator+=( Column const& col ) {
    #####: 6049:            m_columns.push_back( col );
    #####: 6050:            return *this;
        -: 6051:        }
        -: 6052:
    #####: 6053:        Columns Columns::operator+( Column const& col ) {
        -: 6054:            Columns combined = *this;
        -: 6055:            combined += col;
    #####: 6056:            return combined;
        -: 6057:        }
        -: 6058:
        -: 6059:    } // namespace TextFlow
        -: 6060:} // namespace Catch
        -: 6061:
        -: 6062:
        -: 6063:
        -: 6064:namespace Catch {
        -: 6065:
    #####: 6066:    WildcardPattern::WildcardPattern( std::string const& pattern,
        -: 6067:                                      CaseSensitive caseSensitivity )
        -: 6068:    :   m_caseSensitivity( caseSensitivity ),
    #####: 6069:        m_pattern( normaliseString( pattern ) )
        -: 6070:    {
    #####: 6071:        if( startsWith( m_pattern, '*' ) ) {
    #####: 6072:            m_pattern = m_pattern.substr( 1 );
    #####: 6073:            m_wildcard = WildcardAtStart;
        -: 6074:        }
    #####: 6075:        if( endsWith( m_pattern, '*' ) ) {
    #####: 6076:            m_pattern = m_pattern.substr( 0, m_pattern.size()-1 );
    #####: 6077:            m_wildcard = static_cast<WildcardPosition>( m_wildcard | WildcardAtEnd );
        -: 6078:        }
    #####: 6079:    }
        -: 6080:
    #####: 6081:    bool WildcardPattern::matches( std::string const& str ) const {
    #####: 6082:        switch( m_wildcard ) {
        -: 6083:            case NoWildcard:
    #####: 6084:                return m_pattern == normaliseString( str );
        -: 6085:            case WildcardAtStart:
    #####: 6086:                return endsWith( normaliseString( str ), m_pattern );
        -: 6087:            case WildcardAtEnd:
    #####: 6088:                return startsWith( normaliseString( str ), m_pattern );
        -: 6089:            case WildcardAtBothEnds:
    #####: 6090:                return contains( normaliseString( str ), m_pattern );
        -: 6091:            default:
    #####: 6092:                CATCH_INTERNAL_ERROR( "Unknown enum" );
        -: 6093:        }
        -: 6094:    }
        -: 6095:
    #####: 6096:    std::string WildcardPattern::normaliseString( std::string const& str ) const {
    #####: 6097:        return trim( m_caseSensitivity == CaseSensitive::No ? toLower( str ) : str );
        -: 6098:    }
        -: 6099:}
        -: 6100:
        -: 6101:
        -: 6102:
        -: 6103:
        -: 6104:#include <iomanip>
        -: 6105:#include <type_traits>
        -: 6106:
        -: 6107:namespace Catch {
        -: 6108:
        -: 6109:namespace {
        -: 6110:
    #####: 6111:    size_t trailingBytes(unsigned char c) {
    #####: 6112:        if ((c & 0xE0) == 0xC0) {
        -: 6113:            return 2;
        -: 6114:        }
    #####: 6115:        if ((c & 0xF0) == 0xE0) {
        -: 6116:            return 3;
        -: 6117:        }
    #####: 6118:        if ((c & 0xF8) == 0xF0) {
        -: 6119:            return 4;
        -: 6120:        }
    #####: 6121:        CATCH_INTERNAL_ERROR("Invalid multibyte utf-8 start byte encountered");
        -: 6122:    }
        -: 6123:
    #####: 6124:    uint32_t headerValue(unsigned char c) {
    #####: 6125:        if ((c & 0xE0) == 0xC0) {
    #####: 6126:            return c & 0x1F;
        -: 6127:        }
    #####: 6128:        if ((c & 0xF0) == 0xE0) {
    #####: 6129:            return c & 0x0F;
        -: 6130:        }
    #####: 6131:        if ((c & 0xF8) == 0xF0) {
    #####: 6132:            return c & 0x07;
        -: 6133:        }
    #####: 6134:        CATCH_INTERNAL_ERROR("Invalid multibyte utf-8 start byte encountered");
        -: 6135:    }
        -: 6136:
    #####: 6137:    void hexEscapeChar(std::ostream& os, unsigned char c) {
    #####: 6138:        std::ios_base::fmtflags f(os.flags());
        -: 6139:        os << "\\x"
        -: 6140:            << std::uppercase << std::hex << std::setfill('0') << std::setw(2)
    #####: 6141:            << static_cast<int>(c);
    #####: 6142:        os.flags(f);
    #####: 6143:    }
        -: 6144:
        -: 6145:    bool shouldNewline(XmlFormatting fmt) {
    #####: 6146:        return !!(static_cast<std::underlying_type_t<XmlFormatting>>(fmt & XmlFormatting::Newline));
        -: 6147:    }
        -: 6148:
        -: 6149:    bool shouldIndent(XmlFormatting fmt) {
        -: 6150:        return !!(static_cast<std::underlying_type_t<XmlFormatting>>(fmt & XmlFormatting::Indent));
        -: 6151:    }
        -: 6152:
        -: 6153:} // anonymous namespace
        -: 6154:
    #####: 6155:    XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs) {
        -: 6156:        return static_cast<XmlFormatting>(
        -: 6157:            static_cast<std::underlying_type_t<XmlFormatting>>(lhs) |
        -: 6158:            static_cast<std::underlying_type_t<XmlFormatting>>(rhs)
    #####: 6159:        );
        -: 6160:    }
        -: 6161:
    #####: 6162:    XmlFormatting operator & (XmlFormatting lhs, XmlFormatting rhs) {
        -: 6163:        return static_cast<XmlFormatting>(
        -: 6164:            static_cast<std::underlying_type_t<XmlFormatting>>(lhs) &
        -: 6165:            static_cast<std::underlying_type_t<XmlFormatting>>(rhs)
    #####: 6166:        );
        -: 6167:    }
        -: 6168:
        -: 6169:
    #####: 6170:    XmlEncode::XmlEncode( std::string const& str, ForWhat forWhat )
        -: 6171:    :   m_str( str ),
    #####: 6172:        m_forWhat( forWhat )
    #####: 6173:    {}
        -: 6174:
    #####: 6175:    void XmlEncode::encodeTo( std::ostream& os ) const {
        -: 6176:        // Apostrophe escaping not necessary if we always use " to write attributes
        -: 6177:        // (see: http://www.w3.org/TR/xml/#syntax)
        -: 6178:
    #####: 6179:        for( std::size_t idx = 0; idx < m_str.size(); ++ idx ) {
    #####: 6180:            unsigned char c = m_str[idx];
    #####: 6181:            switch (c) {
    #####: 6182:            case '<':   os << "&lt;"; break;
    #####: 6183:            case '&':   os << "&amp;"; break;
        -: 6184:
        -: 6185:            case '>':
        -: 6186:                // See: http://www.w3.org/TR/xml/#syntax
    #####: 6187:                if (idx > 2 && m_str[idx - 1] == ']' && m_str[idx - 2] == ']')
    #####: 6188:                    os << "&gt;";
        -: 6189:                else
        -: 6190:                    os << c;
        -: 6191:                break;
        -: 6192:
        -: 6193:            case '\"':
    #####: 6194:                if (m_forWhat == ForAttributes)
    #####: 6195:                    os << "&quot;";
        -: 6196:                else
        -: 6197:                    os << c;
        -: 6198:                break;
        -: 6199:
        -: 6200:            default:
        -: 6201:                // Check for control characters and invalid utf-8
        -: 6202:
        -: 6203:                // Escape control characters in standard ascii
        -: 6204:                // see http://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0
    #####: 6205:                if (c < 0x09 || (c > 0x0D && c < 0x20) || c == 0x7F) {
    #####: 6206:                    hexEscapeChar(os, c);
    #####: 6207:                    break;
        -: 6208:                }
        -: 6209:
        -: 6210:                // Plain ASCII: Write it to stream
    #####: 6211:                if (c < 0x7F) {
        -: 6212:                    os << c;
        -: 6213:                    break;
        -: 6214:                }
        -: 6215:
        -: 6216:                // UTF-8 territory
        -: 6217:                // Check if the encoding is valid and if it is not, hex escape bytes.
        -: 6218:                // Important: We do not check the exact decoded values for validity, only the encoding format
        -: 6219:                // First check that this bytes is a valid lead byte:
        -: 6220:                // This means that it is not encoded as 1111 1XXX
        -: 6221:                // Or as 10XX XXXX
    #####: 6222:                if (c <  0xC0 ||
        -: 6223:                    c >= 0xF8) {
    #####: 6224:                    hexEscapeChar(os, c);
    #####: 6225:                    break;
        -: 6226:                }
        -: 6227:
    #####: 6228:                auto encBytes = trailingBytes(c);
        -: 6229:                // Are there enough bytes left to avoid accessing out-of-bounds memory?
    #####: 6230:                if (idx + encBytes - 1 >= m_str.size()) {
    #####: 6231:                    hexEscapeChar(os, c);
    #####: 6232:                    break;
        -: 6233:                }
        -: 6234:                // The header is valid, check data
        -: 6235:                // The next encBytes bytes must together be a valid utf-8
        -: 6236:                // This means: bitpattern 10XX XXXX and the extracted value is sane (ish)
        -: 6237:                bool valid = true;
    #####: 6238:                uint32_t value = headerValue(c);
    #####: 6239:                for (std::size_t n = 1; n < encBytes; ++n) {
    #####: 6240:                    unsigned char nc = m_str[idx + n];
    #####: 6241:                    valid &= ((nc & 0xC0) == 0x80);
    #####: 6242:                    value = (value << 6) | (nc & 0x3F);
        -: 6243:                }
        -: 6244:
    #####: 6245:                if (
        -: 6246:                    // Wrong bit pattern of following bytes
        -: 6247:                    (!valid) ||
        -: 6248:                    // Overlong encodings
    #####: 6249:                    (value < 0x80) ||
    #####: 6250:                    (0x80 <= value && value < 0x800   && encBytes > 2) ||
    #####: 6251:                    (0x800 < value && value < 0x10000 && encBytes > 3) ||
        -: 6252:                    // Encoded value out of range
        -: 6253:                    (value >= 0x110000)
        -: 6254:                    ) {
    #####: 6255:                    hexEscapeChar(os, c);
    #####: 6256:                    break;
        -: 6257:                }
        -: 6258:
        -: 6259:                // If we got here, this is in fact a valid(ish) utf-8 sequence
    #####: 6260:                for (std::size_t n = 0; n < encBytes; ++n) {
    #####: 6261:                    os << m_str[idx + n];
        -: 6262:                }
        -: 6263:                idx += encBytes - 1;
        -: 6264:                break;
        -: 6265:            }
        -: 6266:        }
    #####: 6267:    }
        -: 6268:
    #####: 6269:    std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode ) {
    #####: 6270:        xmlEncode.encodeTo( os );
    #####: 6271:        return os;
        -: 6272:    }
        -: 6273:
    #####: 6274:    XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer, XmlFormatting fmt )
        -: 6275:    :   m_writer( writer ),
    #####: 6276:        m_fmt(fmt)
    #####: 6277:    {}
        -: 6278:
    #####: 6279:    XmlWriter::ScopedElement::ScopedElement( ScopedElement&& other ) noexcept
    #####: 6280:    :   m_writer( other.m_writer ),
    #####: 6281:        m_fmt(other.m_fmt)
        -: 6282:    {
    #####: 6283:        other.m_writer = nullptr;
    #####: 6284:        other.m_fmt = XmlFormatting::None;
    #####: 6285:    }
    #####: 6286:    XmlWriter::ScopedElement& XmlWriter::ScopedElement::operator=( ScopedElement&& other ) noexcept {
    #####: 6287:        if ( m_writer ) {
    #####: 6288:            m_writer->endElement();
        -: 6289:        }
    #####: 6290:        m_writer = other.m_writer;
    #####: 6291:        other.m_writer = nullptr;
    #####: 6292:        m_fmt = other.m_fmt;
    #####: 6293:        other.m_fmt = XmlFormatting::None;
    #####: 6294:        return *this;
        -: 6295:    }
        -: 6296:
        -: 6297:
    #####: 6298:    XmlWriter::ScopedElement::~ScopedElement() {
    #####: 6299:        if (m_writer) {
    #####: 6300:            m_writer->endElement(m_fmt);
        -: 6301:        }
    #####: 6302:    }
        -: 6303:
    #####: 6304:    XmlWriter::ScopedElement& XmlWriter::ScopedElement::writeText( std::string const& text, XmlFormatting fmt ) {
    #####: 6305:        m_writer->writeText( text, fmt );
    #####: 6306:        return *this;
        -: 6307:    }
        -: 6308:
    #####: 6309:    XmlWriter::XmlWriter( std::ostream& os ) : m_os( os )
        -: 6310:    {
        -: 6311:        writeDeclaration();
    #####: 6312:    }
        -: 6313:
    #####: 6314:    XmlWriter::~XmlWriter() {
    #####: 6315:        while (!m_tags.empty()) {
    #####: 6316:            endElement();
        -: 6317:        }
        -: 6318:        newlineIfNecessary();
    #####: 6319:    }
        -: 6320:
    #####: 6321:    XmlWriter& XmlWriter::startElement( std::string const& name, XmlFormatting fmt ) {
    #####: 6322:        ensureTagClosed();
        -: 6323:        newlineIfNecessary();
    #####: 6324:        if (shouldIndent(fmt)) {
    #####: 6325:            m_os << m_indent;
    #####: 6326:            m_indent += "  ";
        -: 6327:        }
    #####: 6328:        m_os << '<' << name;
    #####: 6329:        m_tags.push_back( name );
    #####: 6330:        m_tagIsOpen = true;
        -: 6331:        applyFormatting(fmt);
    #####: 6332:        return *this;
        -: 6333:    }
        -: 6334:
    #####: 6335:    XmlWriter::ScopedElement XmlWriter::scopedElement( std::string const& name, XmlFormatting fmt ) {
        -: 6336:        ScopedElement scoped( this, fmt );
    #####: 6337:        startElement( name, fmt );
    #####: 6338:        return scoped;
        -: 6339:    }
        -: 6340:
    #####: 6341:    XmlWriter& XmlWriter::endElement(XmlFormatting fmt) {
    #####: 6342:        m_indent = m_indent.substr(0, m_indent.size() - 2);
        -: 6343:
    #####: 6344:        if( m_tagIsOpen ) {
    #####: 6345:            m_os << "/>";
    #####: 6346:            m_tagIsOpen = false;
        -: 6347:        } else {
        -: 6348:            newlineIfNecessary();
    #####: 6349:            if (shouldIndent(fmt)) {
    #####: 6350:                m_os << m_indent;
        -: 6351:            }
    #####: 6352:            m_os << "</" << m_tags.back() << ">";
        -: 6353:        }
    #####: 6354:        m_os << std::flush;
        -: 6355:        applyFormatting(fmt);
        -: 6356:        m_tags.pop_back();
    #####: 6357:        return *this;
        -: 6358:    }
        -: 6359:
    #####: 6360:    XmlWriter& XmlWriter::writeAttribute( std::string const& name, std::string const& attribute ) {
    #####: 6361:        if( !name.empty() && !attribute.empty() )
    #####: 6362:            m_os << ' ' << name << "=\"" << XmlEncode( attribute, XmlEncode::ForAttributes ) << '"';
    #####: 6363:        return *this;
        -: 6364:    }
        -: 6365:
    #####: 6366:    XmlWriter& XmlWriter::writeAttribute( std::string const& name, bool attribute ) {
    #####: 6367:        m_os << ' ' << name << "=\"" << ( attribute ? "true" : "false" ) << '"';
    #####: 6368:        return *this;
        -: 6369:    }
        -: 6370:
    #####: 6371:    XmlWriter& XmlWriter::writeText( std::string const& text, XmlFormatting fmt) {
    #####: 6372:        if( !text.empty() ){
    #####: 6373:            bool tagWasOpen = m_tagIsOpen;
    #####: 6374:            ensureTagClosed();
    #####: 6375:            if (tagWasOpen && shouldIndent(fmt)) {
    #####: 6376:                m_os << m_indent;
        -: 6377:            }
    #####: 6378:            m_os << XmlEncode( text );
        -: 6379:            applyFormatting(fmt);
        -: 6380:        }
    #####: 6381:        return *this;
        -: 6382:    }
        -: 6383:
    #####: 6384:    XmlWriter& XmlWriter::writeComment( std::string const& text, XmlFormatting fmt) {
    #####: 6385:        ensureTagClosed();
    #####: 6386:        if (shouldIndent(fmt)) {
    #####: 6387:            m_os << m_indent;
        -: 6388:        }
    #####: 6389:        m_os << "<!--" << text << "-->";
        -: 6390:        applyFormatting(fmt);
    #####: 6391:        return *this;
        -: 6392:    }
        -: 6393:
    #####: 6394:    void XmlWriter::writeStylesheetRef( std::string const& url ) {
    #####: 6395:        m_os << "<?xml-stylesheet type=\"text/xsl\" href=\"" << url << "\"?>\n";
    #####: 6396:    }
        -: 6397:
    #####: 6398:    XmlWriter& XmlWriter::writeBlankLine() {
    #####: 6399:        ensureTagClosed();
    #####: 6400:        m_os << '\n';
    #####: 6401:        return *this;
        -: 6402:    }
        -: 6403:
    #####: 6404:    void XmlWriter::ensureTagClosed() {
    #####: 6405:        if( m_tagIsOpen ) {
    #####: 6406:            m_os << '>' << std::flush;
        -: 6407:            newlineIfNecessary();
    #####: 6408:            m_tagIsOpen = false;
        -: 6409:        }
    #####: 6410:    }
        -: 6411:
    #####: 6412:    void XmlWriter::applyFormatting(XmlFormatting fmt) {
    #####: 6413:        m_needsNewline = shouldNewline(fmt);
    #####: 6414:    }
        -: 6415:
    #####: 6416:    void XmlWriter::writeDeclaration() {
    #####: 6417:        m_os << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
    #####: 6418:    }
        -: 6419:
    #####: 6420:    void XmlWriter::newlineIfNecessary() {
    #####: 6421:        if( m_needsNewline ) {
    #####: 6422:            m_os << std::endl;
    #####: 6423:            m_needsNewline = false;
        -: 6424:        }
    #####: 6425:    }
        -: 6426:}
        -: 6427:
        -: 6428:
        -: 6429:
        -: 6430:#include <algorithm>
        -: 6431:#include <cmath>
        -: 6432:#include <cstdlib>
        -: 6433:#include <cstdint>
        -: 6434:#include <cstring>
        -: 6435:#include <sstream>
        -: 6436:#include <iomanip>
        -: 6437:#include <limits>
        -: 6438:
        -: 6439:
        -: 6440:namespace Catch {
        -: 6441:namespace {
        -: 6442:
        -: 6443:    int32_t convert(float f) {
        -: 6444:        static_assert(sizeof(float) == sizeof(int32_t), "Important ULP matcher assumption violated");
        -: 6445:        int32_t i;
        -: 6446:        std::memcpy(&i, &f, sizeof(f));
        -: 6447:        return i;
        -: 6448:    }
        -: 6449:
        -: 6450:    int64_t convert(double d) {
        -: 6451:        static_assert(sizeof(double) == sizeof(int64_t), "Important ULP matcher assumption violated");
        -: 6452:        int64_t i;
        -: 6453:        std::memcpy(&i, &d, sizeof(d));
        -: 6454:        return i;
        -: 6455:    }
        -: 6456:
        -: 6457:    template <typename FP>
        -: 6458:    bool almostEqualUlps(FP lhs, FP rhs, uint64_t maxUlpDiff) {
        -: 6459:        // Comparison with NaN should always be false.
        -: 6460:        // This way we can rule it out before getting into the ugly details
    #####: 6461:        if (Catch::isnan(lhs) || Catch::isnan(rhs)) {
        -: 6462:            return false;
        -: 6463:        }
        -: 6464:
        -: 6465:        auto lc = convert(lhs);
        -: 6466:        auto rc = convert(rhs);
        -: 6467:
    #####: 6468:        if ((lc < 0) != (rc < 0)) {
        -: 6469:            // Potentially we can have +0 and -0
    #####: 6470:            return lhs == rhs;
        -: 6471:        }
        -: 6472:
    #####: 6473:        auto ulpDiff = std::abs(lc - rc);
    #####: 6474:        return static_cast<uint64_t>(ulpDiff) <= maxUlpDiff;
        -: 6475:    }
        -: 6476:
        -: 6477:#if defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
        -: 6478:
        -: 6479:    float nextafter(float x, float y) {
        -: 6480:        return ::nextafterf(x, y);
        -: 6481:    }
        -: 6482:
        -: 6483:    double nextafter(double x, double y) {
        -: 6484:        return ::nextafter(x, y);
        -: 6485:    }
        -: 6486:
        -: 6487:#endif // ^^^ CATCH_CONFIG_GLOBAL_NEXTAFTER ^^^
        -: 6488:
        -: 6489:template <typename FP>
        -: 6490:FP step(FP start, FP direction, uint64_t steps) {
    #####: 6491:    for (uint64_t i = 0; i < steps; ++i) {
        -: 6492:#if defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
        -: 6493:        start = Catch::nextafter(start, direction);
        -: 6494:#else
    #####: 6495:        start = std::nextafter(start, direction);
        -: 6496:#endif
        -: 6497:    }
        -: 6498:    return start;
        -: 6499:}
        -: 6500:
        -: 6501:// Performs equivalent check of std::fabs(lhs - rhs) <= margin
        -: 6502:// But without the subtraction to allow for INFINITY in comparison
        -: 6503:bool marginComparison(double lhs, double rhs, double margin) {
    #####: 6504:    return (lhs + margin >= rhs) && (rhs + margin >= lhs);
        -: 6505:}
        -: 6506:
        -: 6507:template <typename FloatingPoint>
    #####: 6508:void write(std::ostream& out, FloatingPoint num) {
        -: 6509:    out << std::scientific
        -: 6510:        << std::setprecision(std::numeric_limits<FloatingPoint>::max_digits10 - 1)
        -: 6511:        << num;
    #####: 6512:}
        -: 6513:
        -: 6514:} // end anonymous namespace
        -: 6515:
        -: 6516:namespace Matchers {
        -: 6517:namespace Detail {
        -: 6518:
        -: 6519:    enum class FloatingPointKind : uint8_t {
        -: 6520:        Float,
        -: 6521:        Double
        -: 6522:    };
        -: 6523:
        -: 6524:} // end namespace Detail
        -: 6525:
        -: 6526:
    #####: 6527:    WithinAbsMatcher::WithinAbsMatcher(double target, double margin)
    #####: 6528:        :m_target{ target }, m_margin{ margin } {
    #####: 6529:        CATCH_ENFORCE(margin >= 0, "Invalid margin: " << margin << '.'
        -: 6530:            << " Margin has to be non-negative.");
    #####: 6531:    }
        -: 6532:
        -: 6533:    // Performs equivalent check of std::fabs(lhs - rhs) <= margin
        -: 6534:    // But without the subtraction to allow for INFINITY in comparison
    #####: 6535:    bool WithinAbsMatcher::match(double const& matchee) const {
    #####: 6536:        return (matchee + m_margin >= m_target) && (m_target + m_margin >= matchee);
        -: 6537:    }
        -: 6538:
    #####: 6539:    std::string WithinAbsMatcher::describe() const {
    #####: 6540:        return "is within " + ::Catch::Detail::stringify(m_margin) + " of " + ::Catch::Detail::stringify(m_target);
        -: 6541:    }
        -: 6542:
        -: 6543:
    #####: 6544:    WithinUlpsMatcher::WithinUlpsMatcher(double target, uint64_t ulps, Detail::FloatingPointKind baseType)
    #####: 6545:        :m_target{ target }, m_ulps{ ulps }, m_type{ baseType } {
    #####: 6546:        CATCH_ENFORCE(m_type == Detail::FloatingPointKind::Double
        -: 6547:                   || m_ulps < (std::numeric_limits<uint32_t>::max)(),
        -: 6548:            "Provided ULP is impossibly large for a float comparison.");
    #####: 6549:    }
        -: 6550:
        -: 6551:#if defined(__clang__)
        -: 6552:#pragma clang diagnostic push
        -: 6553:// Clang <3.5 reports on the default branch in the switch below
        -: 6554:#pragma clang diagnostic ignored "-Wunreachable-code"
        -: 6555:#endif
        -: 6556:
    #####: 6557:    bool WithinUlpsMatcher::match(double const& matchee) const {
    #####: 6558:        switch (m_type) {
        -: 6559:        case Detail::FloatingPointKind::Float:
    #####: 6560:            return almostEqualUlps<float>(static_cast<float>(matchee), static_cast<float>(m_target), m_ulps);
        -: 6561:        case Detail::FloatingPointKind::Double:
    #####: 6562:            return almostEqualUlps<double>(matchee, m_target, m_ulps);
        -: 6563:        default:
    #####: 6564:            CATCH_INTERNAL_ERROR( "Unknown Detail::FloatingPointKind value" );
        -: 6565:        }
        -: 6566:    }
        -: 6567:
        -: 6568:#if defined(__clang__)
        -: 6569:#pragma clang diagnostic pop
        -: 6570:#endif
        -: 6571:
    #####: 6572:    std::string WithinUlpsMatcher::describe() const {
    #####: 6573:        std::stringstream ret;
        -: 6574:
    #####: 6575:        ret << "is within " << m_ulps << " ULPs of ";
        -: 6576:
    #####: 6577:        if (m_type == Detail::FloatingPointKind::Float) {
    #####: 6578:            write(ret, static_cast<float>(m_target));
        -: 6579:            ret << 'f';
        -: 6580:        } else {
    #####: 6581:            write(ret, m_target);
        -: 6582:        }
        -: 6583:
    #####: 6584:        ret << " ([";
    #####: 6585:        if (m_type == Detail::FloatingPointKind::Double) {
    #####: 6586:            write(ret, step(m_target, static_cast<double>(-INFINITY), m_ulps));
    #####: 6587:            ret << ", ";
    #####: 6588:            write(ret, step(m_target, static_cast<double>( INFINITY), m_ulps));
        -: 6589:        } else {
        -: 6590:            // We have to cast INFINITY to float because of MinGW, see #1782
    #####: 6591:            write(ret, step(static_cast<float>(m_target), static_cast<float>(-INFINITY), m_ulps));
    #####: 6592:            ret << ", ";
    #####: 6593:            write(ret, step(static_cast<float>(m_target), static_cast<float>( INFINITY), m_ulps));
        -: 6594:        }
    #####: 6595:        ret << "])";
        -: 6596:
    #####: 6597:        return ret.str();
        -: 6598:    }
        -: 6599:
    #####: 6600:    WithinRelMatcher::WithinRelMatcher(double target, double epsilon):
        -: 6601:        m_target(target),
    #####: 6602:        m_epsilon(epsilon){
    #####: 6603:        CATCH_ENFORCE(m_epsilon >= 0., "Relative comparison with epsilon <  0 does not make sense.");
    #####: 6604:        CATCH_ENFORCE(m_epsilon  < 1., "Relative comparison with epsilon >= 1 does not make sense.");
    #####: 6605:    }
        -: 6606:
    #####: 6607:    bool WithinRelMatcher::match(double const& matchee) const {
    #####: 6608:        const auto relMargin = m_epsilon * (std::max)(std::fabs(matchee), std::fabs(m_target));
    #####: 6609:        return marginComparison(matchee, m_target,
    #####: 6610:                                std::isinf(relMargin)? 0 : relMargin);
        -: 6611:    }
        -: 6612:
    #####: 6613:    std::string WithinRelMatcher::describe() const {
    #####: 6614:        Catch::ReusableStringStream sstr;
    #####: 6615:        sstr << "and " << m_target << " are within " << m_epsilon * 100. << "% of each other";
    #####: 6616:        return sstr.str();
        -: 6617:    }
        -: 6618:
        -: 6619:
    #####: 6620:WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff) {
    #####: 6621:    return WithinUlpsMatcher(target, maxUlpDiff, Detail::FloatingPointKind::Double);
        -: 6622:}
        -: 6623:
    #####: 6624:WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff) {
    #####: 6625:    return WithinUlpsMatcher(target, maxUlpDiff, Detail::FloatingPointKind::Float);
        -: 6626:}
        -: 6627:
    #####: 6628:WithinAbsMatcher WithinAbs(double target, double margin) {
    #####: 6629:    return WithinAbsMatcher(target, margin);
        -: 6630:}
        -: 6631:
    #####: 6632:WithinRelMatcher WithinRel(double target, double eps) {
    #####: 6633:    return WithinRelMatcher(target, eps);
        -: 6634:}
        -: 6635:
    #####: 6636:WithinRelMatcher WithinRel(double target) {
    #####: 6637:    return WithinRelMatcher(target, std::numeric_limits<double>::epsilon() * 100);
        -: 6638:}
        -: 6639:
    #####: 6640:WithinRelMatcher WithinRel(float target, float eps) {
    #####: 6641:    return WithinRelMatcher(target, eps);
        -: 6642:}
        -: 6643:
    #####: 6644:WithinRelMatcher WithinRel(float target) {
    #####: 6645:    return WithinRelMatcher(target, std::numeric_limits<float>::epsilon() * 100);
        -: 6646:}
        -: 6647:
        -: 6648:
        -: 6649:} // namespace Matchers
        -: 6650:} // namespace Catch
        -: 6651:
        -: 6652:
        -: 6653:
        -: 6654:#include <regex>
        -: 6655:
        -: 6656:namespace Catch {
        -: 6657:namespace Matchers {
        -: 6658:
    #####: 6659:    CasedString::CasedString( std::string const& str, CaseSensitive caseSensitivity )
        -: 6660:    :   m_caseSensitivity( caseSensitivity ),
    #####: 6661:        m_str( adjustString( str ) )
    #####: 6662:    {}
    #####: 6663:    std::string CasedString::adjustString( std::string const& str ) const {
    #####: 6664:        return m_caseSensitivity == CaseSensitive::No
        -: 6665:               ? toLower( str )
    #####: 6666:               : str;
        -: 6667:    }
    #####: 6668:    StringRef CasedString::caseSensitivitySuffix() const {
    #####: 6669:        return m_caseSensitivity == CaseSensitive::Yes
        -: 6670:                   ? StringRef()
    #####: 6671:                   : " (case insensitive)"_sr;
        -: 6672:    }
        -: 6673:
        -: 6674:
    #####: 6675:    StringMatcherBase::StringMatcherBase( std::string const& operation, CasedString const& comparator )
        -: 6676:    : m_comparator( comparator ),
    #####: 6677:      m_operation( operation ) {
    #####: 6678:    }
        -: 6679:
    #####: 6680:    std::string StringMatcherBase::describe() const {
        -: 6681:        std::string description;
    #####: 6682:        description.reserve(5 + m_operation.size() + m_comparator.m_str.size() +
    #####: 6683:                                    m_comparator.caseSensitivitySuffix().size());
        -: 6684:        description += m_operation;
        -: 6685:        description += ": \"";
        -: 6686:        description += m_comparator.m_str;
        -: 6687:        description += "\"";
        -: 6688:        description += m_comparator.caseSensitivitySuffix();
    #####: 6689:        return description;
        -: 6690:    }
        -: 6691:
    #####: 6692:    StringEqualsMatcher::StringEqualsMatcher( CasedString const& comparator ) : StringMatcherBase( "equals", comparator ) {}
        -: 6693:
    #####: 6694:    bool StringEqualsMatcher::match( std::string const& source ) const {
    #####: 6695:        return m_comparator.adjustString( source ) == m_comparator.m_str;
        -: 6696:    }
        -: 6697:
        -: 6698:
    #####: 6699:    StringContainsMatcher::StringContainsMatcher( CasedString const& comparator ) : StringMatcherBase( "contains", comparator ) {}
        -: 6700:
    #####: 6701:    bool StringContainsMatcher::match( std::string const& source ) const {
    #####: 6702:        return contains( m_comparator.adjustString( source ), m_comparator.m_str );
        -: 6703:    }
        -: 6704:
        -: 6705:
    #####: 6706:    StartsWithMatcher::StartsWithMatcher( CasedString const& comparator ) : StringMatcherBase( "starts with", comparator ) {}
        -: 6707:
    #####: 6708:    bool StartsWithMatcher::match( std::string const& source ) const {
    #####: 6709:        return startsWith( m_comparator.adjustString( source ), m_comparator.m_str );
        -: 6710:    }
        -: 6711:
        -: 6712:
    #####: 6713:    EndsWithMatcher::EndsWithMatcher( CasedString const& comparator ) : StringMatcherBase( "ends with", comparator ) {}
        -: 6714:
    #####: 6715:    bool EndsWithMatcher::match( std::string const& source ) const {
    #####: 6716:        return endsWith( m_comparator.adjustString( source ), m_comparator.m_str );
        -: 6717:    }
        -: 6718:
        -: 6719:
        -: 6720:
    #####: 6721:    RegexMatcher::RegexMatcher(std::string regex, CaseSensitive caseSensitivity): m_regex(std::move(regex)), m_caseSensitivity(caseSensitivity) {}
        -: 6722:
    #####: 6723:    bool RegexMatcher::match(std::string const& matchee) const {
        -: 6724:        auto flags = std::regex::ECMAScript; // ECMAScript is the default syntax option anyway
    #####: 6725:        if (m_caseSensitivity == CaseSensitive::No) {
        -: 6726:            flags |= std::regex::icase;
        -: 6727:        }
    #####: 6728:        auto reg = std::regex(m_regex, flags);
    #####: 6729:        return std::regex_match(matchee, reg);
        -: 6730:    }
        -: 6731:
    #####: 6732:    std::string RegexMatcher::describe() const {
    #####: 6733:        return "matches " + ::Catch::Detail::stringify(m_regex) + ((m_caseSensitivity == CaseSensitive::Yes)? " case sensitively" : " case insensitively");
        -: 6734:    }
        -: 6735:
        -: 6736:
    #####: 6737:    StringEqualsMatcher Equals( std::string const& str, CaseSensitive caseSensitivity ) {
    #####: 6738:        return StringEqualsMatcher( CasedString( str, caseSensitivity) );
        -: 6739:    }
    #####: 6740:    StringContainsMatcher Contains( std::string const& str, CaseSensitive caseSensitivity ) {
    #####: 6741:        return StringContainsMatcher( CasedString( str, caseSensitivity) );
        -: 6742:    }
    #####: 6743:    EndsWithMatcher EndsWith( std::string const& str, CaseSensitive caseSensitivity ) {
    #####: 6744:        return EndsWithMatcher( CasedString( str, caseSensitivity) );
        -: 6745:    }
    #####: 6746:    StartsWithMatcher StartsWith( std::string const& str, CaseSensitive caseSensitivity ) {
    #####: 6747:        return StartsWithMatcher( CasedString( str, caseSensitivity) );
        -: 6748:    }
        -: 6749:
    #####: 6750:    RegexMatcher Matches(std::string const& regex, CaseSensitive caseSensitivity) {
    #####: 6751:        return RegexMatcher(regex, caseSensitivity);
        -: 6752:    }
        -: 6753:
        -: 6754:} // namespace Matchers
        -: 6755:} // namespace Catch
        -: 6756:
        -: 6757:
        -: 6758:
        -: 6759:namespace Catch {
        -: 6760:namespace Matchers {
        -: 6761:    MatcherGenericBase::~MatcherGenericBase() = default;
        -: 6762:
        -: 6763:    namespace Detail {
        -: 6764:
    #####: 6765:        std::string describe_multi_matcher(StringRef combine, std::string const* descriptions_begin, std::string const* descriptions_end) {
        -: 6766:            std::string description;
        -: 6767:            std::size_t combined_size = 4;
    #####: 6768:            for ( auto desc = descriptions_begin; desc != descriptions_end; ++desc ) {
    #####: 6769:                combined_size += desc->size();
        -: 6770:            }
    #####: 6771:            combined_size += (descriptions_end - descriptions_begin - 1) * combine.size();
        -: 6772:
    #####: 6773:            description.reserve(combined_size);
        -: 6774:
        -: 6775:            description += "( ";
        -: 6776:            bool first = true;
    #####: 6777:            for( auto desc = descriptions_begin; desc != descriptions_end; ++desc ) {
    #####: 6778:                if( first )
        -: 6779:                    first = false;
        -: 6780:                else
        -: 6781:                    description += combine;
        -: 6782:                description += *desc;
        -: 6783:            }
        -: 6784:            description += " )";
    #####: 6785:            return description;
        -: 6786:        }
        -: 6787:
        -: 6788:    } // namespace Detail
        -: 6789:} // namespace Matchers
        -: 6790:} // namespace Catch
        -: 6791:
        -: 6792:
        -: 6793:/** \file
        -: 6794: * This is a special TU that combines what would otherwise be a very
        -: 6795: * small matcher-related TUs into one bigger TU.
        -: 6796: *
        -: 6797: * The reason for this is compilation performance improvements by
        -: 6798: * avoiding reparsing headers for many small TUs, instead having this
        -: 6799: * one TU include bit more, but having it all parsed only once.
        -: 6800: *
        -: 6801: * To avoid heavy-tail problem with compilation times, each "subpart"
        -: 6802: * of Catch2 has its own combined TU like this.
        -: 6803: */
        -: 6804:
        -: 6805://////////////////////////////////////////////
        -: 6806:// vvv formerly catch_matchers_impl.cpp vvv //
        -: 6807://////////////////////////////////////////////
        -: 6808:
        -: 6809:namespace Catch {
        -: 6810:
        -: 6811:    // This is the general overload that takes a any string matcher
        -: 6812:    // There is another overload, in catch_assertionhandler.h/.cpp, that only takes a string and infers
        -: 6813:    // the Equals matcher (so the header does not mention matchers)
    #####: 6814:    void handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher const& matcher, StringRef const& matcherString  ) {
    #####: 6815:        std::string exceptionMessage = Catch::translateActiveException();
        -: 6816:        MatchExpr<std::string, StringMatcher const&> expr( std::move(exceptionMessage), matcher, matcherString );
        -: 6817:        handler.handleExpr( expr );
    #####: 6818:    }
        -: 6819:
        -: 6820:} // namespace Catch
        -: 6821:
        -: 6822:
        -: 6823://////////////////////////////////////////////////////////////
        -: 6824:// vvv formerly catch_matchers_container_properties.cpp vvv //
        -: 6825://////////////////////////////////////////////////////////////
        -: 6826:
        -: 6827:namespace Catch {
        -: 6828:namespace Matchers {
        -: 6829:
    #####: 6830:    std::string IsEmptyMatcher::describe() const {
    #####: 6831:        return "is empty";
        -: 6832:    }
        -: 6833:
    #####: 6834:    std::string HasSizeMatcher::describe() const {
    #####: 6835:        ReusableStringStream sstr;
        -: 6836:        sstr << "has size == " << m_target_size;
    #####: 6837:        return sstr.str();
        -: 6838:    }
        -: 6839:
    #####: 6840:    IsEmptyMatcher IsEmpty() {
    #####: 6841:        return {};
        -: 6842:    }
        -: 6843:
    #####: 6844:    HasSizeMatcher SizeIs(std::size_t sz) {
    #####: 6845:        return HasSizeMatcher{ sz };
        -: 6846:    }
        -: 6847:
        -: 6848:} // end namespace Matchers
        -: 6849:} // end namespace Catch
        -: 6850:
        -: 6851:
        -: 6852:
        -: 6853://///////////////////////////////////////
        -: 6854:// vvv formerly catch_matchers.cpp vvv //
        -: 6855://///////////////////////////////////////
        -: 6856:
        -: 6857:
        -: 6858:namespace Catch {
        -: 6859:namespace Matchers {
        -: 6860:
    #####: 6861:    std::string MatcherUntypedBase::toString() const {
    #####: 6862:        if (m_cachedToString.empty()) {
    #####: 6863:            m_cachedToString = describe();
        -: 6864:        }
    #####: 6865:        return m_cachedToString;
        -: 6866:    }
        -: 6867:
        -: 6868:    MatcherUntypedBase::~MatcherUntypedBase() = default;
        -: 6869:
        -: 6870:} // namespace Matchers
        -: 6871:} // namespace Catch
        -: 6872:
        -: 6873:
        -: 6874:
        -: 6875:///////////////////////////////////////////////////
        -: 6876:// vvv formerly catch_matchers_predicate.cpp vvv //
        -: 6877:///////////////////////////////////////////////////
        -: 6878:
    #####: 6879:std::string Catch::Matchers::Detail::finalizeDescription(const std::string& desc) {
    #####: 6880:    if (desc.empty()) {
    #####: 6881:        return "matches undescribed predicate";
        -: 6882:    } else {
    #####: 6883:        return "matches predicate: \"" + desc + '"';
        -: 6884:    }
        -: 6885:}
        -: 6886:
        -: 6887:
        -: 6888:
        -: 6889:
        -: 6890:
        -: 6891:///////////////////////////////////////////////////
        -: 6892:// vvv formerly catch_matchers_exception.cpp vvv //
        -: 6893:///////////////////////////////////////////////////
        -: 6894:
        -: 6895:namespace Catch {
        -: 6896:namespace Matchers {
        -: 6897:
    #####: 6898:bool ExceptionMessageMatcher::match(std::exception const& ex) const {
    #####: 6899:    return ex.what() == m_message;
        -: 6900:}
        -: 6901:
    #####: 6902:std::string ExceptionMessageMatcher::describe() const {
    #####: 6903:    return "exception message matches \"" + m_message + "\"";
        -: 6904:}
        -: 6905:
    #####: 6906:ExceptionMessageMatcher Message(std::string const& message) {
    #####: 6907:    return ExceptionMessageMatcher(message);
        -: 6908:}
        -: 6909:
        -: 6910:} // namespace Matchers
        -: 6911:} // namespace Catch
        -: 6912:
        -: 6913:
        -: 6914:
        -: 6915:#include <ostream>
        -: 6916:
        -: 6917:namespace Catch {
        -: 6918:
    #####: 6919:    AutomakeReporter::~AutomakeReporter() {}
        -: 6920:
    #####: 6921:    void AutomakeReporter::testCaseEnded(TestCaseStats const& _testCaseStats) {
        -: 6922:        // Possible values to emit are PASS, XFAIL, SKIP, FAIL, XPASS and ERROR.
    #####: 6923:        stream << ":test-result: ";
    #####: 6924:        if (_testCaseStats.totals.assertions.allPassed()) {
    #####: 6925:            stream << "PASS";
    #####: 6926:        } else if (_testCaseStats.totals.assertions.allOk()) {
    #####: 6927:            stream << "XFAIL";
        -: 6928:        } else {
    #####: 6929:            stream << "FAIL";
        -: 6930:        }
    #####: 6931:        stream << ' ' << _testCaseStats.testInfo->name << '\n';
        -: 6932:        StreamingReporterBase::testCaseEnded(_testCaseStats);
    #####: 6933:    }
        -: 6934:
    #####: 6935:    void AutomakeReporter::skipTest(TestCaseInfo const& testInfo) {
    #####: 6936:        stream << ":test-result: SKIP " << testInfo.name << '\n';
    #####: 6937:    }
        -: 6938:
        -: 6939:} // end namespace Catch
        -: 6940:
        -: 6941:
        -: 6942:/** \file
        -: 6943: * This is a special TU that combines what would otherwise be a very
        -: 6944: * small reporter-related TUs into one bigger TU.
        -: 6945: *
        -: 6946: * The reason for this is compilation performance improvements by
        -: 6947: * avoiding reparsing headers for many small TUs, instead having this
        -: 6948: * one TU include bit more, but having it all parsed only once.
        -: 6949: *
        -: 6950: * To avoid heavy-tail problem with compilation times, each "subpart"
        -: 6951: * of Catch2 has its own combined TU like this.
        -: 6952: */
        -: 6953:
        -: 6954:
        -: 6955:#include <cfloat>
        -: 6956:#include <cstdio>
        -: 6957:#include <ostream>
        -: 6958:
        -: 6959:namespace Catch {
        -: 6960:
        -: 6961:    // Because formatting using c++ streams is stateful, drop down to C is
        -: 6962:    // required Alternatively we could use stringstream, but its performance
        -: 6963:    // is... not good.
    #####: 6964:    std::string getFormattedDuration( double duration ) {
        -: 6965:        // Max exponent + 1 is required to represent the whole part
        -: 6966:        // + 1 for decimal point
        -: 6967:        // + 3 for the 3 decimal places
        -: 6968:        // + 1 for null terminator
        -: 6969:        const std::size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;
        -: 6970:        char buffer[maxDoubleSize];
        -: 6971:
        -: 6972:        // Save previous errno, to prevent sprintf from overwriting it
        -: 6973:        ErrnoGuard guard;
        -: 6974:#ifdef _MSC_VER
        -: 6975:        sprintf_s( buffer, "%.3f", duration );
        -: 6976:#else
        -: 6977:        std::sprintf( buffer, "%.3f", duration );
        -: 6978:#endif
    #####: 6979:        return std::string( buffer );
        -: 6980:    }
        -: 6981:
        1: 6982:    bool shouldShowDuration( IConfig const& config, double duration ) {
        1: 6983:        if ( config.showDurations() == ShowDurations::Always ) {
        -: 6984:            return true;
        -: 6985:        }
        1: 6986:        if ( config.showDurations() == ShowDurations::Never ) {
        -: 6987:            return false;
        -: 6988:        }
        1: 6989:        const double min = config.minDuration();
        1: 6990:        return min >= 0 && duration >= min;
        -: 6991:    }
        -: 6992:
    #####: 6993:    std::string serializeFilters( std::vector<std::string> const& filters ) {
        -: 6994:        // We add a ' ' separator between each filter
    #####: 6995:        size_t serialized_size = filters.size() - 1;
    #####: 6996:        for (auto const& filter : filters) {
    #####: 6997:            serialized_size += filter.size();
        -: 6998:        }
        -: 6999:
        -: 7000:        std::string serialized;
    #####: 7001:        serialized.reserve(serialized_size);
        -: 7002:        bool first = true;
        -: 7003:
    #####: 7004:        for (auto const& filter : filters) {
    #####: 7005:            if (!first) {
    #####: 7006:                serialized.push_back(' ');
        -: 7007:            }
        -: 7008:            first = false;
        -: 7009:            serialized.append(filter);
        -: 7010:        }
        -: 7011:
    #####: 7012:        return serialized;
        -: 7013:    }
        -: 7014:
    #####: 7015:    std::ostream& operator<<( std::ostream& out, lineOfChars value ) {
    #####: 7016:        for ( size_t idx = 0; idx < CATCH_CONFIG_CONSOLE_WIDTH - 1; ++idx ) {
    #####: 7017:            out.put( value.c );
        -: 7018:        }
    #####: 7019:        return out;
        -: 7020:    }
        -: 7021:
        -: 7022:} // namespace Catch
        -: 7023:
        -: 7024:
        -: 7025:
        -: 7026:namespace Catch {
    #####: 7027:    void EventListenerBase::assertionStarting( AssertionInfo const& ) {}
        -: 7028:
    #####: 7029:    bool EventListenerBase::assertionEnded( AssertionStats const& ) {
    #####: 7030:        return false;
        -: 7031:    }
        -: 7032:    void
    #####: 7033:    EventListenerBase::listReporters( std::vector<ReporterDescription> const&,
    #####: 7034:                                      IConfig const& ) {}
    #####: 7035:    void EventListenerBase::listTests( std::vector<TestCaseHandle> const&,
    #####: 7036:                                       IConfig const& ) {}
    #####: 7037:    void EventListenerBase::listTags( std::vector<TagInfo> const&,
    #####: 7038:                                      IConfig const& ) {}
    #####: 7039:    void EventListenerBase::noMatchingTestCases( std::string const& ) {}
    #####: 7040:    void EventListenerBase::testRunStarting( TestRunInfo const& ) {}
    #####: 7041:    void EventListenerBase::testGroupStarting( GroupInfo const& ) {}
    #####: 7042:    void EventListenerBase::testCaseStarting( TestCaseInfo const& ) {}
    #####: 7043:    void EventListenerBase::sectionStarting( SectionInfo const& ) {}
    #####: 7044:    void EventListenerBase::sectionEnded( SectionStats const& ) {}
    #####: 7045:    void EventListenerBase::testCaseEnded( TestCaseStats const& ) {}
    #####: 7046:    void EventListenerBase::testGroupEnded( TestGroupStats const& ) {}
    #####: 7047:    void EventListenerBase::testRunEnded( TestRunStats const& ) {}
    #####: 7048:    void EventListenerBase::skipTest( TestCaseInfo const& ) {}
        -: 7049:} // namespace Catch
        -: 7050:
        -: 7051:
        -: 7052:
        -: 7053:
        -: 7054:#include <ostream>
        -: 7055:
        -: 7056:namespace {
        -: 7057:
        -: 7058:    // Colour::LightGrey
        -: 7059:    Catch::Colour::Code dimColour() { return Catch::Colour::FileName; }
        -: 7060:
        -: 7061:    Catch::StringRef bothOrAll( std::size_t count ) {
    #####: 7062:        switch (count) {
        -: 7063:        case 1:
        -: 7064:            return Catch::StringRef{};
        -: 7065:        case 2:
        -: 7066:            return "both "_catch_sr;
        -: 7067:        default:
        -: 7068:            return "all "_catch_sr;
        -: 7069:        }
        -: 7070:    }
        -: 7071:
        -: 7072:} // anon namespace
        -: 7073:
        -: 7074:
        -: 7075:namespace Catch {
        -: 7076:namespace {
        -: 7077:
        -: 7078:#ifdef CATCH_PLATFORM_MAC
        -: 7079:    static constexpr Catch::StringRef compactFailedString = "FAILED"_sr;
        -: 7080:    static constexpr Catch::StringRef compactPassedString = "PASSED"_sr;
        -: 7081:#else
        -: 7082:    static constexpr Catch::StringRef compactFailedString = "failed"_sr;
        -: 7083:    static constexpr Catch::StringRef compactPassedString = "passed"_sr;
        -: 7084:#endif
        -: 7085:
        -: 7086:// Colour, message variants:
        -: 7087:// - white: No tests ran.
        -: 7088:// -   red: Failed [both/all] N test cases, failed [both/all] M assertions.
        -: 7089:// - white: Passed [both/all] N test cases (no assertions).
        -: 7090:// -   red: Failed N tests cases, failed M assertions.
        -: 7091:// - green: Passed [both/all] N tests cases with M assertions.
    #####: 7092:void printTotals(std::ostream& out, const Totals& totals) {
    #####: 7093:    if (totals.testCases.total() == 0) {
    #####: 7094:        out << "No tests ran.";
    #####: 7095:    } else if (totals.testCases.failed == totals.testCases.total()) {
        -: 7096:        Colour colour(Colour::ResultError);
        -: 7097:        const StringRef qualify_assertions_failed =
    #####: 7098:            totals.assertions.failed == totals.assertions.total() ?
    #####: 7099:            bothOrAll(totals.assertions.failed) : StringRef{};
        -: 7100:        out <<
    #####: 7101:            "Failed " << bothOrAll(totals.testCases.failed)
    #####: 7102:            << pluralise(totals.testCases.failed, "test case") << ", "
        -: 7103:            "failed " << qualify_assertions_failed <<
    #####: 7104:            pluralise(totals.assertions.failed, "assertion") << '.';
    #####: 7105:    } else if (totals.assertions.total() == 0) {
        -: 7106:        out <<
        -: 7107:            "Passed " << bothOrAll(totals.testCases.total())
    #####: 7108:            << pluralise(totals.testCases.total(), "test case")
    #####: 7109:            << " (no assertions).";
    #####: 7110:    } else if (totals.assertions.failed) {
        -: 7111:        Colour colour(Colour::ResultError);
        -: 7112:        out <<
    #####: 7113:            "Failed " << pluralise(totals.testCases.failed, "test case") << ", "
    #####: 7114:            "failed " << pluralise(totals.assertions.failed, "assertion") << '.';
        -: 7115:    } else {
        -: 7116:        Colour colour(Colour::ResultSuccess);
        -: 7117:        out <<
    #####: 7118:            "Passed " << bothOrAll(totals.testCases.passed)
    #####: 7119:            << pluralise(totals.testCases.passed, "test case") <<
    #####: 7120:            " with " << pluralise(totals.assertions.passed, "assertion") << '.';
        -: 7121:    }
    #####: 7122:}
        -: 7123:
        -: 7124:// Implementation of CompactReporter formatting
    #####: 7125:class AssertionPrinter {
        -: 7126:public:
        -: 7127:    AssertionPrinter& operator= (AssertionPrinter const&) = delete;
        -: 7128:    AssertionPrinter(AssertionPrinter const&) = delete;
        -: 7129:    AssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)
        -: 7130:        : stream(_stream)
        -: 7131:        , result(_stats.assertionResult)
        -: 7132:        , messages(_stats.infoMessages)
        -: 7133:        , itMessage(_stats.infoMessages.begin())
    #####: 7134:        , printInfoMessages(_printInfoMessages) {}
        -: 7135:
    #####: 7136:    void print() {
    #####: 7137:        printSourceInfo();
        -: 7138:
    #####: 7139:        itMessage = messages.begin();
        -: 7140:
    #####: 7141:        switch (result.getResultType()) {
        -: 7142:        case ResultWas::Ok:
    #####: 7143:            printResultType(Colour::ResultSuccess, compactPassedString);
    #####: 7144:            printOriginalExpression();
    #####: 7145:            printReconstructedExpression();
    #####: 7146:            if (!result.hasExpression())
    #####: 7147:                printRemainingMessages(Colour::None);
        -: 7148:            else
    #####: 7149:                printRemainingMessages();
        -: 7150:            break;
        -: 7151:        case ResultWas::ExpressionFailed:
    #####: 7152:            if (result.isOk())
    #####: 7153:                printResultType(Colour::ResultSuccess, compactFailedString + " - but was ok"_sr);
        -: 7154:            else
    #####: 7155:                printResultType(Colour::Error, compactFailedString);
    #####: 7156:            printOriginalExpression();
    #####: 7157:            printReconstructedExpression();
    #####: 7158:            printRemainingMessages();
    #####: 7159:            break;
        -: 7160:        case ResultWas::ThrewException:
    #####: 7161:            printResultType(Colour::Error, compactFailedString);
    #####: 7162:            printIssue("unexpected exception with message:");
    #####: 7163:            printMessage();
    #####: 7164:            printExpressionWas();
    #####: 7165:            printRemainingMessages();
    #####: 7166:            break;
        -: 7167:        case ResultWas::FatalErrorCondition:
    #####: 7168:            printResultType(Colour::Error, compactFailedString);
    #####: 7169:            printIssue("fatal error condition with message:");
    #####: 7170:            printMessage();
    #####: 7171:            printExpressionWas();
    #####: 7172:            printRemainingMessages();
    #####: 7173:            break;
        -: 7174:        case ResultWas::DidntThrowException:
    #####: 7175:            printResultType(Colour::Error, compactFailedString);
    #####: 7176:            printIssue("expected exception, got none");
    #####: 7177:            printExpressionWas();
    #####: 7178:            printRemainingMessages();
    #####: 7179:            break;
        -: 7180:        case ResultWas::Info:
    #####: 7181:            printResultType(Colour::None, "info"_sr);
    #####: 7182:            printMessage();
    #####: 7183:            printRemainingMessages();
    #####: 7184:            break;
        -: 7185:        case ResultWas::Warning:
    #####: 7186:            printResultType(Colour::None, "warning"_sr);
    #####: 7187:            printMessage();
    #####: 7188:            printRemainingMessages();
    #####: 7189:            break;
        -: 7190:        case ResultWas::ExplicitFailure:
    #####: 7191:            printResultType(Colour::Error, compactFailedString);
    #####: 7192:            printIssue("explicitly");
    #####: 7193:            printRemainingMessages(Colour::None);
    #####: 7194:            break;
        -: 7195:            // These cases are here to prevent compiler warnings
        -: 7196:        case ResultWas::Unknown:
        -: 7197:        case ResultWas::FailureBit:
        -: 7198:        case ResultWas::Exception:
    #####: 7199:            printResultType(Colour::Error, "** internal error **");
    #####: 7200:            break;
        -: 7201:        }
    #####: 7202:    }
        -: 7203:
        -: 7204:private:
    #####: 7205:    void printSourceInfo() const {
        -: 7206:        Colour colourGuard(Colour::FileName);
    #####: 7207:        stream << result.getSourceInfo() << ':';
    #####: 7208:    }
        -: 7209:
    #####: 7210:    void printResultType(Colour::Code colour, StringRef passOrFail) const {
    #####: 7211:        if (!passOrFail.empty()) {
        -: 7212:            {
        -: 7213:                Colour colourGuard(colour);
    #####: 7214:                stream << ' ' << passOrFail;
        -: 7215:            }
    #####: 7216:            stream << ':';
        -: 7217:        }
    #####: 7218:    }
        -: 7219:
    #####: 7220:    void printIssue(char const* issue) const {
    #####: 7221:        stream << ' ' << issue;
    #####: 7222:    }
        -: 7223:
    #####: 7224:    void printExpressionWas() {
    #####: 7225:        if (result.hasExpression()) {
    #####: 7226:            stream << ';';
        -: 7227:            {
        -: 7228:                Colour colour(dimColour());
    #####: 7229:                stream << " expression was:";
        -: 7230:            }
    #####: 7231:            printOriginalExpression();
        -: 7232:        }
    #####: 7233:    }
        -: 7234:
    #####: 7235:    void printOriginalExpression() const {
    #####: 7236:        if (result.hasExpression()) {
    #####: 7237:            stream << ' ' << result.getExpression();
        -: 7238:        }
    #####: 7239:    }
        -: 7240:
    #####: 7241:    void printReconstructedExpression() const {
    #####: 7242:        if (result.hasExpandedExpression()) {
        -: 7243:            {
        -: 7244:                Colour colour(dimColour());
    #####: 7245:                stream << " for: ";
        -: 7246:            }
    #####: 7247:            stream << result.getExpandedExpression();
        -: 7248:        }
    #####: 7249:    }
        -: 7250:
    #####: 7251:    void printMessage() {
    #####: 7252:        if (itMessage != messages.end()) {
    #####: 7253:            stream << " '" << itMessage->message << '\'';
        -: 7254:            ++itMessage;
        -: 7255:        }
    #####: 7256:    }
        -: 7257:
    #####: 7258:    void printRemainingMessages(Colour::Code colour = dimColour()) {
    #####: 7259:        if (itMessage == messages.end())
        -: 7260:            return;
        -: 7261:
        -: 7262:        const auto itEnd = messages.cend();
    #####: 7263:        const auto N = static_cast<std::size_t>(std::distance(itMessage, itEnd));
        -: 7264:
        -: 7265:        {
        -: 7266:            Colour colourGuard(colour);
    #####: 7267:            stream << " with " << pluralise(N, "message") << ':';
        -: 7268:        }
        -: 7269:
    #####: 7270:        while (itMessage != itEnd) {
        -: 7271:            // If this assertion is a warning ignore any INFO messages
    #####: 7272:            if (printInfoMessages || itMessage->type != ResultWas::Info) {
    #####: 7273:                printMessage();
    #####: 7274:                if (itMessage != itEnd) {
        -: 7275:                    Colour colourGuard(dimColour());
    #####: 7276:                    stream << " and";
        -: 7277:                }
        -: 7278:                continue;
        -: 7279:            }
        -: 7280:            ++itMessage;
        -: 7281:        }
        -: 7282:    }
        -: 7283:
        -: 7284:private:
        -: 7285:    std::ostream& stream;
        -: 7286:    AssertionResult const& result;
        -: 7287:    std::vector<MessageInfo> messages;
        -: 7288:    std::vector<MessageInfo>::const_iterator itMessage;
        -: 7289:    bool printInfoMessages;
        -: 7290:};
        -: 7291:
        -: 7292:} // anon namespace
        -: 7293:
    #####: 7294:        std::string CompactReporter::getDescription() {
    #####: 7295:            return "Reports test results on a single line, suitable for IDEs";
        -: 7296:        }
        -: 7297:
    #####: 7298:        void CompactReporter::noMatchingTestCases( std::string const& spec ) {
    #####: 7299:            stream << "No test cases matched '" << spec << '\'' << std::endl;
    #####: 7300:        }
        -: 7301:
    #####: 7302:        void CompactReporter::assertionStarting( AssertionInfo const& ) {}
        -: 7303:
    #####: 7304:        bool CompactReporter::assertionEnded( AssertionStats const& _assertionStats ) {
        -: 7305:            AssertionResult const& result = _assertionStats.assertionResult;
        -: 7306:
        -: 7307:            bool printInfoMessages = true;
        -: 7308:
        -: 7309:            // Drop out if result was successful and we're not printing those
    #####: 7310:            if( !m_config->includeSuccessfulResults() && result.isOk() ) {
    #####: 7311:                if( result.getResultType() != ResultWas::Warning )
        -: 7312:                    return false;
        -: 7313:                printInfoMessages = false;
        -: 7314:            }
        -: 7315:
    #####: 7316:            AssertionPrinter printer( stream, _assertionStats, printInfoMessages );
    #####: 7317:            printer.print();
        -: 7318:
    #####: 7319:            stream << std::endl;
        -: 7320:            return true;
        -: 7321:        }
        -: 7322:
    #####: 7323:        void CompactReporter::sectionEnded(SectionStats const& _sectionStats) {
    #####: 7324:            double dur = _sectionStats.durationInSeconds;
    #####: 7325:            if ( shouldShowDuration( *m_config, dur ) ) {
    #####: 7326:                stream << getFormattedDuration( dur ) << " s: " << _sectionStats.sectionInfo.name << std::endl;
        -: 7327:            }
    #####: 7328:        }
        -: 7329:
    #####: 7330:        void CompactReporter::testRunEnded( TestRunStats const& _testRunStats ) {
    #####: 7331:            printTotals( stream, _testRunStats.totals );
    #####: 7332:            stream << '\n' << std::endl;
    #####: 7333:            StreamingReporterBase::testRunEnded( _testRunStats );
    #####: 7334:        }
        -: 7335:
    #####: 7336:        CompactReporter::~CompactReporter() {}
        -: 7337:
        -: 7338:} // end namespace Catch
        -: 7339:
        -: 7340:
        -: 7341:
        -: 7342:
        -: 7343:#include <cfloat>
        -: 7344:#include <cstdio>
        -: 7345:
        -: 7346:#if defined(_MSC_VER)
        -: 7347:#pragma warning(push)
        -: 7348:#pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch
        -: 7349: // Note that 4062 (not all labels are handled and default is missing) is enabled
        -: 7350:#endif
        -: 7351:
        -: 7352:#if defined(__clang__)
        -: 7353:#  pragma clang diagnostic push
        -: 7354:// For simplicity, benchmarking-only helpers are always enabled
        -: 7355:#  pragma clang diagnostic ignored "-Wunused-function"
        -: 7356:#endif
        -: 7357:
        -: 7358:
        -: 7359:
        -: 7360:namespace Catch {
        -: 7361:
        -: 7362:namespace {
        -: 7363:
        -: 7364:// Formatter impl for ConsoleReporter
    #####: 7365:class ConsoleAssertionPrinter {
        -: 7366:public:
        -: 7367:    ConsoleAssertionPrinter& operator= (ConsoleAssertionPrinter const&) = delete;
        -: 7368:    ConsoleAssertionPrinter(ConsoleAssertionPrinter const&) = delete;
    #####: 7369:    ConsoleAssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)
        -: 7370:        : stream(_stream),
        -: 7371:        stats(_stats),
        -: 7372:        result(_stats.assertionResult),
        -: 7373:        colour(Colour::None),
        -: 7374:        message(result.getMessage()),
        -: 7375:        messages(_stats.infoMessages),
    #####: 7376:        printInfoMessages(_printInfoMessages) {
    #####: 7377:        switch (result.getResultType()) {
        -: 7378:        case ResultWas::Ok:
    #####: 7379:            colour = Colour::Success;
    #####: 7380:            passOrFail = "PASSED";
        -: 7381:            //if( result.hasMessage() )
    #####: 7382:            if (_stats.infoMessages.size() == 1)
    #####: 7383:                messageLabel = "with message";
    #####: 7384:            if (_stats.infoMessages.size() > 1)
    #####: 7385:                messageLabel = "with messages";
        -: 7386:            break;
        -: 7387:        case ResultWas::ExpressionFailed:
    #####: 7388:            if (result.isOk()) {
    #####: 7389:                colour = Colour::Success;
    #####: 7390:                passOrFail = "FAILED - but was ok";
        -: 7391:            } else {
    #####: 7392:                colour = Colour::Error;
    #####: 7393:                passOrFail = "FAILED";
        -: 7394:            }
    #####: 7395:            if (_stats.infoMessages.size() == 1)
    #####: 7396:                messageLabel = "with message";
    #####: 7397:            if (_stats.infoMessages.size() > 1)
    #####: 7398:                messageLabel = "with messages";
        -: 7399:            break;
        -: 7400:        case ResultWas::ThrewException:
    #####: 7401:            colour = Colour::Error;
    #####: 7402:            passOrFail = "FAILED";
    #####: 7403:            messageLabel = "due to unexpected exception with ";
    #####: 7404:            if (_stats.infoMessages.size() == 1)
        -: 7405:                messageLabel += "message";
    #####: 7406:            if (_stats.infoMessages.size() > 1)
        -: 7407:                messageLabel += "messages";
        -: 7408:            break;
        -: 7409:        case ResultWas::FatalErrorCondition:
    #####: 7410:            colour = Colour::Error;
    #####: 7411:            passOrFail = "FAILED";
    #####: 7412:            messageLabel = "due to a fatal error condition";
        -: 7413:            break;
        -: 7414:        case ResultWas::DidntThrowException:
    #####: 7415:            colour = Colour::Error;
    #####: 7416:            passOrFail = "FAILED";
    #####: 7417:            messageLabel = "because no exception was thrown where one was expected";
        -: 7418:            break;
        -: 7419:        case ResultWas::Info:
    #####: 7420:            messageLabel = "info";
        -: 7421:            break;
        -: 7422:        case ResultWas::Warning:
    #####: 7423:            messageLabel = "warning";
        -: 7424:            break;
        -: 7425:        case ResultWas::ExplicitFailure:
    #####: 7426:            passOrFail = "FAILED";
    #####: 7427:            colour = Colour::Error;
    #####: 7428:            if (_stats.infoMessages.size() == 1)
    #####: 7429:                messageLabel = "explicitly with message";
    #####: 7430:            if (_stats.infoMessages.size() > 1)
    #####: 7431:                messageLabel = "explicitly with messages";
        -: 7432:            break;
        -: 7433:            // These cases are here to prevent compiler warnings
        -: 7434:        case ResultWas::Unknown:
        -: 7435:        case ResultWas::FailureBit:
        -: 7436:        case ResultWas::Exception:
    #####: 7437:            passOrFail = "** internal error **";
    #####: 7438:            colour = Colour::Error;
    #####: 7439:            break;
        -: 7440:        }
    #####: 7441:    }
        -: 7442:
    #####: 7443:    void print() const {
    #####: 7444:        printSourceInfo();
    #####: 7445:        if (stats.totals.assertions.total() > 0) {
    #####: 7446:            printResultType();
    #####: 7447:            printOriginalExpression();
    #####: 7448:            printReconstructedExpression();
        -: 7449:        } else {
    #####: 7450:            stream << '\n';
        -: 7451:        }
    #####: 7452:        printMessage();
    #####: 7453:    }
        -: 7454:
        -: 7455:private:
    #####: 7456:    void printResultType() const {
    #####: 7457:        if (!passOrFail.empty()) {
    #####: 7458:            Colour colourGuard(colour);
    #####: 7459:            stream << passOrFail << ":\n";
        -: 7460:        }
    #####: 7461:    }
    #####: 7462:    void printOriginalExpression() const {
    #####: 7463:        if (result.hasExpression()) {
        -: 7464:            Colour colourGuard(Colour::OriginalExpression);
    #####: 7465:            stream << "  ";
    #####: 7466:            stream << result.getExpressionInMacro();
    #####: 7467:            stream << '\n';
        -: 7468:        }
    #####: 7469:    }
    #####: 7470:    void printReconstructedExpression() const {
    #####: 7471:        if (result.hasExpandedExpression()) {
    #####: 7472:            stream << "with expansion:\n";
        -: 7473:            Colour colourGuard(Colour::ReconstructedExpression);
    #####: 7474:            stream << TextFlow::Column(result.getExpandedExpression()).indent(2) << '\n';
        -: 7475:        }
    #####: 7476:    }
    #####: 7477:    void printMessage() const {
    #####: 7478:        if (!messageLabel.empty())
    #####: 7479:            stream << messageLabel << ':' << '\n';
    #####: 7480:        for (auto const& msg : messages) {
        -: 7481:            // If this assertion is a warning ignore any INFO messages
    #####: 7482:            if (printInfoMessages || msg.type != ResultWas::Info)
    #####: 7483:                stream << TextFlow::Column(msg.message).indent(2) << '\n';
        -: 7484:        }
    #####: 7485:    }
    #####: 7486:    void printSourceInfo() const {
        -: 7487:        Colour colourGuard(Colour::FileName);
    #####: 7488:        stream << result.getSourceInfo() << ": ";
    #####: 7489:    }
        -: 7490:
        -: 7491:    std::ostream& stream;
        -: 7492:    AssertionStats const& stats;
        -: 7493:    AssertionResult const& result;
        -: 7494:    Colour::Code colour;
        -: 7495:    std::string passOrFail;
        -: 7496:    std::string messageLabel;
        -: 7497:    std::string message;
        -: 7498:    std::vector<MessageInfo> messages;
        -: 7499:    bool printInfoMessages;
        -: 7500:};
        -: 7501:
        -: 7502:std::size_t makeRatio(std::size_t number, std::size_t total) {
        3: 7503:    std::size_t ratio = total > 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number / total : 0;
        3: 7504:    return (ratio == 0 && number > 0) ? 1 : ratio;
        -: 7505:}
        -: 7506:
        -: 7507:std::size_t& findMax(std::size_t& i, std::size_t& j, std::size_t& k) {
        1: 7508:    if (i > j && i > k)
        -: 7509:        return i;
        1: 7510:    else if (j > k)
        -: 7511:        return j;
        -: 7512:    else
        -: 7513:        return k;
        -: 7514:}
        -: 7515:
        -: 7516:enum class Justification { Left, Right };
        -: 7517:
       16: 7518:struct ColumnInfo {
        -: 7519:    std::string name;
        -: 7520:    int width;
        -: 7521:    Justification justification;
        -: 7522:};
        -: 7523:struct ColumnBreak {};
        -: 7524:struct RowBreak {};
        -: 7525:
        -: 7526:class Duration {
        -: 7527:    enum class Unit {
        -: 7528:        Auto,
        -: 7529:        Nanoseconds,
        -: 7530:        Microseconds,
        -: 7531:        Milliseconds,
        -: 7532:        Seconds,
        -: 7533:        Minutes
        -: 7534:    };
        -: 7535:    static const uint64_t s_nanosecondsInAMicrosecond = 1000;
        -: 7536:    static const uint64_t s_nanosecondsInAMillisecond = 1000 * s_nanosecondsInAMicrosecond;
        -: 7537:    static const uint64_t s_nanosecondsInASecond = 1000 * s_nanosecondsInAMillisecond;
        -: 7538:    static const uint64_t s_nanosecondsInAMinute = 60 * s_nanosecondsInASecond;
        -: 7539:
        -: 7540:    double m_inNanoseconds;
        -: 7541:    Unit m_units;
        -: 7542:
        -: 7543:public:
        -: 7544:    explicit Duration(double inNanoseconds, Unit units = Unit::Auto)
        -: 7545:        : m_inNanoseconds(inNanoseconds),
    #####: 7546:        m_units(units) {
        -: 7547:        if (m_units == Unit::Auto) {
    #####: 7548:            if (m_inNanoseconds < s_nanosecondsInAMicrosecond)
    #####: 7549:                m_units = Unit::Nanoseconds;
    #####: 7550:            else if (m_inNanoseconds < s_nanosecondsInAMillisecond)
    #####: 7551:                m_units = Unit::Microseconds;
    #####: 7552:            else if (m_inNanoseconds < s_nanosecondsInASecond)
    #####: 7553:                m_units = Unit::Milliseconds;
    #####: 7554:            else if (m_inNanoseconds < s_nanosecondsInAMinute)
    #####: 7555:                m_units = Unit::Seconds;
        -: 7556:            else
    #####: 7557:                m_units = Unit::Minutes;
        -: 7558:        }
        -: 7559:
        -: 7560:    }
        -: 7561:
    #####: 7562:    auto value() const -> double {
    #####: 7563:        switch (m_units) {
        -: 7564:        case Unit::Microseconds:
    #####: 7565:            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMicrosecond);
        -: 7566:        case Unit::Milliseconds:
    #####: 7567:            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMillisecond);
        -: 7568:        case Unit::Seconds:
    #####: 7569:            return m_inNanoseconds / static_cast<double>(s_nanosecondsInASecond);
        -: 7570:        case Unit::Minutes:
    #####: 7571:            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMinute);
        -: 7572:        default:
    #####: 7573:            return m_inNanoseconds;
        -: 7574:        }
        -: 7575:    }
        -: 7576:    StringRef unitsAsString() const {
    #####: 7577:        switch (m_units) {
        -: 7578:        case Unit::Nanoseconds:
        -: 7579:            return "ns"_sr;
        -: 7580:        case Unit::Microseconds:
        -: 7581:            return "us"_sr;
        -: 7582:        case Unit::Milliseconds:
        -: 7583:            return "ms"_sr;
        -: 7584:        case Unit::Seconds:
        -: 7585:            return "s"_sr;
        -: 7586:        case Unit::Minutes:
        -: 7587:            return "m"_sr;
        -: 7588:        default:
        -: 7589:            return "** internal error **"_sr;
        -: 7590:        }
        -: 7591:
        -: 7592:    }
    #####: 7593:    friend auto operator << (std::ostream& os, Duration const& duration) -> std::ostream& {
    #####: 7594:        return os << duration.value() << ' ' << duration.unitsAsString();
        -: 7595:    }
        -: 7596:};
        -: 7597:} // end anon namespace
        -: 7598:
        1: 7599:class TablePrinter {
        -: 7600:    std::ostream& m_os;
        -: 7601:    std::vector<ColumnInfo> m_columnInfos;
        -: 7602:    ReusableStringStream m_oss;
        -: 7603:    int m_currentColumn = -1;
        -: 7604:    bool m_isOpen = false;
        -: 7605:
        -: 7606:public:
        1: 7607:    TablePrinter( std::ostream& os, std::vector<ColumnInfo> columnInfos )
        -: 7608:    :   m_os( os ),
        2: 7609:        m_columnInfos( std::move( columnInfos ) ) {}
        -: 7610:
        -: 7611:    auto columnInfos() const -> std::vector<ColumnInfo> const& {
        -: 7612:        return m_columnInfos;
        -: 7613:    }
        -: 7614:
    #####: 7615:    void open() {
    #####: 7616:        if (!m_isOpen) {
    #####: 7617:            m_isOpen = true;
        -: 7618:            *this << RowBreak();
        -: 7619:
        -: 7620:			TextFlow::Columns headerCols;
    #####: 7621:			auto spacer = TextFlow::Spacer(2);
    #####: 7622:			for (auto const& info : m_columnInfos) {
    #####: 7623:				headerCols += TextFlow::Column(info.name).width(static_cast<std::size_t>(info.width - 2));
        -: 7624:				headerCols += spacer;
        -: 7625:			}
    #####: 7626:			m_os << headerCols << '\n';
        -: 7627:
    #####: 7628:            m_os << lineOfChars('-') << '\n';
        -: 7629:        }
    #####: 7630:    }
        3: 7631:    void close() {
        3: 7632:        if (m_isOpen) {
        -: 7633:            *this << RowBreak();
    #####: 7634:            m_os << std::endl;
    #####: 7635:            m_isOpen = false;
        -: 7636:        }
        3: 7637:    }
        -: 7638:
        -: 7639:    template<typename T>
        -: 7640:    friend TablePrinter& operator << (TablePrinter& tp, T const& value) {
        -: 7641:        tp.m_oss << value;
        -: 7642:        return tp;
        -: 7643:    }
        -: 7644:
    #####: 7645:    friend TablePrinter& operator << (TablePrinter& tp, ColumnBreak) {
        -: 7646:        auto colStr = tp.m_oss.str();
        -: 7647:        const auto strSize = colStr.size();
    #####: 7648:        tp.m_oss.str("");
    #####: 7649:        tp.open();
    #####: 7650:        if (tp.m_currentColumn == static_cast<int>(tp.m_columnInfos.size() - 1)) {
    #####: 7651:            tp.m_currentColumn = -1;
    #####: 7652:            tp.m_os << '\n';
        -: 7653:        }
    #####: 7654:        tp.m_currentColumn++;
        -: 7655:
    #####: 7656:        auto colInfo = tp.m_columnInfos[tp.m_currentColumn];
    #####: 7657:        auto padding = (strSize + 1 < static_cast<std::size_t>(colInfo.width))
        -: 7658:            ? std::string(colInfo.width - (strSize + 1), ' ')
    #####: 7659:            : std::string();
    #####: 7660:        if (colInfo.justification == Justification::Left)
    #####: 7661:            tp.m_os << colStr << padding << ' ';
        -: 7662:        else
    #####: 7663:            tp.m_os << padding << colStr << ' ';
    #####: 7664:        return tp;
        -: 7665:    }
        -: 7666:
        -: 7667:    friend TablePrinter& operator << (TablePrinter& tp, RowBreak) {
    #####: 7668:        if (tp.m_currentColumn > 0) {
    #####: 7669:            tp.m_os << '\n';
    #####: 7670:            tp.m_currentColumn = -1;
        -: 7671:        }
        -: 7672:        return tp;
        -: 7673:    }
        -: 7674:};
        -: 7675:
        1: 7676:ConsoleReporter::ConsoleReporter(ReporterConfig const& config)
        -: 7677:    : StreamingReporterBase(config),
        -: 7678:    m_tablePrinter(new TablePrinter(config.stream(),
        1: 7679:        [&config]() -> std::vector<ColumnInfo> {
        1: 7680:        if (config.fullConfig()->benchmarkNoAnalysis())
        -: 7681:        {
        -: 7682:            return{
        -: 7683:                { "benchmark name", CATCH_CONFIG_CONSOLE_WIDTH - 43, Justification::Left },
        -: 7684:                { "     samples", 14, Justification::Right },
        -: 7685:                { "  iterations", 14, Justification::Right },
        -: 7686:                { "        mean", 14, Justification::Right }
    #####: 7687:            };
        -: 7688:        }
        -: 7689:        else
        -: 7690:        {
        -: 7691:            return{
        -: 7692:                { "benchmark name", CATCH_CONFIG_CONSOLE_WIDTH - 43, Justification::Left },
        -: 7693:                { "samples      mean       std dev", 14, Justification::Right },
        -: 7694:                { "iterations   low mean   low std dev", 14, Justification::Right },
        -: 7695:                { "estimated    high mean  high std dev", 14, Justification::Right }
        2: 7696:            };
        -: 7697:        }
        2: 7698:    }())) {}
        -: 7699:ConsoleReporter::~ConsoleReporter() = default;
        -: 7700:
    #####: 7701:std::string ConsoleReporter::getDescription() {
    #####: 7702:    return "Reports test results as plain lines of text";
        -: 7703:}
        -: 7704:
    #####: 7705:void ConsoleReporter::noMatchingTestCases(std::string const& spec) {
    #####: 7706:    stream << "No test cases matched '" << spec << '\'' << std::endl;
    #####: 7707:}
        -: 7708:
    #####: 7709:void ConsoleReporter::reportInvalidArguments(std::string const&arg){
    #####: 7710:    stream << "Invalid Filter: " << arg << std::endl;
    #####: 7711:}
        -: 7712:
        4: 7713:void ConsoleReporter::assertionStarting(AssertionInfo const&) {}
        -: 7714:
    #####: 7715:bool ConsoleReporter::assertionEnded(AssertionStats const& _assertionStats) {
        -: 7716:    AssertionResult const& result = _assertionStats.assertionResult;
        -: 7717:
    #####: 7718:    bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();
        -: 7719:
        -: 7720:    // Drop out if result was successful but we're not printing them.
    #####: 7721:    if (!includeResults && result.getResultType() != ResultWas::Warning)
        -: 7722:        return false;
        -: 7723:
    #####: 7724:    lazyPrint();
        -: 7725:
    #####: 7726:    ConsoleAssertionPrinter printer(stream, _assertionStats, includeResults);
    #####: 7727:    printer.print();
    #####: 7728:    stream << std::endl;
        -: 7729:    return true;
        -: 7730:}
        -: 7731:
        1: 7732:void ConsoleReporter::sectionStarting(SectionInfo const& _sectionInfo) {
        1: 7733:    m_tablePrinter->close();
        1: 7734:    m_headerPrinted = false;
        -: 7735:    StreamingReporterBase::sectionStarting(_sectionInfo);
        1: 7736:}
        1: 7737:void ConsoleReporter::sectionEnded(SectionStats const& _sectionStats) {
        1: 7738:    m_tablePrinter->close();
        1: 7739:    if (_sectionStats.missingAssertions) {
    #####: 7740:        lazyPrint();
        -: 7741:        Colour colour(Colour::ResultError);
    #####: 7742:        if (m_sectionStack.size() > 1)
    #####: 7743:            stream << "\nNo assertions in section";
        -: 7744:        else
    #####: 7745:            stream << "\nNo assertions in test case";
    #####: 7746:        stream << " '" << _sectionStats.sectionInfo.name << "'\n" << std::endl;
        -: 7747:    }
        1: 7748:    double dur = _sectionStats.durationInSeconds;
        1: 7749:    if (shouldShowDuration(*m_config, dur)) {
    #####: 7750:        stream << getFormattedDuration(dur) << " s: " << _sectionStats.sectionInfo.name << std::endl;
        -: 7751:    }
        1: 7752:    if (m_headerPrinted) {
    #####: 7753:        m_headerPrinted = false;
        -: 7754:    }
        -: 7755:    StreamingReporterBase::sectionEnded(_sectionStats);
        1: 7756:}
        -: 7757:
    #####: 7758:void ConsoleReporter::benchmarkPreparing(std::string const& name) {
    #####: 7759:	lazyPrintWithoutClosingBenchmarkTable();
        -: 7760:
    #####: 7761:	auto nameCol = TextFlow::Column(name).width(static_cast<std::size_t>(m_tablePrinter->columnInfos()[0].width - 2));
        -: 7762:
        -: 7763:	bool firstLine = true;
    #####: 7764:	for (auto line : nameCol) {
    #####: 7765:		if (!firstLine)
    #####: 7766:			(*m_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();
        -: 7767:		else
        -: 7768:			firstLine = false;
        -: 7769:
    #####: 7770:		(*m_tablePrinter) << line << ColumnBreak();
        -: 7771:	}
    #####: 7772:}
        -: 7773:
    #####: 7774:void ConsoleReporter::benchmarkStarting(BenchmarkInfo const& info) {
    #####: 7775:    (*m_tablePrinter) << info.samples << ColumnBreak()
    #####: 7776:        << info.iterations << ColumnBreak();
    #####: 7777:    if (!m_config->benchmarkNoAnalysis())
    #####: 7778:        (*m_tablePrinter) << Duration(info.estimatedDuration) << ColumnBreak();
    #####: 7779:}
    #####: 7780:void ConsoleReporter::benchmarkEnded(BenchmarkStats<> const& stats) {
    #####: 7781:    if (m_config->benchmarkNoAnalysis())
        -: 7782:    {
    #####: 7783:        (*m_tablePrinter) << Duration(stats.mean.point.count()) << ColumnBreak();
        -: 7784:    }
        -: 7785:    else
        -: 7786:    {
    #####: 7787:        (*m_tablePrinter) << ColumnBreak()
    #####: 7788:            << Duration(stats.mean.point.count()) << ColumnBreak()
    #####: 7789:            << Duration(stats.mean.lower_bound.count()) << ColumnBreak()
    #####: 7790:            << Duration(stats.mean.upper_bound.count()) << ColumnBreak() << ColumnBreak()
    #####: 7791:            << Duration(stats.standardDeviation.point.count()) << ColumnBreak()
    #####: 7792:            << Duration(stats.standardDeviation.lower_bound.count()) << ColumnBreak()
    #####: 7793:            << Duration(stats.standardDeviation.upper_bound.count()) << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak();
        -: 7794:    }
    #####: 7795:}
        -: 7796:
    #####: 7797:void ConsoleReporter::benchmarkFailed(std::string const& error) {
        -: 7798:	Colour colour(Colour::Red);
        -: 7799:    (*m_tablePrinter)
        -: 7800:        << "Benchmark failed (" << error << ')'
    #####: 7801:        << ColumnBreak() << RowBreak();
    #####: 7802:}
        -: 7803:
        1: 7804:void ConsoleReporter::testCaseEnded(TestCaseStats const& _testCaseStats) {
        1: 7805:    m_tablePrinter->close();
        -: 7806:    StreamingReporterBase::testCaseEnded(_testCaseStats);
        1: 7807:    m_headerPrinted = false;
        1: 7808:}
        1: 7809:void ConsoleReporter::testGroupEnded(TestGroupStats const& _testGroupStats) {
        1: 7810:    if (currentGroupInfo.used) {
    #####: 7811:        printSummaryDivider();
    #####: 7812:        stream << "Summary for group '" << _testGroupStats.groupInfo.name << "':\n";
    #####: 7813:        printTotals(_testGroupStats.totals);
    #####: 7814:        stream << '\n' << std::endl;
        -: 7815:    }
        -: 7816:    StreamingReporterBase::testGroupEnded(_testGroupStats);
        1: 7817:}
        1: 7818:void ConsoleReporter::testRunEnded(TestRunStats const& _testRunStats) {
        1: 7819:    printTotalsDivider(_testRunStats.totals);
        1: 7820:    printTotals(_testRunStats.totals);
        1: 7821:    stream << std::endl;
        1: 7822:    StreamingReporterBase::testRunEnded(_testRunStats);
        1: 7823:}
        1: 7824:void ConsoleReporter::testRunStarting(TestRunInfo const& _testInfo) {
        -: 7825:    StreamingReporterBase::testRunStarting(_testInfo);
        1: 7826:    printTestFilters();
        1: 7827:}
        -: 7828:
    #####: 7829:void ConsoleReporter::lazyPrint() {
        -: 7830:
    #####: 7831:    m_tablePrinter->close();
    #####: 7832:    lazyPrintWithoutClosingBenchmarkTable();
    #####: 7833:}
        -: 7834:
    #####: 7835:void ConsoleReporter::lazyPrintWithoutClosingBenchmarkTable() {
        -: 7836:
    #####: 7837:    if (!currentTestRunInfo.used)
    #####: 7838:        lazyPrintRunInfo();
    #####: 7839:    if (!currentGroupInfo.used)
    #####: 7840:        lazyPrintGroupInfo();
        -: 7841:
    #####: 7842:    if (!m_headerPrinted) {
    #####: 7843:        printTestCaseAndSectionHeader();
    #####: 7844:        m_headerPrinted = true;
        -: 7845:    }
    #####: 7846:}
    #####: 7847:void ConsoleReporter::lazyPrintRunInfo() {
    #####: 7848:    stream << '\n' << lineOfChars('~') << '\n';
        -: 7849:    Colour colour(Colour::SecondaryText);
    #####: 7850:    stream << currentTestRunInfo->name
    #####: 7851:        << " is a Catch v" << libraryVersion() << " host application.\n"
    #####: 7852:        << "Run with -? for options\n\n";
        -: 7853:
    #####: 7854:    if (m_config->rngSeed() != 0)
    #####: 7855:        stream << "Randomness seeded to: " << m_config->rngSeed() << "\n\n";
        -: 7856:
    #####: 7857:    currentTestRunInfo.used = true;
    #####: 7858:}
    #####: 7859:void ConsoleReporter::lazyPrintGroupInfo() {
    #####: 7860:    if (!currentGroupInfo->name.empty() && currentGroupInfo->groupsCounts > 1) {
    #####: 7861:        printClosedHeader("Group: " + currentGroupInfo->name);
    #####: 7862:        currentGroupInfo.used = true;
        -: 7863:    }
    #####: 7864:}
    #####: 7865:void ConsoleReporter::printTestCaseAndSectionHeader() {
    #####: 7866:    assert(!m_sectionStack.empty());
    #####: 7867:    printOpenHeader(currentTestCaseInfo->name);
        -: 7868:
    #####: 7869:    if (m_sectionStack.size() > 1) {
        -: 7870:        Colour colourGuard(Colour::Headers);
        -: 7871:
        -: 7872:        auto
        -: 7873:            it = m_sectionStack.begin() + 1, // Skip first section (test case)
        -: 7874:            itEnd = m_sectionStack.end();
    #####: 7875:        for (; it != itEnd; ++it)
    #####: 7876:            printHeaderString(it->name, 2);
        -: 7877:    }
        -: 7878:
    #####: 7879:    SourceLineInfo lineInfo = m_sectionStack.back().lineInfo;
        -: 7880:
        -: 7881:
    #####: 7882:    stream << lineOfChars('-') << '\n';
        -: 7883:    Colour colourGuard(Colour::FileName);
    #####: 7884:    stream << lineInfo << '\n';
    #####: 7885:    stream << lineOfChars('.') << '\n' << std::endl;
    #####: 7886:}
        -: 7887:
    #####: 7888:void ConsoleReporter::printClosedHeader(std::string const& _name) {
    #####: 7889:    printOpenHeader(_name);
    #####: 7890:    stream << lineOfChars('.') << '\n';
    #####: 7891:}
    #####: 7892:void ConsoleReporter::printOpenHeader(std::string const& _name) {
    #####: 7893:    stream << lineOfChars('-') << '\n';
        -: 7894:    {
        -: 7895:        Colour colourGuard(Colour::Headers);
    #####: 7896:        printHeaderString(_name);
        -: 7897:    }
    #####: 7898:}
        -: 7899:
        -: 7900:// if string has a : in first line will set indent to follow it on
        -: 7901:// subsequent lines
    #####: 7902:void ConsoleReporter::printHeaderString(std::string const& _string, std::size_t indent) {
        -: 7903:    std::size_t i = _string.find(": ");
    #####: 7904:    if (i != std::string::npos)
    #####: 7905:        i += 2;
        -: 7906:    else
        -: 7907:        i = 0;
    #####: 7908:    stream << TextFlow::Column(_string).indent(indent + i).initialIndent(indent) << '\n';
    #####: 7909:}
        -: 7910:
    #####: 7911:struct SummaryColumn {
        -: 7912:
        -: 7913:    SummaryColumn( std::string _label, Colour::Code _colour )
        -: 7914:    :   label( std::move( _label ) ),
    #####: 7915:        colour( _colour ) {}
    #####: 7916:    SummaryColumn addRow( std::size_t count ) {
    #####: 7917:        ReusableStringStream rss;
        -: 7918:        rss << count;
        -: 7919:        std::string row = rss.str();
    #####: 7920:        for (auto& oldRow : rows) {
    #####: 7921:            while (oldRow.size() < row.size())
    #####: 7922:                oldRow = ' ' + oldRow;
    #####: 7923:            while (oldRow.size() > row.size())
    #####: 7924:                row = ' ' + row;
        -: 7925:        }
    #####: 7926:        rows.push_back(row);
    #####: 7927:        return *this;
        -: 7928:    }
        -: 7929:
        -: 7930:    std::string label;
        -: 7931:    Colour::Code colour;
        -: 7932:    std::vector<std::string> rows;
        -: 7933:
        -: 7934:};
        -: 7935:
        1: 7936:void ConsoleReporter::printTotals( Totals const& totals ) {
        1: 7937:    if (totals.testCases.total() == 0) {
    #####: 7938:        stream << Colour(Colour::Warning) << "No tests ran\n";
        2: 7939:    } else if (totals.assertions.total() > 0 && totals.testCases.allPassed()) {
        1: 7940:        stream << Colour(Colour::ResultSuccess) << "All tests passed";
        1: 7941:        stream << " ("
        4: 7942:            << pluralise(totals.assertions.passed, "assertion") << " in "
        4: 7943:            << pluralise(totals.testCases.passed, "test case") << ')'
        -: 7944:            << '\n';
        -: 7945:    } else {
        -: 7946:
    #####: 7947:        std::vector<SummaryColumn> columns;
        -: 7948:        columns.push_back(SummaryColumn("", Colour::None)
    #####: 7949:                          .addRow(totals.testCases.total())
    #####: 7950:                          .addRow(totals.assertions.total()));
        -: 7951:        columns.push_back(SummaryColumn("passed", Colour::Success)
    #####: 7952:                          .addRow(totals.testCases.passed)
    #####: 7953:                          .addRow(totals.assertions.passed));
        -: 7954:        columns.push_back(SummaryColumn("failed", Colour::ResultError)
    #####: 7955:                          .addRow(totals.testCases.failed)
    #####: 7956:                          .addRow(totals.assertions.failed));
        -: 7957:        columns.push_back(SummaryColumn("failed as expected", Colour::ResultExpectedFailure)
    #####: 7958:                          .addRow(totals.testCases.failedButOk)
    #####: 7959:                          .addRow(totals.assertions.failedButOk));
        -: 7960:
    #####: 7961:        printSummaryRow("test cases", columns, 0);
    #####: 7962:        printSummaryRow("assertions", columns, 1);
        -: 7963:    }
        1: 7964:}
    #####: 7965:void ConsoleReporter::printSummaryRow(std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row) {
    #####: 7966:    for (auto col : cols) {
        -: 7967:        std::string value = col.rows[row];
    #####: 7968:        if (col.label.empty()) {
    #####: 7969:            stream << label << ": ";
    #####: 7970:            if (value != "0")
    #####: 7971:                stream << value;
        -: 7972:            else
    #####: 7973:                stream << Colour(Colour::Warning) << "- none -";
    #####: 7974:        } else if (value != "0") {
    #####: 7975:            stream << Colour(Colour::LightGrey) << " | ";
    #####: 7976:            stream << Colour(col.colour)
        -: 7977:                << value << ' ' << col.label;
        -: 7978:        }
        -: 7979:    }
    #####: 7980:    stream << '\n';
    #####: 7981:}
        -: 7982:
        1: 7983:void ConsoleReporter::printTotalsDivider(Totals const& totals) {
        1: 7984:    if (totals.testCases.total() > 0) {
        1: 7985:        std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());
        1: 7986:        std::size_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());
        1: 7987:        std::size_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());
        1: 7988:        while (failedRatio + failedButOkRatio + passedRatio < CATCH_CONFIG_CONSOLE_WIDTH - 1)
    #####: 7989:            findMax(failedRatio, failedButOkRatio, passedRatio)++;
        3: 7990:        while (failedRatio + failedButOkRatio + passedRatio > CATCH_CONFIG_CONSOLE_WIDTH - 1)
        1: 7991:            findMax(failedRatio, failedButOkRatio, passedRatio)--;
        -: 7992:
        2: 7993:        stream << Colour(Colour::Error) << std::string(failedRatio, '=');
        2: 7994:        stream << Colour(Colour::ResultExpectedFailure) << std::string(failedButOkRatio, '=');
        1: 7995:        if (totals.testCases.allPassed())
        2: 7996:            stream << Colour(Colour::ResultSuccess) << std::string(passedRatio, '=');
        -: 7997:        else
    #####: 7998:            stream << Colour(Colour::Success) << std::string(passedRatio, '=');
        -: 7999:    } else {
    #####: 8000:        stream << Colour(Colour::Warning) << std::string(CATCH_CONFIG_CONSOLE_WIDTH - 1, '=');
        -: 8001:    }
        1: 8002:    stream << '\n';
        1: 8003:}
    #####: 8004:void ConsoleReporter::printSummaryDivider() {
    #####: 8005:    stream << lineOfChars('-') << '\n';
    #####: 8006:}
        -: 8007:
        1: 8008:void ConsoleReporter::printTestFilters() {
        1: 8009:    if (m_config->testSpec().hasFilters()) {
        -: 8010:        Colour guard(Colour::BrightYellow);
    #####: 8011:        stream << "Filters: " << serializeFilters(m_config->getTestsOrTags()) << '\n';
        -: 8012:    }
        1: 8013:}
        -: 8014:
        -: 8015:} // end namespace Catch
        -: 8016:
        -: 8017:#if defined(_MSC_VER)
        -: 8018:#pragma warning(pop)
        -: 8019:#endif
        -: 8020:
        -: 8021:#if defined(__clang__)
        -: 8022:#  pragma clang diagnostic pop
        -: 8023:#endif
        -: 8024:
        -: 8025:
        -: 8026:
        -: 8027:#include <algorithm>
        -: 8028:#include <cassert>
        -: 8029:
        -: 8030:namespace Catch {
        -: 8031:    namespace {
        -: 8032:        struct BySectionInfo {
        -: 8033:            BySectionInfo( SectionInfo const& other ): m_other( other ) {}
        -: 8034:            BySectionInfo( BySectionInfo const& other ):
    #####: 8035:                m_other( other.m_other ) {}
    #####: 8036:            bool operator()(
        -: 8037:                std::shared_ptr<CumulativeReporterBase::SectionNode> const&
        -: 8038:                    node ) const {
        -: 8039:                return (
    #####: 8040:                    ( node->stats.sectionInfo.name == m_other.name ) &&
    #####: 8041:                    ( node->stats.sectionInfo.lineInfo == m_other.lineInfo ) );
        -: 8042:            }
        -: 8043:            void operator=( BySectionInfo const& ) = delete;
        -: 8044:
        -: 8045:        private:
        -: 8046:            SectionInfo const& m_other;
        -: 8047:        };
        -: 8048:
    #####: 8049:        void prepareExpandedExpression( AssertionResult& result ) {
    #####: 8050:            result.getExpandedExpression();
    #####: 8051:        }
        -: 8052:    } // namespace
        -: 8053:
        -: 8054:
        -: 8055:    CumulativeReporterBase::~CumulativeReporterBase() = default;
        -: 8056:
        -: 8057:    void
    #####: 8058:    CumulativeReporterBase::sectionStarting( SectionInfo const& sectionInfo ) {
        -: 8059:        SectionStats incompleteStats( sectionInfo, Counts(), 0, false );
    #####: 8060:        std::shared_ptr<SectionNode> node;
    #####: 8061:        if ( m_sectionStack.empty() ) {
    #####: 8062:            if ( !m_rootSection )
        -: 8063:                m_rootSection =
    #####: 8064:                    std::make_shared<SectionNode>( incompleteStats );
        -: 8065:            node = m_rootSection;
        -: 8066:        } else {
        -: 8067:            SectionNode& parentNode = *m_sectionStack.back();
        -: 8068:            auto it = std::find_if( parentNode.childSections.begin(),
        -: 8069:                                    parentNode.childSections.end(),
        -: 8070:                                    BySectionInfo( sectionInfo ) );
    #####: 8071:            if ( it == parentNode.childSections.end() ) {
    #####: 8072:                node = std::make_shared<SectionNode>( incompleteStats );
    #####: 8073:                parentNode.childSections.push_back( node );
        -: 8074:            } else {
        -: 8075:                node = *it;
        -: 8076:            }
        -: 8077:        }
    #####: 8078:        m_sectionStack.push_back( node );
        -: 8079:        m_deepestSection = std::move( node );
    #####: 8080:    }
        -: 8081:
    #####: 8082:    bool CumulativeReporterBase::assertionEnded(
        -: 8083:        AssertionStats const& assertionStats ) {
    #####: 8084:        assert( !m_sectionStack.empty() );
        -: 8085:        // AssertionResult holds a pointer to a temporary DecomposedExpression,
        -: 8086:        // which getExpandedExpression() calls to build the expression string.
        -: 8087:        // Our section stack copy of the assertionResult will likely outlive the
        -: 8088:        // temporary, so it must be expanded or discarded now to avoid calling
        -: 8089:        // a destroyed object later.
    #####: 8090:        prepareExpandedExpression(
    #####: 8091:            const_cast<AssertionResult&>( assertionStats.assertionResult ) );
        -: 8092:        SectionNode& sectionNode = *m_sectionStack.back();
    #####: 8093:        sectionNode.assertions.push_back( assertionStats );
    #####: 8094:        return true;
        -: 8095:    }
        -: 8096:
    #####: 8097:    void CumulativeReporterBase::sectionEnded( SectionStats const& sectionStats ) {
    #####: 8098:        assert( !m_sectionStack.empty() );
        -: 8099:        SectionNode& node = *m_sectionStack.back();
    #####: 8100:        node.stats = sectionStats;
        -: 8101:        m_sectionStack.pop_back();
    #####: 8102:    }
        -: 8103:
    #####: 8104:    void CumulativeReporterBase::testCaseEnded(
        -: 8105:        TestCaseStats const& testCaseStats ) {
        -: 8106:        auto node = std::make_shared<TestCaseNode>( testCaseStats );
    #####: 8107:        assert( m_sectionStack.size() == 0 );
    #####: 8108:        node->children.push_back( m_rootSection );
    #####: 8109:        m_testCases.push_back( node );
        -: 8110:        m_rootSection.reset();
        -: 8111:
    #####: 8112:        assert( m_deepestSection );
    #####: 8113:        m_deepestSection->stdOut = testCaseStats.stdOut;
    #####: 8114:        m_deepestSection->stdErr = testCaseStats.stdErr;
    #####: 8115:    }
        -: 8116:
    #####: 8117:    void CumulativeReporterBase::testGroupEnded(
        -: 8118:        TestGroupStats const& testGroupStats ) {
        -: 8119:        auto node = std::make_shared<TestGroupNode>( testGroupStats );
        -: 8120:        node->children.swap( m_testCases );
    #####: 8121:        m_testGroups.push_back( node );
    #####: 8122:    }
        -: 8123:
    #####: 8124:    void CumulativeReporterBase::testRunEnded( TestRunStats const& testRunStats ) {
        -: 8125:        auto node = std::make_shared<TestRunNode>( testRunStats );
        -: 8126:        node->children.swap( m_testGroups );
    #####: 8127:        m_testRuns.push_back( node );
    #####: 8128:        testRunEndedCumulative();
    #####: 8129:    }
        -: 8130:
        -: 8131:} // end namespace Catch
        -: 8132:
        -: 8133:
        -: 8134:
        -: 8135:
        -: 8136:#include <cassert>
        -: 8137:#include <ctime>
        -: 8138:#include <algorithm>
        -: 8139:
        -: 8140:namespace Catch {
        -: 8141:
        -: 8142:    namespace {
    #####: 8143:        std::string getCurrentTimestamp() {
        -: 8144:            // Beware, this is not reentrant because of backward compatibility issues
        -: 8145:            // Also, UTC only, again because of backward compatibility (%z is C++11)
        -: 8146:            time_t rawtime;
    #####: 8147:            std::time(&rawtime);
        -: 8148:            auto const timeStampSize = sizeof("2017-01-16T17:06:45Z");
        -: 8149:
        -: 8150:#ifdef _MSC_VER
        -: 8151:            std::tm timeInfo = {};
        -: 8152:            gmtime_s(&timeInfo, &rawtime);
        -: 8153:#else
        -: 8154:            std::tm* timeInfo;
    #####: 8155:            timeInfo = std::gmtime(&rawtime);
        -: 8156:#endif
        -: 8157:
        -: 8158:            char timeStamp[timeStampSize];
        -: 8159:            const char * const fmt = "%Y-%m-%dT%H:%M:%SZ";
        -: 8160:
        -: 8161:#ifdef _MSC_VER
        -: 8162:            std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);
        -: 8163:#else
    #####: 8164:            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
        -: 8165:#endif
    #####: 8166:            return std::string(timeStamp);
        -: 8167:        }
        -: 8168:
    #####: 8169:        std::string fileNameTag(std::vector<Tag> const& tags) {
        -: 8170:            auto it = std::find_if(begin(tags),
        -: 8171:                                   end(tags),
    #####: 8172:                                   [] (Tag const& tag) {
        -: 8173:                                       return tag.original.size() > 0
    #####: 8174:                                           && tag.original[0] == '#'; });
    #####: 8175:            if (it != tags.end()) {
        -: 8176:                return static_cast<std::string>(
    #####: 8177:                    it->original.substr(1, it->original.size() - 1)
        -: 8178:                );
        -: 8179:            }
        -: 8180:            return std::string();
        -: 8181:        }
        -: 8182:    } // anonymous namespace
        -: 8183:
    #####: 8184:    JunitReporter::JunitReporter( ReporterConfig const& _config )
        -: 8185:        :   CumulativeReporterBase( _config ),
    #####: 8186:            xml( _config.stream() )
        -: 8187:        {
    #####: 8188:            m_preferences.shouldRedirectStdOut = true;
    #####: 8189:            m_preferences.shouldReportAllAssertions = true;
    #####: 8190:        }
        -: 8191:
    #####: 8192:    JunitReporter::~JunitReporter() {}
        -: 8193:
    #####: 8194:    std::string JunitReporter::getDescription() {
    #####: 8195:        return "Reports test results in an XML format that looks like Ant's junitreport target";
        -: 8196:    }
        -: 8197:
    #####: 8198:    void JunitReporter::noMatchingTestCases( std::string const& /*spec*/ ) {}
        -: 8199:
    #####: 8200:    void JunitReporter::testRunStarting( TestRunInfo const& runInfo )  {
        -: 8201:        CumulativeReporterBase::testRunStarting( runInfo );
    #####: 8202:        xml.startElement( "testsuites" );
    #####: 8203:    }
        -: 8204:
    #####: 8205:    void JunitReporter::testGroupStarting( GroupInfo const& groupInfo ) {
        -: 8206:        suiteTimer.start();
        -: 8207:        stdOutForSuite.clear();
        -: 8208:        stdErrForSuite.clear();
    #####: 8209:        unexpectedExceptions = 0;
        -: 8210:        CumulativeReporterBase::testGroupStarting( groupInfo );
    #####: 8211:    }
        -: 8212:
    #####: 8213:    void JunitReporter::testCaseStarting( TestCaseInfo const& testCaseInfo ) {
    #####: 8214:        m_okToFail = testCaseInfo.okToFail();
    #####: 8215:    }
        -: 8216:
    #####: 8217:    bool JunitReporter::assertionEnded( AssertionStats const& assertionStats ) {
    #####: 8218:        if( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException && !m_okToFail )
    #####: 8219:            unexpectedExceptions++;
    #####: 8220:        return CumulativeReporterBase::assertionEnded( assertionStats );
        -: 8221:    }
        -: 8222:
    #####: 8223:    void JunitReporter::testCaseEnded( TestCaseStats const& testCaseStats ) {
    #####: 8224:        stdOutForSuite += testCaseStats.stdOut;
    #####: 8225:        stdErrForSuite += testCaseStats.stdErr;
    #####: 8226:        CumulativeReporterBase::testCaseEnded( testCaseStats );
    #####: 8227:    }
        -: 8228:
    #####: 8229:    void JunitReporter::testGroupEnded( TestGroupStats const& testGroupStats ) {
        -: 8230:        double suiteTime = suiteTimer.getElapsedSeconds();
    #####: 8231:        CumulativeReporterBase::testGroupEnded( testGroupStats );
    #####: 8232:        writeGroup( *m_testGroups.back(), suiteTime );
    #####: 8233:    }
        -: 8234:
    #####: 8235:    void JunitReporter::testRunEndedCumulative() {
    #####: 8236:        xml.endElement();
    #####: 8237:    }
        -: 8238:
    #####: 8239:    void JunitReporter::writeGroup( TestGroupNode const& groupNode, double suiteTime ) {
    #####: 8240:        XmlWriter::ScopedElement e = xml.scopedElement( "testsuite" );
        -: 8241:
        -: 8242:        TestGroupStats const& stats = groupNode.value;
    #####: 8243:        xml.writeAttribute( "name", stats.groupInfo.name );
    #####: 8244:        xml.writeAttribute( "errors", unexpectedExceptions );
    #####: 8245:        xml.writeAttribute( "failures", stats.totals.assertions.failed-unexpectedExceptions );
    #####: 8246:        xml.writeAttribute( "tests", stats.totals.assertions.total() );
    #####: 8247:        xml.writeAttribute( "hostname", "tbd" ); // !TBD
    #####: 8248:        if( m_config->showDurations() == ShowDurations::Never )
    #####: 8249:            xml.writeAttribute( "time", "" );
        -: 8250:        else
    #####: 8251:            xml.writeAttribute( "time", suiteTime );
    #####: 8252:        xml.writeAttribute( "timestamp", getCurrentTimestamp() );
        -: 8253:
        -: 8254:        // Write properties if there are any
    #####: 8255:        if (m_config->hasTestFilters() || m_config->rngSeed() != 0) {
    #####: 8256:            auto properties = xml.scopedElement("properties");
    #####: 8257:            if (m_config->hasTestFilters()) {
    #####: 8258:                xml.scopedElement("property")
    #####: 8259:                    .writeAttribute("name", "filters")
    #####: 8260:                    .writeAttribute("value", serializeFilters(m_config->getTestsOrTags()));
        -: 8261:            }
    #####: 8262:            if (m_config->rngSeed() != 0) {
    #####: 8263:                xml.scopedElement("property")
    #####: 8264:                    .writeAttribute("name", "random-seed")
    #####: 8265:                    .writeAttribute("value", m_config->rngSeed());
        -: 8266:            }
        -: 8267:        }
        -: 8268:
        -: 8269:        // Write test cases
    #####: 8270:        for( auto const& child : groupNode.children )
    #####: 8271:            writeTestCase( *child );
        -: 8272:
    #####: 8273:        xml.scopedElement( "system-out" ).writeText( trim( stdOutForSuite ), XmlFormatting::Newline );
    #####: 8274:        xml.scopedElement( "system-err" ).writeText( trim( stdErrForSuite ), XmlFormatting::Newline );
    #####: 8275:    }
        -: 8276:
    #####: 8277:    void JunitReporter::writeTestCase( TestCaseNode const& testCaseNode ) {
        -: 8278:        TestCaseStats const& stats = testCaseNode.value;
        -: 8279:
        -: 8280:        // All test cases have exactly one section - which represents the
        -: 8281:        // test case itself. That section may have 0-n nested sections
    #####: 8282:        assert( testCaseNode.children.size() == 1 );
        -: 8283:        SectionNode const& rootSection = *testCaseNode.children.front();
        -: 8284:
    #####: 8285:        std::string className = stats.testInfo->className;
        -: 8286:
    #####: 8287:        if( className.empty() ) {
    #####: 8288:            className = fileNameTag(stats.testInfo->tags);
    #####: 8289:            if ( className.empty() )
        -: 8290:                className = "global";
        -: 8291:        }
        -: 8292:
    #####: 8293:        if ( !m_config->name().empty() )
    #####: 8294:            className = m_config->name() + "." + className;
        -: 8295:
    #####: 8296:        writeSection( className, "", rootSection );
    #####: 8297:    }
        -: 8298:
    #####: 8299:    void JunitReporter::writeSection(  std::string const& className,
        -: 8300:                        std::string const& rootName,
        -: 8301:                        SectionNode const& sectionNode ) {
    #####: 8302:        std::string name = trim( sectionNode.stats.sectionInfo.name );
    #####: 8303:        if( !rootName.empty() )
    #####: 8304:            name = rootName + '/' + name;
        -: 8305:
    #####: 8306:        if( !sectionNode.assertions.empty() ||
    #####: 8307:            !sectionNode.stdOut.empty() ||
        -: 8308:            !sectionNode.stdErr.empty() ) {
    #####: 8309:            XmlWriter::ScopedElement e = xml.scopedElement( "testcase" );
    #####: 8310:            if( className.empty() ) {
    #####: 8311:                xml.writeAttribute( "classname", name );
    #####: 8312:                xml.writeAttribute( "name", "root" );
        -: 8313:            }
        -: 8314:            else {
    #####: 8315:                xml.writeAttribute( "classname", className );
    #####: 8316:                xml.writeAttribute( "name", name );
        -: 8317:            }
    #####: 8318:            xml.writeAttribute( "time", ::Catch::Detail::stringify( sectionNode.stats.durationInSeconds ) );
        -: 8319:            // This is not ideal, but it should be enough to mimic gtest's
        -: 8320:            // junit output.
        -: 8321:            // Ideally the JUnit reporter would also handle `skipTest`
        -: 8322:            // events and write those out appropriately.
    #####: 8323:            xml.writeAttribute( "status", "run" );
        -: 8324:
        -: 8325:            writeAssertions( sectionNode );
        -: 8326:
    #####: 8327:            if( !sectionNode.stdOut.empty() )
    #####: 8328:                xml.scopedElement( "system-out" ).writeText( trim( sectionNode.stdOut ), XmlFormatting::Newline );
    #####: 8329:            if( !sectionNode.stdErr.empty() )
    #####: 8330:                xml.scopedElement( "system-err" ).writeText( trim( sectionNode.stdErr ), XmlFormatting::Newline );
        -: 8331:        }
    #####: 8332:        for( auto const& childNode : sectionNode.childSections )
    #####: 8333:            if( className.empty() )
    #####: 8334:                writeSection( name, "", *childNode );
        -: 8335:            else
    #####: 8336:                writeSection( className, name, *childNode );
    #####: 8337:    }
        -: 8338:
    #####: 8339:    void JunitReporter::writeAssertions( SectionNode const& sectionNode ) {
    #####: 8340:        for( auto const& assertion : sectionNode.assertions )
    #####: 8341:            writeAssertion( assertion );
    #####: 8342:    }
        -: 8343:
    #####: 8344:    void JunitReporter::writeAssertion( AssertionStats const& stats ) {
    #####: 8345:        AssertionResult const& result = stats.assertionResult;
    #####: 8346:        if( !result.isOk() ) {
        -: 8347:            std::string elementName;
    #####: 8348:            switch( result.getResultType() ) {
        -: 8349:                case ResultWas::ThrewException:
        -: 8350:                case ResultWas::FatalErrorCondition:
        -: 8351:                    elementName = "error";
        -: 8352:                    break;
        -: 8353:                case ResultWas::ExplicitFailure:
        -: 8354:                case ResultWas::ExpressionFailed:
        -: 8355:                case ResultWas::DidntThrowException:
        -: 8356:                    elementName = "failure";
        -: 8357:                    break;
        -: 8358:
        -: 8359:                // We should never see these here:
        -: 8360:                case ResultWas::Info:
        -: 8361:                case ResultWas::Warning:
        -: 8362:                case ResultWas::Ok:
        -: 8363:                case ResultWas::Unknown:
        -: 8364:                case ResultWas::FailureBit:
        -: 8365:                case ResultWas::Exception:
        -: 8366:                    elementName = "internalError";
        -: 8367:                    break;
        -: 8368:            }
        -: 8369:
    #####: 8370:            XmlWriter::ScopedElement e = xml.scopedElement( elementName );
        -: 8371:
    #####: 8372:            xml.writeAttribute( "message", result.getExpression() );
    #####: 8373:            xml.writeAttribute( "type", result.getTestMacroName() );
        -: 8374:
    #####: 8375:            ReusableStringStream rss;
    #####: 8376:            if (stats.totals.assertions.total() > 0) {
        -: 8377:                rss << "FAILED" << ":\n";
    #####: 8378:                if (result.hasExpression()) {
        -: 8379:                    rss << "  ";
    #####: 8380:                    rss << result.getExpressionInMacro();
        -: 8381:                    rss << '\n';
        -: 8382:                }
    #####: 8383:                if (result.hasExpandedExpression()) {
        -: 8384:                    rss << "with expansion:\n";
    #####: 8385:                    rss << TextFlow::Column(result.getExpandedExpression()).indent(2) << '\n';
        -: 8386:                }
        -: 8387:            } else {
        -: 8388:                rss << '\n';
        -: 8389:            }
        -: 8390:
    #####: 8391:            if( !result.getMessage().empty() )
    #####: 8392:                rss << result.getMessage() << '\n';
    #####: 8393:            for( auto const& msg : stats.infoMessages )
    #####: 8394:                if( msg.type == ResultWas::Info )
        -: 8395:                    rss << msg.message << '\n';
        -: 8396:
    #####: 8397:            rss << "at " << result.getSourceInfo();
    #####: 8398:            xml.writeText( rss.str(), XmlFormatting::Newline );
        -: 8399:        }
    #####: 8400:    }
        -: 8401:
        -: 8402:} // end namespace Catch
        -: 8403:
        -: 8404:
        -: 8405:
        -: 8406:#include <cassert>
        -: 8407:
        -: 8408:namespace Catch {
        -: 8409:
    #####: 8410:    ListeningReporter::ListeningReporter() {
        -: 8411:        // We will assume that listeners will always want all assertions
    #####: 8412:        m_preferences.shouldReportAllAssertions = true;
    #####: 8413:    }
        -: 8414:
    #####: 8415:    void ListeningReporter::addListener( IStreamingReporterPtr&& listener ) {
    #####: 8416:        m_listeners.push_back( std::move( listener ) );
    #####: 8417:    }
        -: 8418:
    #####: 8419:    void ListeningReporter::addReporter(IStreamingReporterPtr&& reporter) {
    #####: 8420:        assert(!m_reporter && "Listening reporter can wrap only 1 real reporter");
        -: 8421:        m_reporter = std::move( reporter );
    #####: 8422:        m_preferences.shouldRedirectStdOut = m_reporter->getPreferences().shouldRedirectStdOut;
    #####: 8423:    }
        -: 8424:
    #####: 8425:    void ListeningReporter::noMatchingTestCases( std::string const& spec ) {
    #####: 8426:        for ( auto const& listener : m_listeners ) {
    #####: 8427:            listener->noMatchingTestCases( spec );
        -: 8428:        }
    #####: 8429:        m_reporter->noMatchingTestCases( spec );
    #####: 8430:    }
        -: 8431:
    #####: 8432:    void ListeningReporter::reportInvalidArguments(std::string const&arg){
    #####: 8433:        for ( auto const& listener : m_listeners ) {
    #####: 8434:            listener->reportInvalidArguments( arg );
        -: 8435:        }
    #####: 8436:        m_reporter->reportInvalidArguments( arg );
    #####: 8437:    }
        -: 8438:
    #####: 8439:    void ListeningReporter::benchmarkPreparing( std::string const& name ) {
    #####: 8440:        for (auto const& listener : m_listeners) {
    #####: 8441:            listener->benchmarkPreparing(name);
        -: 8442:        }
    #####: 8443:        m_reporter->benchmarkPreparing(name);
    #####: 8444:    }
    #####: 8445:    void ListeningReporter::benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) {
    #####: 8446:        for ( auto const& listener : m_listeners ) {
    #####: 8447:            listener->benchmarkStarting( benchmarkInfo );
        -: 8448:        }
    #####: 8449:        m_reporter->benchmarkStarting( benchmarkInfo );
    #####: 8450:    }
    #####: 8451:    void ListeningReporter::benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) {
    #####: 8452:        for ( auto const& listener : m_listeners ) {
    #####: 8453:            listener->benchmarkEnded( benchmarkStats );
        -: 8454:        }
    #####: 8455:        m_reporter->benchmarkEnded( benchmarkStats );
    #####: 8456:    }
        -: 8457:
    #####: 8458:    void ListeningReporter::benchmarkFailed( std::string const& error ) {
    #####: 8459:        for (auto const& listener : m_listeners) {
    #####: 8460:            listener->benchmarkFailed(error);
        -: 8461:        }
    #####: 8462:        m_reporter->benchmarkFailed(error);
    #####: 8463:    }
        -: 8464:
    #####: 8465:    void ListeningReporter::testRunStarting( TestRunInfo const& testRunInfo ) {
    #####: 8466:        for ( auto const& listener : m_listeners ) {
    #####: 8467:            listener->testRunStarting( testRunInfo );
        -: 8468:        }
    #####: 8469:        m_reporter->testRunStarting( testRunInfo );
    #####: 8470:    }
        -: 8471:
    #####: 8472:    void ListeningReporter::testGroupStarting( GroupInfo const& groupInfo ) {
    #####: 8473:        for ( auto const& listener : m_listeners ) {
    #####: 8474:            listener->testGroupStarting( groupInfo );
        -: 8475:        }
    #####: 8476:        m_reporter->testGroupStarting( groupInfo );
    #####: 8477:    }
        -: 8478:
        -: 8479:
    #####: 8480:    void ListeningReporter::testCaseStarting( TestCaseInfo const& testInfo ) {
    #####: 8481:        for ( auto const& listener : m_listeners ) {
    #####: 8482:            listener->testCaseStarting( testInfo );
        -: 8483:        }
    #####: 8484:        m_reporter->testCaseStarting( testInfo );
    #####: 8485:    }
        -: 8486:
    #####: 8487:    void ListeningReporter::sectionStarting( SectionInfo const& sectionInfo ) {
    #####: 8488:        for ( auto const& listener : m_listeners ) {
    #####: 8489:            listener->sectionStarting( sectionInfo );
        -: 8490:        }
    #####: 8491:        m_reporter->sectionStarting( sectionInfo );
    #####: 8492:    }
        -: 8493:
    #####: 8494:    void ListeningReporter::assertionStarting( AssertionInfo const& assertionInfo ) {
    #####: 8495:        for ( auto const& listener : m_listeners ) {
    #####: 8496:            listener->assertionStarting( assertionInfo );
        -: 8497:        }
    #####: 8498:        m_reporter->assertionStarting( assertionInfo );
    #####: 8499:    }
        -: 8500:
        -: 8501:    // The return value indicates if the messages buffer should be cleared:
    #####: 8502:    bool ListeningReporter::assertionEnded( AssertionStats const& assertionStats ) {
    #####: 8503:        for( auto const& listener : m_listeners ) {
    #####: 8504:            static_cast<void>( listener->assertionEnded( assertionStats ) );
        -: 8505:        }
    #####: 8506:        return m_reporter->assertionEnded( assertionStats );
        -: 8507:    }
        -: 8508:
    #####: 8509:    void ListeningReporter::sectionEnded( SectionStats const& sectionStats ) {
    #####: 8510:        for ( auto const& listener : m_listeners ) {
    #####: 8511:            listener->sectionEnded( sectionStats );
        -: 8512:        }
    #####: 8513:        m_reporter->sectionEnded( sectionStats );
    #####: 8514:    }
        -: 8515:
    #####: 8516:    void ListeningReporter::testCaseEnded( TestCaseStats const& testCaseStats ) {
    #####: 8517:        for ( auto const& listener : m_listeners ) {
    #####: 8518:            listener->testCaseEnded( testCaseStats );
        -: 8519:        }
    #####: 8520:        m_reporter->testCaseEnded( testCaseStats );
    #####: 8521:    }
        -: 8522:
    #####: 8523:    void ListeningReporter::testGroupEnded( TestGroupStats const& testGroupStats ) {
    #####: 8524:        for ( auto const& listener : m_listeners ) {
    #####: 8525:            listener->testGroupEnded( testGroupStats );
        -: 8526:        }
    #####: 8527:        m_reporter->testGroupEnded( testGroupStats );
    #####: 8528:    }
        -: 8529:
    #####: 8530:    void ListeningReporter::testRunEnded( TestRunStats const& testRunStats ) {
    #####: 8531:        for ( auto const& listener : m_listeners ) {
    #####: 8532:            listener->testRunEnded( testRunStats );
        -: 8533:        }
    #####: 8534:        m_reporter->testRunEnded( testRunStats );
    #####: 8535:    }
        -: 8536:
        -: 8537:
    #####: 8538:    void ListeningReporter::skipTest( TestCaseInfo const& testInfo ) {
    #####: 8539:        for ( auto const& listener : m_listeners ) {
    #####: 8540:            listener->skipTest( testInfo );
        -: 8541:        }
    #####: 8542:        m_reporter->skipTest( testInfo );
    #####: 8543:    }
        -: 8544:
    #####: 8545:    void ListeningReporter::listReporters(std::vector<ReporterDescription> const& descriptions, IConfig const& config) {
    #####: 8546:        for (auto const& listener : m_listeners) {
    #####: 8547:            listener->listReporters(descriptions, config);
        -: 8548:        }
    #####: 8549:        m_reporter->listReporters(descriptions, config);
    #####: 8550:    }
        -: 8551:
    #####: 8552:    void ListeningReporter::listTests(std::vector<TestCaseHandle> const& tests, IConfig const& config) {
    #####: 8553:        for (auto const& listener : m_listeners) {
    #####: 8554:            listener->listTests(tests, config);
        -: 8555:        }
    #####: 8556:        m_reporter->listTests(tests, config);
    #####: 8557:    }
        -: 8558:
    #####: 8559:    void ListeningReporter::listTags(std::vector<TagInfo> const& tags, IConfig const& config) {
    #####: 8560:        for (auto const& listener : m_listeners) {
    #####: 8561:            listener->listTags(tags, config);
        -: 8562:        }
    #####: 8563:        m_reporter->listTags(tags, config);
    #####: 8564:    }
        -: 8565:
        -: 8566:} // end namespace Catch
        -: 8567:
        -: 8568:
        -: 8569:
        -: 8570:
        -: 8571:#include <map>
        -: 8572:
        -: 8573:namespace Catch {
        -: 8574:
    #####: 8575:    SonarQubeReporter::~SonarQubeReporter() {}
        -: 8576:
    #####: 8577:    void SonarQubeReporter::testRunStarting(TestRunInfo const& testRunInfo) {
        -: 8578:        CumulativeReporterBase::testRunStarting(testRunInfo);
    #####: 8579:        xml.startElement("testExecutions");
    #####: 8580:        xml.writeAttribute("version", '1');
    #####: 8581:    }
        -: 8582:
    #####: 8583:    void SonarQubeReporter::testGroupEnded(TestGroupStats const& testGroupStats) {
    #####: 8584:        CumulativeReporterBase::testGroupEnded(testGroupStats);
    #####: 8585:        writeGroup(*m_testGroups.back());
    #####: 8586:    }
        -: 8587:
    #####: 8588:    void SonarQubeReporter::writeGroup(TestGroupNode const& groupNode) {
        -: 8589:        std::map<std::string, TestGroupNode::ChildNodes> testsPerFile;
    #####: 8590:        for (auto const& child : groupNode.children)
    #####: 8591:            testsPerFile[child->value.testInfo->lineInfo.file].push_back(child);
        -: 8592:
    #####: 8593:        for (auto const& kv : testsPerFile)
    #####: 8594:            writeTestFile(kv.first, kv.second);
    #####: 8595:    }
        -: 8596:
    #####: 8597:    void SonarQubeReporter::writeTestFile(std::string const& filename, TestGroupNode::ChildNodes const& testCaseNodes) {
    #####: 8598:        XmlWriter::ScopedElement e = xml.scopedElement("file");
    #####: 8599:        xml.writeAttribute("path", filename);
        -: 8600:
    #####: 8601:        for (auto const& child : testCaseNodes)
    #####: 8602:            writeTestCase(*child);
    #####: 8603:    }
        -: 8604:
    #####: 8605:    void SonarQubeReporter::writeTestCase(TestCaseNode const& testCaseNode) {
        -: 8606:        // All test cases have exactly one section - which represents the
        -: 8607:        // test case itself. That section may have 0-n nested sections
    #####: 8608:        assert(testCaseNode.children.size() == 1);
        -: 8609:        SectionNode const& rootSection = *testCaseNode.children.front();
    #####: 8610:        writeSection("", rootSection, testCaseNode.value.testInfo->okToFail());
    #####: 8611:    }
        -: 8612:
    #####: 8613:    void SonarQubeReporter::writeSection(std::string const& rootName, SectionNode const& sectionNode, bool okToFail) {
    #####: 8614:        std::string name = trim(sectionNode.stats.sectionInfo.name);
    #####: 8615:        if (!rootName.empty())
    #####: 8616:            name = rootName + '/' + name;
        -: 8617:
    #####: 8618:        if (!sectionNode.assertions.empty() || !sectionNode.stdOut.empty() || !sectionNode.stdErr.empty()) {
    #####: 8619:            XmlWriter::ScopedElement e = xml.scopedElement("testCase");
    #####: 8620:            xml.writeAttribute("name", name);
    #####: 8621:            xml.writeAttribute("duration", static_cast<long>(sectionNode.stats.durationInSeconds * 1000));
        -: 8622:
        -: 8623:            writeAssertions(sectionNode, okToFail);
        -: 8624:        }
        -: 8625:
    #####: 8626:        for (auto const& childNode : sectionNode.childSections)
    #####: 8627:            writeSection(name, *childNode, okToFail);
    #####: 8628:    }
        -: 8629:
    #####: 8630:    void SonarQubeReporter::writeAssertions(SectionNode const& sectionNode, bool okToFail) {
    #####: 8631:        for (auto const& assertion : sectionNode.assertions)
    #####: 8632:            writeAssertion(assertion, okToFail);
    #####: 8633:    }
        -: 8634:
    #####: 8635:    void SonarQubeReporter::writeAssertion(AssertionStats const& stats, bool okToFail) {
    #####: 8636:        AssertionResult const& result = stats.assertionResult;
    #####: 8637:        if (!result.isOk()) {
        -: 8638:            std::string elementName;
    #####: 8639:            if (okToFail) {
        -: 8640:                elementName = "skipped";
        -: 8641:            } else {
    #####: 8642:                switch (result.getResultType()) {
        -: 8643:                case ResultWas::ThrewException:
        -: 8644:                case ResultWas::FatalErrorCondition:
        -: 8645:                    elementName = "error";
        -: 8646:                    break;
        -: 8647:                case ResultWas::ExplicitFailure:
        -: 8648:                    elementName = "failure";
        -: 8649:                    break;
        -: 8650:                case ResultWas::ExpressionFailed:
        -: 8651:                    elementName = "failure";
        -: 8652:                    break;
        -: 8653:                case ResultWas::DidntThrowException:
        -: 8654:                    elementName = "failure";
        -: 8655:                    break;
        -: 8656:
        -: 8657:                    // We should never see these here:
        -: 8658:                case ResultWas::Info:
        -: 8659:                case ResultWas::Warning:
        -: 8660:                case ResultWas::Ok:
        -: 8661:                case ResultWas::Unknown:
        -: 8662:                case ResultWas::FailureBit:
        -: 8663:                case ResultWas::Exception:
        -: 8664:                    elementName = "internalError";
        -: 8665:                    break;
        -: 8666:                }
        -: 8667:            }
        -: 8668:
    #####: 8669:            XmlWriter::ScopedElement e = xml.scopedElement(elementName);
        -: 8670:
    #####: 8671:            ReusableStringStream messageRss;
    #####: 8672:            messageRss << result.getTestMacroName() << "(" << result.getExpression() << ")";
    #####: 8673:            xml.writeAttribute("message", messageRss.str());
        -: 8674:
    #####: 8675:            ReusableStringStream textRss;
    #####: 8676:            if (stats.totals.assertions.total() > 0) {
        -: 8677:                textRss << "FAILED:\n";
    #####: 8678:                if (result.hasExpression()) {
    #####: 8679:                    textRss << "\t" << result.getExpressionInMacro() << "\n";
        -: 8680:                }
    #####: 8681:                if (result.hasExpandedExpression()) {
    #####: 8682:                    textRss << "with expansion:\n\t" << result.getExpandedExpression() << "\n";
        -: 8683:                }
        -: 8684:            }
        -: 8685:
    #####: 8686:            if (!result.getMessage().empty())
    #####: 8687:                textRss << result.getMessage() << "\n";
        -: 8688:
    #####: 8689:            for (auto const& msg : stats.infoMessages)
    #####: 8690:                if (msg.type == ResultWas::Info)
        -: 8691:                    textRss << msg.message << "\n";
        -: 8692:
    #####: 8693:            textRss << "at " << result.getSourceInfo();
    #####: 8694:            xml.writeText(textRss.str(), XmlFormatting::Newline);
        -: 8695:        }
    #####: 8696:    }
        -: 8697:
        -: 8698:} // end namespace Catch
        -: 8699:
        -: 8700:
        -: 8701:
        -: 8702:namespace Catch {
        -: 8703:
        -: 8704:    StreamingReporterBase::~StreamingReporterBase() = default;
        -: 8705:
        -: 8706:    void
    #####: 8707:    StreamingReporterBase::testRunStarting( TestRunInfo const& _testRunInfo ) {
        -: 8708:        currentTestRunInfo = _testRunInfo;
    #####: 8709:    }
        -: 8710:
        -: 8711:    void
        1: 8712:    StreamingReporterBase::testGroupStarting( GroupInfo const& _groupInfo ) {
        -: 8713:        currentGroupInfo = _groupInfo;
        1: 8714:    }
        -: 8715:
    #####: 8716:    void StreamingReporterBase::testGroupEnded( TestGroupStats const& ) {
        -: 8717:        currentGroupInfo.reset();
    #####: 8718:    }
        -: 8719:
        1: 8720:    void StreamingReporterBase::testRunEnded( TestRunStats const& ) {
        1: 8721:        currentTestCaseInfo = nullptr;
        -: 8722:        currentGroupInfo.reset();
        -: 8723:        currentTestRunInfo.reset();
        1: 8724:    }
        -: 8725:
        -: 8726:} // end namespace Catch
        -: 8727:
        -: 8728:
        -: 8729:
        -: 8730:#include <algorithm>
        -: 8731:#include <ostream>
        -: 8732:
        -: 8733:namespace Catch {
        -: 8734:
        -: 8735:    namespace {
        -: 8736:        // Yes, this has to be outside the class and namespaced by naming.
        -: 8737:        // Making older compiler happy is hard.
        -: 8738:        static constexpr StringRef tapFailedString = "not ok"_sr;
        -: 8739:        static constexpr StringRef tapPassedString = "ok"_sr;
        -: 8740:
    #####: 8741:        class TapAssertionPrinter {
        -: 8742:        public:
        -: 8743:            TapAssertionPrinter& operator= (TapAssertionPrinter const&) = delete;
        -: 8744:            TapAssertionPrinter(TapAssertionPrinter const&) = delete;
        -: 8745:            TapAssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, std::size_t _counter)
        -: 8746:                : stream(_stream)
        -: 8747:                , result(_stats.assertionResult)
        -: 8748:                , messages(_stats.infoMessages)
        -: 8749:                , itMessage(_stats.infoMessages.begin())
        -: 8750:                , printInfoMessages(true)
    #####: 8751:                , counter(_counter) {}
        -: 8752:
    #####: 8753:            void print() {
    #####: 8754:                itMessage = messages.begin();
        -: 8755:
    #####: 8756:                switch (result.getResultType()) {
        -: 8757:                case ResultWas::Ok:
    #####: 8758:                    printResultType(tapPassedString);
    #####: 8759:                    printOriginalExpression();
    #####: 8760:                    printReconstructedExpression();
    #####: 8761:                    if (!result.hasExpression())
    #####: 8762:                        printRemainingMessages(Colour::None);
        -: 8763:                    else
    #####: 8764:                        printRemainingMessages();
        -: 8765:                    break;
        -: 8766:                case ResultWas::ExpressionFailed:
    #####: 8767:                    if (result.isOk()) {
    #####: 8768:                        printResultType(tapPassedString);
        -: 8769:                    } else {
    #####: 8770:                        printResultType(tapFailedString);
        -: 8771:                    }
    #####: 8772:                    printOriginalExpression();
    #####: 8773:                    printReconstructedExpression();
    #####: 8774:                    if (result.isOk()) {
    #####: 8775:                        printIssue(" # TODO");
        -: 8776:                    }
    #####: 8777:                    printRemainingMessages();
    #####: 8778:                    break;
        -: 8779:                case ResultWas::ThrewException:
    #####: 8780:                    printResultType(tapFailedString);
    #####: 8781:                    printIssue("unexpected exception with message:"_sr);
    #####: 8782:                    printMessage();
    #####: 8783:                    printExpressionWas();
    #####: 8784:                    printRemainingMessages();
    #####: 8785:                    break;
        -: 8786:                case ResultWas::FatalErrorCondition:
    #####: 8787:                    printResultType(tapFailedString);
    #####: 8788:                    printIssue("fatal error condition with message:"_sr);
    #####: 8789:                    printMessage();
    #####: 8790:                    printExpressionWas();
    #####: 8791:                    printRemainingMessages();
    #####: 8792:                    break;
        -: 8793:                case ResultWas::DidntThrowException:
    #####: 8794:                    printResultType(tapFailedString);
    #####: 8795:                    printIssue("expected exception, got none"_sr);
    #####: 8796:                    printExpressionWas();
    #####: 8797:                    printRemainingMessages();
    #####: 8798:                    break;
        -: 8799:                case ResultWas::Info:
    #####: 8800:                    printResultType("info"_sr);
    #####: 8801:                    printMessage();
    #####: 8802:                    printRemainingMessages();
    #####: 8803:                    break;
        -: 8804:                case ResultWas::Warning:
    #####: 8805:                    printResultType("warning"_sr);
    #####: 8806:                    printMessage();
    #####: 8807:                    printRemainingMessages();
    #####: 8808:                    break;
        -: 8809:                case ResultWas::ExplicitFailure:
    #####: 8810:                    printResultType(tapFailedString);
    #####: 8811:                    printIssue("explicitly"_sr);
    #####: 8812:                    printRemainingMessages(Colour::None);
    #####: 8813:                    break;
        -: 8814:                    // These cases are here to prevent compiler warnings
        -: 8815:                case ResultWas::Unknown:
        -: 8816:                case ResultWas::FailureBit:
        -: 8817:                case ResultWas::Exception:
    #####: 8818:                    printResultType("** internal error **"_sr);
    #####: 8819:                    break;
        -: 8820:                }
    #####: 8821:            }
        -: 8822:
        -: 8823:        private:
        -: 8824:            static Colour::Code dimColour() { return Colour::FileName; }
        -: 8825:
        -: 8826:            void printSourceInfo() const {
        -: 8827:                Colour colourGuard(dimColour());
        -: 8828:                stream << result.getSourceInfo() << ':';
        -: 8829:            }
        -: 8830:
    #####: 8831:            void printResultType(StringRef passOrFail) const {
    #####: 8832:                if (!passOrFail.empty()) {
    #####: 8833:                    stream << passOrFail << ' ' << counter << " -";
        -: 8834:                }
    #####: 8835:            }
        -: 8836:
    #####: 8837:            void printIssue(StringRef issue) const {
    #####: 8838:                stream << ' ' << issue;
    #####: 8839:            }
        -: 8840:
    #####: 8841:            void printExpressionWas() {
    #####: 8842:                if (result.hasExpression()) {
    #####: 8843:                    stream << ';';
        -: 8844:                    {
        -: 8845:                        Colour colour(dimColour());
    #####: 8846:                        stream << " expression was:";
        -: 8847:                    }
    #####: 8848:                    printOriginalExpression();
        -: 8849:                }
    #####: 8850:            }
        -: 8851:
    #####: 8852:            void printOriginalExpression() const {
    #####: 8853:                if (result.hasExpression()) {
    #####: 8854:                    stream << ' ' << result.getExpression();
        -: 8855:                }
    #####: 8856:            }
        -: 8857:
    #####: 8858:            void printReconstructedExpression() const {
    #####: 8859:                if (result.hasExpandedExpression()) {
        -: 8860:                    {
        -: 8861:                        Colour colour(dimColour());
    #####: 8862:                        stream << " for: ";
        -: 8863:                    }
    #####: 8864:                    std::string expr = result.getExpandedExpression();
        -: 8865:                    std::replace(expr.begin(), expr.end(), '\n', ' ');
    #####: 8866:                    stream << expr;
        -: 8867:                }
    #####: 8868:            }
        -: 8869:
    #####: 8870:            void printMessage() {
    #####: 8871:                if (itMessage != messages.end()) {
    #####: 8872:                    stream << " '" << itMessage->message << '\'';
        -: 8873:                    ++itMessage;
        -: 8874:                }
    #####: 8875:            }
        -: 8876:
    #####: 8877:            void printRemainingMessages(Colour::Code colour = dimColour()) {
    #####: 8878:                if (itMessage == messages.end()) {
        -: 8879:                    return;
        -: 8880:                }
        -: 8881:
        -: 8882:                // using messages.end() directly (or auto) yields compilation error:
        -: 8883:                std::vector<MessageInfo>::const_iterator itEnd = messages.end();
    #####: 8884:                const std::size_t N = static_cast<std::size_t>(std::distance(itMessage, itEnd));
        -: 8885:
        -: 8886:                {
        -: 8887:                    Colour colourGuard(colour);
    #####: 8888:                    stream << " with " << pluralise(N, "message") << ':';
        -: 8889:                }
        -: 8890:
    #####: 8891:                for (; itMessage != itEnd; ) {
        -: 8892:                    // If this assertion is a warning ignore any INFO messages
    #####: 8893:                    if (printInfoMessages || itMessage->type != ResultWas::Info) {
    #####: 8894:                        stream << " '" << itMessage->message << '\'';
    #####: 8895:                        if (++itMessage != itEnd) {
        -: 8896:                            Colour colourGuard(dimColour());
    #####: 8897:                            stream << " and";
        -: 8898:                        }
        -: 8899:                    }
        -: 8900:                }
        -: 8901:            }
        -: 8902:
        -: 8903:        private:
        -: 8904:            std::ostream& stream;
        -: 8905:            AssertionResult const& result;
        -: 8906:            std::vector<MessageInfo> messages;
        -: 8907:            std::vector<MessageInfo>::const_iterator itMessage;
        -: 8908:            bool printInfoMessages;
        -: 8909:            std::size_t counter;
        -: 8910:        };
        -: 8911:
        -: 8912:    } // End anonymous namespace
        -: 8913:
    #####: 8914:    TAPReporter::~TAPReporter() {}
        -: 8915:
    #####: 8916:    void TAPReporter::noMatchingTestCases(std::string const& spec) {
    #####: 8917:        stream << "# No test cases matched '" << spec << "'\n";
    #####: 8918:    }
        -: 8919:
    #####: 8920:    bool TAPReporter::assertionEnded(AssertionStats const& _assertionStats) {
    #####: 8921:        ++counter;
        -: 8922:
    #####: 8923:        stream << "# " << currentTestCaseInfo->name << '\n';
    #####: 8924:        TapAssertionPrinter printer(stream, _assertionStats, counter);
    #####: 8925:        printer.print();
        -: 8926:
    #####: 8927:        stream << '\n' << std::flush;
    #####: 8928:        return true;
        -: 8929:    }
        -: 8930:
    #####: 8931:    void TAPReporter::testRunEnded(TestRunStats const& _testRunStats) {
    #####: 8932:        stream << "1.." << _testRunStats.totals.assertions.total();
    #####: 8933:        if (_testRunStats.totals.testCases.total() == 0) {
    #####: 8934:            stream << " # Skipped: No tests ran.";
        -: 8935:        }
    #####: 8936:        stream << "\n\n" << std::flush;
    #####: 8937:        StreamingReporterBase::testRunEnded(_testRunStats);
    #####: 8938:    }
        -: 8939:
        -: 8940:
        -: 8941:
        -: 8942:
        -: 8943:} // end namespace Catch
        -: 8944:
        -: 8945:
        -: 8946:
        -: 8947:
        -: 8948:#include <cassert>
        -: 8949:
        -: 8950:namespace Catch {
        -: 8951:
        -: 8952:    namespace {
        -: 8953:        // if string has a : in first line will set indent to follow it on
        -: 8954:        // subsequent lines
    #####: 8955:        void printHeaderString(std::ostream& os, std::string const& _string, std::size_t indent = 0) {
        -: 8956:            std::size_t i = _string.find(": ");
    #####: 8957:            if (i != std::string::npos)
    #####: 8958:                i += 2;
        -: 8959:            else
        -: 8960:                i = 0;
        -: 8961:            os << TextFlow::Column(_string)
    #####: 8962:                  .indent(indent + i)
    #####: 8963:                  .initialIndent(indent) << '\n';
    #####: 8964:        }
        -: 8965:
    #####: 8966:        std::string escape(std::string const& str) {
        -: 8967:            std::string escaped = str;
    #####: 8968:            replaceInPlace(escaped, "|", "||");
    #####: 8969:            replaceInPlace(escaped, "'", "|'");
    #####: 8970:            replaceInPlace(escaped, "\n", "|n");
    #####: 8971:            replaceInPlace(escaped, "\r", "|r");
    #####: 8972:            replaceInPlace(escaped, "[", "|[");
    #####: 8973:            replaceInPlace(escaped, "]", "|]");
    #####: 8974:            return escaped;
        -: 8975:        }
        -: 8976:    } // end anonymous namespace
        -: 8977:
        -: 8978:
    #####: 8979:    TeamCityReporter::~TeamCityReporter() {}
        -: 8980:
    #####: 8981:    void TeamCityReporter::testGroupStarting(GroupInfo const& groupInfo) {
        -: 8982:        StreamingReporterBase::testGroupStarting(groupInfo);
    #####: 8983:        stream << "##teamcity[testSuiteStarted name='"
    #####: 8984:            << escape(groupInfo.name) << "']\n";
    #####: 8985:    }
        -: 8986:
    #####: 8987:    void TeamCityReporter::testGroupEnded(TestGroupStats const& testGroupStats) {
        -: 8988:        StreamingReporterBase::testGroupEnded(testGroupStats);
    #####: 8989:        stream << "##teamcity[testSuiteFinished name='"
    #####: 8990:            << escape(testGroupStats.groupInfo.name) << "']\n";
    #####: 8991:    }
        -: 8992:
    #####: 8993:    bool TeamCityReporter::assertionEnded(AssertionStats const& assertionStats) {
    #####: 8994:        AssertionResult const& result = assertionStats.assertionResult;
    #####: 8995:        if (!result.isOk()) {
        -: 8996:
    #####: 8997:            ReusableStringStream msg;
    #####: 8998:            if (!m_headerPrintedForThisSection)
    #####: 8999:                printSectionHeader(msg.get());
    #####: 9000:            m_headerPrintedForThisSection = true;
        -: 9001:
    #####: 9002:            msg << result.getSourceInfo() << '\n';
        -: 9003:
    #####: 9004:            switch (result.getResultType()) {
        -: 9005:            case ResultWas::ExpressionFailed:
        -: 9006:                msg << "expression failed";
        -: 9007:                break;
        -: 9008:            case ResultWas::ThrewException:
        -: 9009:                msg << "unexpected exception";
        -: 9010:                break;
        -: 9011:            case ResultWas::FatalErrorCondition:
        -: 9012:                msg << "fatal error condition";
        -: 9013:                break;
        -: 9014:            case ResultWas::DidntThrowException:
        -: 9015:                msg << "no exception was thrown where one was expected";
        -: 9016:                break;
        -: 9017:            case ResultWas::ExplicitFailure:
        -: 9018:                msg << "explicit failure";
        -: 9019:                break;
        -: 9020:
        -: 9021:                // We shouldn't get here because of the isOk() test
        -: 9022:            case ResultWas::Ok:
        -: 9023:            case ResultWas::Info:
        -: 9024:            case ResultWas::Warning:
    #####: 9025:                CATCH_ERROR("Internal error in TeamCity reporter");
        -: 9026:                // These cases are here to prevent compiler warnings
        -: 9027:            case ResultWas::Unknown:
        -: 9028:            case ResultWas::FailureBit:
        -: 9029:            case ResultWas::Exception:
    #####: 9030:                CATCH_ERROR("Not implemented");
        -: 9031:            }
    #####: 9032:            if (assertionStats.infoMessages.size() == 1)
        -: 9033:                msg << " with message:";
    #####: 9034:            if (assertionStats.infoMessages.size() > 1)
        -: 9035:                msg << " with messages:";
    #####: 9036:            for (auto const& messageInfo : assertionStats.infoMessages)
        -: 9037:                msg << "\n  \"" << messageInfo.message << '"';
        -: 9038:
        -: 9039:
    #####: 9040:            if (result.hasExpression()) {
        -: 9041:                msg <<
    #####: 9042:                    "\n  " << result.getExpressionInMacro() << "\n"
        -: 9043:                    "with expansion:\n"
    #####: 9044:                    "  " << result.getExpandedExpression() << '\n';
        -: 9045:            }
        -: 9046:
    #####: 9047:            if (currentTestCaseInfo->okToFail()) {
        -: 9048:                msg << "- failure ignore as test marked as 'ok to fail'\n";
    #####: 9049:                stream << "##teamcity[testIgnored"
    #####: 9050:                    << " name='" << escape(currentTestCaseInfo->name) << '\''
    #####: 9051:                    << " message='" << escape(msg.str()) << '\''
    #####: 9052:                    << "]\n";
        -: 9053:            } else {
    #####: 9054:                stream << "##teamcity[testFailed"
    #####: 9055:                    << " name='" << escape(currentTestCaseInfo->name) << '\''
    #####: 9056:                    << " message='" << escape(msg.str()) << '\''
    #####: 9057:                    << "]\n";
        -: 9058:            }
        -: 9059:        }
    #####: 9060:        stream.flush();
    #####: 9061:        return true;
        -: 9062:    }
        -: 9063:
    #####: 9064:    void TeamCityReporter::testCaseStarting(TestCaseInfo const& testInfo) {
        -: 9065:        m_testTimer.start();
        -: 9066:        StreamingReporterBase::testCaseStarting(testInfo);
    #####: 9067:        stream << "##teamcity[testStarted name='"
    #####: 9068:            << escape(testInfo.name) << "']\n";
    #####: 9069:        stream.flush();
    #####: 9070:    }
        -: 9071:
    #####: 9072:    void TeamCityReporter::testCaseEnded(TestCaseStats const& testCaseStats) {
        -: 9073:        StreamingReporterBase::testCaseEnded(testCaseStats);
    #####: 9074:        auto const& testCaseInfo = *testCaseStats.testInfo;
    #####: 9075:        if (!testCaseStats.stdOut.empty())
    #####: 9076:            stream << "##teamcity[testStdOut name='"
    #####: 9077:            << escape(testCaseInfo.name)
    #####: 9078:            << "' out='" << escape(testCaseStats.stdOut) << "']\n";
    #####: 9079:        if (!testCaseStats.stdErr.empty())
    #####: 9080:            stream << "##teamcity[testStdErr name='"
    #####: 9081:            << escape(testCaseInfo.name)
    #####: 9082:            << "' out='" << escape(testCaseStats.stdErr) << "']\n";
    #####: 9083:        stream << "##teamcity[testFinished name='"
    #####: 9084:            << escape(testCaseInfo.name) << "' duration='"
    #####: 9085:            << m_testTimer.getElapsedMilliseconds() << "']\n";
    #####: 9086:        stream.flush();
    #####: 9087:    }
        -: 9088:
    #####: 9089:    void TeamCityReporter::printSectionHeader(std::ostream& os) {
    #####: 9090:        assert(!m_sectionStack.empty());
        -: 9091:
    #####: 9092:        if (m_sectionStack.size() > 1) {
        -: 9093:            os << lineOfChars('-') << '\n';
        -: 9094:
        -: 9095:            std::vector<SectionInfo>::const_iterator
        -: 9096:                it = m_sectionStack.begin() + 1, // Skip first section (test case)
        -: 9097:                itEnd = m_sectionStack.end();
    #####: 9098:            for (; it != itEnd; ++it)
    #####: 9099:                printHeaderString(os, it->name);
        -: 9100:            os << lineOfChars('-') << '\n';
        -: 9101:        }
        -: 9102:
    #####: 9103:        SourceLineInfo lineInfo = m_sectionStack.front().lineInfo;
        -: 9104:
    #####: 9105:        os << lineInfo << '\n';
    #####: 9106:        os << lineOfChars('.') << "\n\n";
    #####: 9107:    }
        -: 9108:
        -: 9109:} // end namespace Catch
        -: 9110:
        -: 9111:
        -: 9112:
        -: 9113:
        -: 9114:#if defined(_MSC_VER)
        -: 9115:#pragma warning(push)
        -: 9116:#pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch
        -: 9117:                              // Note that 4062 (not all labels are handled
        -: 9118:                              // and default is missing) is enabled
        -: 9119:#endif
        -: 9120:
        -: 9121:namespace Catch {
    #####: 9122:    XmlReporter::XmlReporter( ReporterConfig const& _config )
        -: 9123:    :   StreamingReporterBase( _config ),
    #####: 9124:        m_xml(_config.stream())
        -: 9125:    {
    #####: 9126:        m_preferences.shouldRedirectStdOut = true;
    #####: 9127:        m_preferences.shouldReportAllAssertions = true;
    #####: 9128:    }
        -: 9129:
        -: 9130:    XmlReporter::~XmlReporter() = default;
        -: 9131:
    #####: 9132:    std::string XmlReporter::getDescription() {
    #####: 9133:        return "Reports test results as an XML document";
        -: 9134:    }
        -: 9135:
    #####: 9136:    std::string XmlReporter::getStylesheetRef() const {
    #####: 9137:        return std::string();
        -: 9138:    }
        -: 9139:
    #####: 9140:    void XmlReporter::writeSourceInfo( SourceLineInfo const& sourceInfo ) {
        -: 9141:        m_xml
    #####: 9142:            .writeAttribute( "filename", sourceInfo.file )
    #####: 9143:            .writeAttribute( "line", sourceInfo.line );
    #####: 9144:    }
        -: 9145:
    #####: 9146:    void XmlReporter::noMatchingTestCases( std::string const& s ) {
        -: 9147:        StreamingReporterBase::noMatchingTestCases( s );
    #####: 9148:    }
        -: 9149:
    #####: 9150:    void XmlReporter::testRunStarting( TestRunInfo const& testInfo ) {
        -: 9151:        StreamingReporterBase::testRunStarting( testInfo );
    #####: 9152:        std::string stylesheetRef = getStylesheetRef();
    #####: 9153:        if( !stylesheetRef.empty() )
    #####: 9154:            m_xml.writeStylesheetRef( stylesheetRef );
    #####: 9155:        m_xml.startElement( "Catch" );
    #####: 9156:        if( !m_config->name().empty() )
    #####: 9157:            m_xml.writeAttribute( "name", m_config->name() );
    #####: 9158:        if (m_config->testSpec().hasFilters())
    #####: 9159:            m_xml.writeAttribute( "filters", serializeFilters( m_config->getTestsOrTags() ) );
    #####: 9160:        if( m_config->rngSeed() != 0 )
    #####: 9161:            m_xml.scopedElement( "Randomness" )
    #####: 9162:                .writeAttribute( "seed", m_config->rngSeed() );
    #####: 9163:    }
        -: 9164:
    #####: 9165:    void XmlReporter::testGroupStarting( GroupInfo const& groupInfo ) {
        -: 9166:        StreamingReporterBase::testGroupStarting( groupInfo );
    #####: 9167:        m_xml.startElement( "Group" )
    #####: 9168:            .writeAttribute( "name", groupInfo.name );
    #####: 9169:    }
        -: 9170:
    #####: 9171:    void XmlReporter::testCaseStarting( TestCaseInfo const& testInfo ) {
        -: 9172:        StreamingReporterBase::testCaseStarting(testInfo);
    #####: 9173:        m_xml.startElement( "TestCase" )
    #####: 9174:            .writeAttribute( "name", trim( testInfo.name ) )
    #####: 9175:            .writeAttribute( "tags", testInfo.tagsAsString() );
        -: 9176:
    #####: 9177:        writeSourceInfo( testInfo.lineInfo );
        -: 9178:
    #####: 9179:        if ( m_config->showDurations() == ShowDurations::Always )
        -: 9180:            m_testCaseTimer.start();
    #####: 9181:        m_xml.ensureTagClosed();
    #####: 9182:    }
        -: 9183:
    #####: 9184:    void XmlReporter::sectionStarting( SectionInfo const& sectionInfo ) {
        -: 9185:        StreamingReporterBase::sectionStarting( sectionInfo );
    #####: 9186:        if( m_sectionDepth++ > 0 ) {
    #####: 9187:            m_xml.startElement( "Section" )
    #####: 9188:                .writeAttribute( "name", trim( sectionInfo.name ) );
    #####: 9189:            writeSourceInfo( sectionInfo.lineInfo );
    #####: 9190:            m_xml.ensureTagClosed();
        -: 9191:        }
    #####: 9192:    }
        -: 9193:
    #####: 9194:    void XmlReporter::assertionStarting( AssertionInfo const& ) { }
        -: 9195:
    #####: 9196:    bool XmlReporter::assertionEnded( AssertionStats const& assertionStats ) {
        -: 9197:
    #####: 9198:        AssertionResult const& result = assertionStats.assertionResult;
        -: 9199:
    #####: 9200:        bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();
        -: 9201:
    #####: 9202:        if( includeResults || result.getResultType() == ResultWas::Warning ) {
        -: 9203:            // Print any info messages in <Info> tags.
    #####: 9204:            for( auto const& msg : assertionStats.infoMessages ) {
    #####: 9205:                if( msg.type == ResultWas::Info && includeResults ) {
    #####: 9206:                    m_xml.scopedElement( "Info" )
    #####: 9207:                            .writeText( msg.message );
    #####: 9208:                } else if ( msg.type == ResultWas::Warning ) {
    #####: 9209:                    m_xml.scopedElement( "Warning" )
    #####: 9210:                            .writeText( msg.message );
        -: 9211:                }
        -: 9212:            }
        -: 9213:        }
        -: 9214:
        -: 9215:        // Drop out if result was successful but we're not printing them.
    #####: 9216:        if( !includeResults && result.getResultType() != ResultWas::Warning )
        -: 9217:            return true;
        -: 9218:
        -: 9219:
        -: 9220:        // Print the expression if there is one.
    #####: 9221:        if( result.hasExpression() ) {
    #####: 9222:            m_xml.startElement( "Expression" )
    #####: 9223:                .writeAttribute( "success", result.succeeded() )
    #####: 9224:                .writeAttribute( "type", result.getTestMacroName() );
        -: 9225:
    #####: 9226:            writeSourceInfo( result.getSourceInfo() );
        -: 9227:
    #####: 9228:            m_xml.scopedElement( "Original" )
    #####: 9229:                .writeText( result.getExpression() );
    #####: 9230:            m_xml.scopedElement( "Expanded" )
    #####: 9231:                .writeText( result.getExpandedExpression() );
        -: 9232:        }
        -: 9233:
        -: 9234:        // And... Print a result applicable to each result type.
    #####: 9235:        switch( result.getResultType() ) {
        -: 9236:            case ResultWas::ThrewException:
    #####: 9237:                m_xml.startElement( "Exception" );
    #####: 9238:                writeSourceInfo( result.getSourceInfo() );
    #####: 9239:                m_xml.writeText( result.getMessage() );
    #####: 9240:                m_xml.endElement();
    #####: 9241:                break;
        -: 9242:            case ResultWas::FatalErrorCondition:
    #####: 9243:                m_xml.startElement( "FatalErrorCondition" );
    #####: 9244:                writeSourceInfo( result.getSourceInfo() );
    #####: 9245:                m_xml.writeText( result.getMessage() );
    #####: 9246:                m_xml.endElement();
    #####: 9247:                break;
        -: 9248:            case ResultWas::Info:
    #####: 9249:                m_xml.scopedElement( "Info" )
    #####: 9250:                    .writeText( result.getMessage() );
    #####: 9251:                break;
        -: 9252:            case ResultWas::Warning:
        -: 9253:                // Warning will already have been written
        -: 9254:                break;
        -: 9255:            case ResultWas::ExplicitFailure:
    #####: 9256:                m_xml.startElement( "Failure" );
    #####: 9257:                writeSourceInfo( result.getSourceInfo() );
    #####: 9258:                m_xml.writeText( result.getMessage() );
    #####: 9259:                m_xml.endElement();
    #####: 9260:                break;
        -: 9261:            default:
        -: 9262:                break;
        -: 9263:        }
        -: 9264:
    #####: 9265:        if( result.hasExpression() )
    #####: 9266:            m_xml.endElement();
        -: 9267:
        -: 9268:        return true;
        -: 9269:    }
        -: 9270:
    #####: 9271:    void XmlReporter::sectionEnded( SectionStats const& sectionStats ) {
        -: 9272:        StreamingReporterBase::sectionEnded( sectionStats );
    #####: 9273:        if( --m_sectionDepth > 0 ) {
    #####: 9274:            XmlWriter::ScopedElement e = m_xml.scopedElement( "OverallResults" );
    #####: 9275:            e.writeAttribute( "successes", sectionStats.assertions.passed );
    #####: 9276:            e.writeAttribute( "failures", sectionStats.assertions.failed );
    #####: 9277:            e.writeAttribute( "expectedFailures", sectionStats.assertions.failedButOk );
        -: 9278:
    #####: 9279:            if ( m_config->showDurations() == ShowDurations::Always )
    #####: 9280:                e.writeAttribute( "durationInSeconds", sectionStats.durationInSeconds );
        -: 9281:
    #####: 9282:            m_xml.endElement();
        -: 9283:        }
    #####: 9284:    }
        -: 9285:
    #####: 9286:    void XmlReporter::testCaseEnded( TestCaseStats const& testCaseStats ) {
        -: 9287:        StreamingReporterBase::testCaseEnded( testCaseStats );
    #####: 9288:        XmlWriter::ScopedElement e = m_xml.scopedElement( "OverallResult" );
    #####: 9289:        e.writeAttribute( "success", testCaseStats.totals.assertions.allOk() );
        -: 9290:
    #####: 9291:        if ( m_config->showDurations() == ShowDurations::Always )
    #####: 9292:            e.writeAttribute( "durationInSeconds", m_testCaseTimer.getElapsedSeconds() );
        -: 9293:
    #####: 9294:        if( !testCaseStats.stdOut.empty() )
    #####: 9295:            m_xml.scopedElement( "StdOut" ).writeText( trim( testCaseStats.stdOut ), XmlFormatting::Newline );
    #####: 9296:        if( !testCaseStats.stdErr.empty() )
    #####: 9297:            m_xml.scopedElement( "StdErr" ).writeText( trim( testCaseStats.stdErr ), XmlFormatting::Newline );
        -: 9298:
    #####: 9299:        m_xml.endElement();
    #####: 9300:    }
        -: 9301:
    #####: 9302:    void XmlReporter::testGroupEnded( TestGroupStats const& testGroupStats ) {
        -: 9303:        StreamingReporterBase::testGroupEnded( testGroupStats );
        -: 9304:        // TODO: Check testGroupStats.aborting and act accordingly.
    #####: 9305:        m_xml.scopedElement( "OverallResults" )
    #####: 9306:            .writeAttribute( "successes", testGroupStats.totals.assertions.passed )
    #####: 9307:            .writeAttribute( "failures", testGroupStats.totals.assertions.failed )
    #####: 9308:            .writeAttribute( "expectedFailures", testGroupStats.totals.assertions.failedButOk );
    #####: 9309:        m_xml.scopedElement( "OverallResultsCases")
    #####: 9310:            .writeAttribute( "successes", testGroupStats.totals.testCases.passed )
    #####: 9311:            .writeAttribute( "failures", testGroupStats.totals.testCases.failed )
    #####: 9312:            .writeAttribute( "expectedFailures", testGroupStats.totals.testCases.failedButOk );
    #####: 9313:        m_xml.endElement();
    #####: 9314:    }
        -: 9315:
    #####: 9316:    void XmlReporter::testRunEnded( TestRunStats const& testRunStats ) {
    #####: 9317:        StreamingReporterBase::testRunEnded( testRunStats );
    #####: 9318:        m_xml.scopedElement( "OverallResults" )
    #####: 9319:            .writeAttribute( "successes", testRunStats.totals.assertions.passed )
    #####: 9320:            .writeAttribute( "failures", testRunStats.totals.assertions.failed )
    #####: 9321:            .writeAttribute( "expectedFailures", testRunStats.totals.assertions.failedButOk );
    #####: 9322:        m_xml.scopedElement( "OverallResultsCases")
    #####: 9323:            .writeAttribute( "successes", testRunStats.totals.testCases.passed )
    #####: 9324:            .writeAttribute( "failures", testRunStats.totals.testCases.failed )
    #####: 9325:            .writeAttribute( "expectedFailures", testRunStats.totals.testCases.failedButOk );
    #####: 9326:        m_xml.endElement();
    #####: 9327:    }
        -: 9328:
    #####: 9329:    void XmlReporter::benchmarkPreparing(std::string const& name) {
    #####: 9330:        m_xml.startElement("BenchmarkResults")
    #####: 9331:            .writeAttribute("name", name);
    #####: 9332:    }
        -: 9333:
    #####: 9334:    void XmlReporter::benchmarkStarting(BenchmarkInfo const &info) {
    #####: 9335:        m_xml.writeAttribute("samples", info.samples)
    #####: 9336:            .writeAttribute("resamples", info.resamples)
    #####: 9337:            .writeAttribute("iterations", info.iterations)
    #####: 9338:            .writeAttribute("clockResolution", info.clockResolution)
    #####: 9339:            .writeAttribute("estimatedDuration", info.estimatedDuration)
    #####: 9340:            .writeComment("All values in nano seconds");
    #####: 9341:    }
        -: 9342:
    #####: 9343:    void XmlReporter::benchmarkEnded(BenchmarkStats<> const& benchmarkStats) {
    #####: 9344:        m_xml.startElement("mean")
    #####: 9345:            .writeAttribute("value", benchmarkStats.mean.point.count())
    #####: 9346:            .writeAttribute("lowerBound", benchmarkStats.mean.lower_bound.count())
    #####: 9347:            .writeAttribute("upperBound", benchmarkStats.mean.upper_bound.count())
    #####: 9348:            .writeAttribute("ci", benchmarkStats.mean.confidence_interval);
    #####: 9349:        m_xml.endElement();
    #####: 9350:        m_xml.startElement("standardDeviation")
    #####: 9351:            .writeAttribute("value", benchmarkStats.standardDeviation.point.count())
    #####: 9352:            .writeAttribute("lowerBound", benchmarkStats.standardDeviation.lower_bound.count())
    #####: 9353:            .writeAttribute("upperBound", benchmarkStats.standardDeviation.upper_bound.count())
    #####: 9354:            .writeAttribute("ci", benchmarkStats.standardDeviation.confidence_interval);
    #####: 9355:        m_xml.endElement();
    #####: 9356:        m_xml.startElement("outliers")
    #####: 9357:            .writeAttribute("variance", benchmarkStats.outlierVariance)
    #####: 9358:            .writeAttribute("lowMild", benchmarkStats.outliers.low_mild)
    #####: 9359:            .writeAttribute("lowSevere", benchmarkStats.outliers.low_severe)
    #####: 9360:            .writeAttribute("highMild", benchmarkStats.outliers.high_mild)
    #####: 9361:            .writeAttribute("highSevere", benchmarkStats.outliers.high_severe);
    #####: 9362:        m_xml.endElement();
    #####: 9363:        m_xml.endElement();
    #####: 9364:    }
        -: 9365:
    #####: 9366:    void XmlReporter::benchmarkFailed(std::string const &error) {
    #####: 9367:        m_xml.scopedElement("failed").
    #####: 9368:            writeAttribute("message", error);
    #####: 9369:        m_xml.endElement();
    #####: 9370:    }
        -: 9371:
    #####: 9372:    void XmlReporter::listReporters(std::vector<ReporterDescription> const& descriptions, IConfig const&) {
    #####: 9373:        auto outerTag = m_xml.scopedElement("AvailableReporters");
    #####: 9374:        for (auto const& reporter : descriptions) {
    #####: 9375:            auto inner = m_xml.scopedElement("Reporter");
    #####: 9376:            m_xml.startElement("Name", XmlFormatting::Indent)
    #####: 9377:                 .writeText(reporter.name, XmlFormatting::None)
    #####: 9378:                 .endElement(XmlFormatting::Newline);
    #####: 9379:            m_xml.startElement("Description", XmlFormatting::Indent)
    #####: 9380:                 .writeText(reporter.description, XmlFormatting::None)
    #####: 9381:                 .endElement(XmlFormatting::Newline);
        -: 9382:        }
    #####: 9383:    }
        -: 9384:
    #####: 9385:    void XmlReporter::listTests(std::vector<TestCaseHandle> const& tests, IConfig const&) {
    #####: 9386:        auto outerTag = m_xml.scopedElement("MatchingTests");
    #####: 9387:        for (auto const& test : tests) {
    #####: 9388:            auto innerTag = m_xml.scopedElement("TestCase");
        -: 9389:            auto const& testInfo = test.getTestCaseInfo();
    #####: 9390:            m_xml.startElement("Name", XmlFormatting::Indent)
    #####: 9391:                 .writeText(testInfo.name, XmlFormatting::None)
    #####: 9392:                 .endElement(XmlFormatting::Newline);
    #####: 9393:            m_xml.startElement("ClassName", XmlFormatting::Indent)
    #####: 9394:                 .writeText(testInfo.className, XmlFormatting::None)
    #####: 9395:                 .endElement(XmlFormatting::Newline);
    #####: 9396:            m_xml.startElement("Tags", XmlFormatting::Indent)
    #####: 9397:                 .writeText(testInfo.tagsAsString(), XmlFormatting::None)
    #####: 9398:                 .endElement(XmlFormatting::Newline);
        -: 9399:
    #####: 9400:            auto sourceTag = m_xml.scopedElement("SourceInfo");
    #####: 9401:            m_xml.startElement("File", XmlFormatting::Indent)
    #####: 9402:                 .writeText(testInfo.lineInfo.file, XmlFormatting::None)
    #####: 9403:                 .endElement(XmlFormatting::Newline);
    #####: 9404:            m_xml.startElement("Line", XmlFormatting::Indent)
    #####: 9405:                 .writeText(std::to_string(testInfo.lineInfo.line), XmlFormatting::None)
    #####: 9406:                 .endElement(XmlFormatting::Newline);
        -: 9407:        }
    #####: 9408:    }
        -: 9409:
    #####: 9410:    void XmlReporter::listTags(std::vector<TagInfo> const& tags, IConfig const&) {
    #####: 9411:        auto outerTag = m_xml.scopedElement("TagsFromMatchingTests");
    #####: 9412:        for (auto const& tag : tags) {
    #####: 9413:            auto innerTag = m_xml.scopedElement("Tag");
    #####: 9414:            m_xml.startElement("Count", XmlFormatting::Indent)
    #####: 9415:                 .writeText(std::to_string(tag.count), XmlFormatting::None)
    #####: 9416:                 .endElement(XmlFormatting::Newline);
    #####: 9417:            auto aliasTag = m_xml.scopedElement("Aliases");
    #####: 9418:            for (auto const& alias : tag.spellings) {
    #####: 9419:                m_xml.startElement("Alias", XmlFormatting::Indent)
    #####: 9420:                     .writeText(static_cast<std::string>(alias), XmlFormatting::None)
    #####: 9421:                     .endElement(XmlFormatting::Newline);
        -: 9422:            }
        -: 9423:        }
    #####: 9424:    }
        -: 9425:
        -: 9426:} // end namespace Catch
        -: 9427:
        -: 9428:#if defined(_MSC_VER)
        -: 9429:#pragma warning(pop)
        -: 9430:#endif
