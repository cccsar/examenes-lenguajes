        -:    0:Source:catch_amalgamated.hpp
        -:    0:Graph:test.gcno
        -:    0:Data:test.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://              Copyright Catch2 Authors
        -:    2:// Distributed under the Boost Software License, Version 1.0.
        -:    3://   (See accompanying file LICENSE_1_0.txt or copy at
        -:    4://        https://www.boost.org/LICENSE_1_0.txt)
        -:    5:
        -:    6:// SPDX-License-Identifier: BSL-1.0
        -:    7:
        -:    8://  Catch v3.0.0-preview.3
        -:    9://  Generated: 2020-10-08 13:59:26.309308
        -:   10://  ----------------------------------------------------------
        -:   11://  This file is an amalgamation of multiple different files.
        -:   12://  You probably shouldn't edit it directly.
        -:   13://  ----------------------------------------------------------
        -:   14:#ifndef CATCH_AMALGAMATED_HPP_INCLUDED
        -:   15:#define CATCH_AMALGAMATED_HPP_INCLUDED
        -:   16:
        -:   17:
        -:   18:/** \file
        -:   19: * This is a convenience header for Catch2. It includes **all** of Catch2 headers.
        -:   20: *
        -:   21: * Generally the Catch2 users should use specific includes they need,
        -:   22: * but this header can be used instead for ease-of-experimentation, or
        -:   23: * just plain convenience, at the cost of (significantly) increased
        -:   24: * compilation times.
        -:   25: *
        -:   26: * When a new header is added to either the top level folder, or to the
        -:   27: * corresponding internal subfolder, it should be added here. Headers
        -:   28: * added to the various subparts (e.g. matchers, generators, etc...),
        -:   29: * should go their respective catch-all headers.
        -:   30: */
        -:   31:
        -:   32:#ifndef CATCH_ALL_HPP_INCLUDED
        -:   33:#define CATCH_ALL_HPP_INCLUDED
        -:   34:
        -:   35:
        -:   36:
        -:   37:/** \file
        -:   38: * This is a convenience header for Catch2's benchmarking. It includes
        -:   39: * **all** of Catch2 headers related to benchmarking.
        -:   40: *
        -:   41: * Generally the Catch2 users should use specific includes they need,
        -:   42: * but this header can be used instead for ease-of-experimentation, or
        -:   43: * just plain convenience, at the cost of (significantly) increased
        -:   44: * compilation times.
        -:   45: *
        -:   46: * When a new header is added to either the `benchmark` folder, or to
        -:   47: * the corresponding internal (detail) subfolder, it should be added here.
        -:   48: */
        -:   49:
        -:   50:#ifndef CATCH_BENCHMARK_ALL_HPP_INCLUDED
        -:   51:#define CATCH_BENCHMARK_ALL_HPP_INCLUDED
        -:   52:
        -:   53:
        -:   54:
        -:   55:// Adapted from donated nonius code.
        -:   56:
        -:   57:#ifndef CATCH_BENCHMARK_HPP_INCLUDED
        -:   58:#define CATCH_BENCHMARK_HPP_INCLUDED
        -:   59:
        -:   60:
        -:   61:
        -:   62:#ifndef CATCH_INTERFACES_CONFIG_HPP_INCLUDED
        -:   63:#define CATCH_INTERFACES_CONFIG_HPP_INCLUDED
        -:   64:
        -:   65:
        -:   66:
        -:   67:#ifndef CATCH_NONCOPYABLE_HPP_INCLUDED
        -:   68:#define CATCH_NONCOPYABLE_HPP_INCLUDED
        -:   69:
        -:   70:namespace Catch {
        -:   71:    namespace Detail {
        -:   72:
        -:   73:        //! Deriving classes become noncopyable and nonmovable
        -:   74:        class NonCopyable {
        -:   75:            NonCopyable( NonCopyable const& ) = delete;
        -:   76:            NonCopyable( NonCopyable&& ) = delete;
        -:   77:            NonCopyable& operator=( NonCopyable const& ) = delete;
        -:   78:            NonCopyable& operator=( NonCopyable&& ) = delete;
        -:   79:
        -:   80:        protected:
        -:   81:            NonCopyable() noexcept = default;
        -:   82:        };
        -:   83:
        -:   84:    } // namespace Detail
        -:   85:} // namespace Catch
        -:   86:
        -:   87:#endif // CATCH_NONCOPYABLE_HPP_INCLUDED
        -:   88:
        -:   89:#include <chrono>
        -:   90:#include <iosfwd>
        -:   91:#include <string>
        -:   92:#include <vector>
        -:   93:
        -:   94:namespace Catch {
        -:   95:
        -:   96:    enum class Verbosity {
        -:   97:        Quiet = 0,
        -:   98:        Normal,
        -:   99:        High
        -:  100:    };
        -:  101:
        -:  102:    struct WarnAbout { enum What {
        -:  103:        Nothing = 0x00,
        -:  104:        NoAssertions = 0x01,
        -:  105:        NoTests = 0x02
        -:  106:    }; };
        -:  107:
        -:  108:    enum class ShowDurations {
        -:  109:        DefaultForReporter,
        -:  110:        Always,
        -:  111:        Never
        -:  112:    };
        -:  113:    enum class TestRunOrder {
        -:  114:        Declared,
        -:  115:        LexicographicallySorted,
        -:  116:        Randomized
        -:  117:    };
        -:  118:    enum class UseColour {
        -:  119:        Auto,
        -:  120:        Yes,
        -:  121:        No
        -:  122:    };
        -:  123:    struct WaitForKeypress { enum When {
        -:  124:        Never,
        -:  125:        BeforeStart = 1,
        -:  126:        BeforeExit = 2,
        -:  127:        BeforeStartAndExit = BeforeStart | BeforeExit
        -:  128:    }; };
        -:  129:
        -:  130:    class TestSpec;
        -:  131:
        2:  132:    struct IConfig : Detail::NonCopyable {
        -:  133:
        -:  134:        virtual ~IConfig();
        -:  135:
        -:  136:        virtual bool allowThrows() const = 0;
        -:  137:        virtual std::ostream& stream() const = 0;
        -:  138:        virtual std::string name() const = 0;
        -:  139:        virtual bool includeSuccessfulResults() const = 0;
        -:  140:        virtual bool shouldDebugBreak() const = 0;
        -:  141:        virtual bool warnAboutMissingAssertions() const = 0;
        -:  142:        virtual bool warnAboutNoTests() const = 0;
        -:  143:        virtual int abortAfter() const = 0;
        -:  144:        virtual bool showInvisibles() const = 0;
        -:  145:        virtual ShowDurations showDurations() const = 0;
        -:  146:        virtual double minDuration() const = 0;
        -:  147:        virtual TestSpec const& testSpec() const = 0;
        -:  148:        virtual bool hasTestFilters() const = 0;
        -:  149:        virtual std::vector<std::string> const& getTestsOrTags() const = 0;
        -:  150:        virtual TestRunOrder runOrder() const = 0;
        -:  151:        virtual unsigned int rngSeed() const = 0;
        -:  152:        virtual UseColour useColour() const = 0;
        -:  153:        virtual std::vector<std::string> const& getSectionsToRun() const = 0;
        -:  154:        virtual Verbosity verbosity() const = 0;
        -:  155:
        -:  156:        virtual bool benchmarkNoAnalysis() const = 0;
        -:  157:        virtual int benchmarkSamples() const = 0;
        -:  158:        virtual double benchmarkConfidenceInterval() const = 0;
        -:  159:        virtual unsigned int benchmarkResamples() const = 0;
        -:  160:        virtual std::chrono::milliseconds benchmarkWarmupTime() const = 0;
        -:  161:    };
        -:  162:}
        -:  163:
        -:  164:#endif // CATCH_INTERFACES_CONFIG_HPP_INCLUDED
        -:  165:
        -:  166:
        -:  167:#ifndef CATCH_CONTEXT_HPP_INCLUDED
        -:  168:#define CATCH_CONTEXT_HPP_INCLUDED
        -:  169:
        -:  170:namespace Catch {
        -:  171:
        -:  172:    struct IResultCapture;
        -:  173:    struct IRunner;
        -:  174:    struct IConfig;
        -:  175:
        2:  176:    struct IContext
        -:  177:    {
        -:  178:        virtual ~IContext();
        -:  179:
        -:  180:        virtual IResultCapture* getResultCapture() = 0;
        -:  181:        virtual IRunner* getRunner() = 0;
        -:  182:        virtual IConfig const* getConfig() const = 0;
        -:  183:    };
        -:  184:
        3:  185:    struct IMutableContext : IContext
        -:  186:    {
        -:  187:        virtual ~IMutableContext();
        -:  188:        virtual void setResultCapture( IResultCapture* resultCapture ) = 0;
        -:  189:        virtual void setRunner( IRunner* runner ) = 0;
        -:  190:        virtual void setConfig( IConfig const* config ) = 0;
        -:  191:
        -:  192:    private:
        -:  193:        static IMutableContext *currentContext;
        -:  194:        friend IMutableContext& getCurrentMutableContext();
        -:  195:        friend void cleanUpContext();
        -:  196:        static void createContext();
        -:  197:    };
        -:  198:
        -:  199:    inline IMutableContext& getCurrentMutableContext()
        -:  200:    {
       15:  201:        if( !IMutableContext::currentContext )
        1:  202:            IMutableContext::createContext();
        -:  203:        // NOLINTNEXTLINE(clang-analyzer-core.uninitialized.UndefReturn)
       15:  204:        return *IMutableContext::currentContext;
        -:  205:    }
        -:  206:
        -:  207:    inline IContext& getCurrentContext()
        -:  208:    {
       13:  209:        return getCurrentMutableContext();
        -:  210:    }
        -:  211:
        -:  212:    void cleanUpContext();
        -:  213:
        -:  214:    class SimplePcg32;
        -:  215:    SimplePcg32& rng();
        -:  216:}
        -:  217:
        -:  218:#endif // CATCH_CONTEXT_HPP_INCLUDED
        -:  219:
        -:  220:
        -:  221:#ifndef CATCH_INTERFACES_REPORTER_HPP_INCLUDED
        -:  222:#define CATCH_INTERFACES_REPORTER_HPP_INCLUDED
        -:  223:
        -:  224:
        -:  225:
        -:  226:#ifndef CATCH_SECTION_INFO_HPP_INCLUDED
        -:  227:#define CATCH_SECTION_INFO_HPP_INCLUDED
        -:  228:
        -:  229:
        -:  230:
        -:  231:#ifndef CATCH_COMMON_HPP_INCLUDED
        -:  232:#define CATCH_COMMON_HPP_INCLUDED
        -:  233:
        -:  234:
        -:  235:
        -:  236:#ifndef CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED
        -:  237:#define CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED
        -:  238:
        -:  239:// Detect a number of compiler features - by compiler
        -:  240:// The following features are defined:
        -:  241://
        -:  242:// CATCH_CONFIG_COUNTER : is the __COUNTER__ macro supported?
        -:  243:// CATCH_CONFIG_WINDOWS_SEH : is Windows SEH supported?
        -:  244:// CATCH_CONFIG_POSIX_SIGNALS : are POSIX signals supported?
        -:  245:// CATCH_CONFIG_DISABLE_EXCEPTIONS : Are exceptions enabled?
        -:  246:// ****************
        -:  247:// Note to maintainers: if new toggles are added please document them
        -:  248:// in configuration.md, too
        -:  249:// ****************
        -:  250:
        -:  251:// In general each macro has a _NO_<feature name> form
        -:  252:// (e.g. CATCH_CONFIG_NO_POSIX_SIGNALS) which disables the feature.
        -:  253:// Many features, at point of detection, define an _INTERNAL_ macro, so they
        -:  254:// can be combined, en-mass, with the _NO_ forms later.
        -:  255:
        -:  256:
        -:  257:
        -:  258:#ifndef CATCH_PLATFORM_HPP_INCLUDED
        -:  259:#define CATCH_PLATFORM_HPP_INCLUDED
        -:  260:
        -:  261:#ifdef __APPLE__
        -:  262:# include <TargetConditionals.h>
        -:  263:# if TARGET_OS_OSX == 1
        -:  264:#  define CATCH_PLATFORM_MAC
        -:  265:# elif TARGET_OS_IPHONE == 1
        -:  266:#  define CATCH_PLATFORM_IPHONE
        -:  267:# endif
        -:  268:
        -:  269:#elif defined(linux) || defined(__linux) || defined(__linux__)
        -:  270:#  define CATCH_PLATFORM_LINUX
        -:  271:
        -:  272:#elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) || defined(__MINGW32__)
        -:  273:#  define CATCH_PLATFORM_WINDOWS
        -:  274:#endif
        -:  275:
        -:  276:#endif // CATCH_PLATFORM_HPP_INCLUDED
        -:  277:
        -:  278:#ifdef __cplusplus
        -:  279:
        -:  280:#  if (__cplusplus >= 201402L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201402L)
        -:  281:#    define CATCH_CPP14_OR_GREATER
        -:  282:#  endif
        -:  283:
        -:  284:#  if (__cplusplus >= 201703L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)
        -:  285:#    define CATCH_CPP17_OR_GREATER
        -:  286:#  endif
        -:  287:
        -:  288:#endif
        -:  289:
        -:  290:// We have to avoid both ICC and Clang, because they try to mask themselves
        -:  291:// as gcc, and we want only GCC in this block
        -:  292:#if defined(__GNUC__) && !defined(__clang__) && !defined(__ICC) && !defined(__CUDACC__)
        -:  293:#    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "GCC diagnostic push" )
        -:  294:#    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "GCC diagnostic pop" )
        -:  295:
        -:  296:// This only works on GCC 9+. so we have to also add a global suppression of Wparentheses
        -:  297:// for older versions of GCC.
        -:  298:#    define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
        -:  299:         _Pragma( "GCC diagnostic ignored \"-Wparentheses\"" )
        -:  300:
        -:  301:#    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -:  302:         _Pragma( "GCC diagnostic ignored \"-Wunused-variable\"" )
        -:  303:
        -:  304:#    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__)
        -:  305:
        -:  306:#endif
        -:  307:
        -:  308:#if defined(__clang__)
        -:  309:
        -:  310:#    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "clang diagnostic push" )
        -:  311:#    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "clang diagnostic pop" )
        -:  312:
        -:  313:// As of this writing, IBM XL's implementation of __builtin_constant_p has a bug
        -:  314:// which results in calls to destructors being emitted for each temporary,
        -:  315:// without a matching initialization. In practice, this can result in something
        -:  316:// like `std::string::~string` being called on an uninitialized value.
        -:  317://
        -:  318:// For example, this code will likely segfault under IBM XL:
        -:  319:// ```
        -:  320:// REQUIRE(std::string("12") + "34" == "1234")
        -:  321:// ```
        -:  322://
        -:  323:// Therefore, `CATCH_INTERNAL_IGNORE_BUT_WARN` is not implemented.
        -:  324:#  if !defined(__ibmxl__) && !defined(__CUDACC__)
        -:  325:#    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__) /* NOLINT(cppcoreguidelines-pro-type-vararg, hicpp-vararg) */
        -:  326:#  endif
        -:  327:
        -:  328:
        -:  329:#    define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -:  330:         _Pragma( "clang diagnostic ignored \"-Wexit-time-destructors\"" ) \
        -:  331:         _Pragma( "clang diagnostic ignored \"-Wglobal-constructors\"")
        -:  332:
        -:  333:#    define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
        -:  334:         _Pragma( "clang diagnostic ignored \"-Wparentheses\"" )
        -:  335:
        -:  336:#    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -:  337:         _Pragma( "clang diagnostic ignored \"-Wunused-variable\"" )
        -:  338:
        -:  339:#    define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
        -:  340:         _Pragma( "clang diagnostic ignored \"-Wgnu-zero-variadic-macro-arguments\"" )
        -:  341:
        -:  342:#    define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
        -:  343:         _Pragma( "clang diagnostic ignored \"-Wunused-template\"" )
        -:  344:
        -:  345:#endif // __clang__
        -:  346:
        -:  347:
        -:  348:////////////////////////////////////////////////////////////////////////////////
        -:  349:// Assume that non-Windows platforms support posix signals by default
        -:  350:#if !defined(CATCH_PLATFORM_WINDOWS)
        -:  351:    #define CATCH_INTERNAL_CONFIG_POSIX_SIGNALS
        -:  352:#endif
        -:  353:
        -:  354:////////////////////////////////////////////////////////////////////////////////
        -:  355:// We know some environments not to support full POSIX signals
        -:  356:#if defined(__CYGWIN__) || defined(__QNX__) || defined(__EMSCRIPTEN__) || defined(__DJGPP__)
        -:  357:    #define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
        -:  358:#endif
        -:  359:
        -:  360:#ifdef __OS400__
        -:  361:#       define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
        -:  362:#       define CATCH_CONFIG_COLOUR_NONE
        -:  363:#endif
        -:  364:
        -:  365:////////////////////////////////////////////////////////////////////////////////
        -:  366:// Android somehow still does not support std::to_string
        -:  367:#if defined(__ANDROID__)
        -:  368:#    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING
        -:  369:#    define CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE
        -:  370:#endif
        -:  371:
        -:  372:////////////////////////////////////////////////////////////////////////////////
        -:  373:// Not all Windows environments support SEH properly
        -:  374:#if defined(__MINGW32__)
        -:  375:#    define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH
        -:  376:#endif
        -:  377:
        -:  378:////////////////////////////////////////////////////////////////////////////////
        -:  379:// PS4
        -:  380:#if defined(__ORBIS__)
        -:  381:#    define CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE
        -:  382:#endif
        -:  383:
        -:  384:////////////////////////////////////////////////////////////////////////////////
        -:  385:// Cygwin
        -:  386:#ifdef __CYGWIN__
        -:  387:
        -:  388:// Required for some versions of Cygwin to declare gettimeofday
        -:  389:// see: http://stackoverflow.com/questions/36901803/gettimeofday-not-declared-in-this-scope-cygwin
        -:  390:#   define _BSD_SOURCE
        -:  391:// some versions of cygwin (most) do not support std::to_string. Use the libstd check.
        -:  392:// https://gcc.gnu.org/onlinedocs/gcc-4.8.2/libstdc++/api/a01053_source.html line 2812-2813
        -:  393:# if !((__cplusplus >= 201103L) && defined(_GLIBCXX_USE_C99) \
        -:  394:           && !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF))
        -:  395:
        -:  396:#    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING
        -:  397:
        -:  398:# endif
        -:  399:#endif // __CYGWIN__
        -:  400:
        -:  401:////////////////////////////////////////////////////////////////////////////////
        -:  402:// Visual C++
        -:  403:#if defined(_MSC_VER)
        -:  404:
        -:  405:#  define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION __pragma( warning(push) )
        -:  406:#  define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  __pragma( warning(pop) )
        -:  407:
        -:  408:// Universal Windows platform does not support SEH
        -:  409:// Or console colours (or console at all...)
        -:  410:#  if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
        -:  411:#    define CATCH_CONFIG_COLOUR_NONE
        -:  412:#  else
        -:  413:#    define CATCH_INTERNAL_CONFIG_WINDOWS_SEH
        -:  414:#  endif
        -:  415:
        -:  416:// MSVC traditional preprocessor needs some workaround for __VA_ARGS__
        -:  417:// _MSVC_TRADITIONAL == 0 means new conformant preprocessor
        -:  418:// _MSVC_TRADITIONAL == 1 means old traditional non-conformant preprocessor
        -:  419:#  if !defined(__clang__) // Handle Clang masquerading for msvc
        -:  420:#    if !defined(_MSVC_TRADITIONAL) || (defined(_MSVC_TRADITIONAL) && _MSVC_TRADITIONAL)
        -:  421:#      define CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -:  422:#    endif // MSVC_TRADITIONAL
        -:  423:#  endif // __clang__
        -:  424:
        -:  425:#endif // _MSC_VER
        -:  426:
        -:  427:#if defined(_REENTRANT) || defined(_MSC_VER)
        -:  428:// Enable async processing, as -pthread is specified or no additional linking is required
        -:  429:# define CATCH_INTERNAL_CONFIG_USE_ASYNC
        -:  430:#endif // _MSC_VER
        -:  431:
        -:  432:////////////////////////////////////////////////////////////////////////////////
        -:  433:// Check if we are compiled with -fno-exceptions or equivalent
        -:  434:#if defined(__EXCEPTIONS) || defined(__cpp_exceptions) || defined(_CPPUNWIND)
        -:  435:#  define CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED
        -:  436:#endif
        -:  437:
        -:  438:////////////////////////////////////////////////////////////////////////////////
        -:  439:// DJGPP
        -:  440:#ifdef __DJGPP__
        -:  441:#  define CATCH_INTERNAL_CONFIG_NO_WCHAR
        -:  442:#endif // __DJGPP__
        -:  443:
        -:  444:////////////////////////////////////////////////////////////////////////////////
        -:  445:// Embarcadero C++Build
        -:  446:#if defined(__BORLANDC__)
        -:  447:    #define CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN
        -:  448:#endif
        -:  449:
        -:  450:////////////////////////////////////////////////////////////////////////////////
        -:  451:
        -:  452:// Use of __COUNTER__ is suppressed during code analysis in
        -:  453:// CLion/AppCode 2017.2.x and former, because __COUNTER__ is not properly
        -:  454:// handled by it.
        -:  455:// Otherwise all supported compilers support COUNTER macro,
        -:  456:// but user still might want to turn it off
        -:  457:#if ( !defined(__JETBRAINS_IDE__) || __JETBRAINS_IDE__ >= 20170300L )
        -:  458:    #define CATCH_INTERNAL_CONFIG_COUNTER
        -:  459:#endif
        -:  460:
        -:  461:
        -:  462:////////////////////////////////////////////////////////////////////////////////
        -:  463:
        -:  464:// RTX is a special version of Windows that is real time.
        -:  465:// This means that it is detected as Windows, but does not provide
        -:  466:// the same set of capabilities as real Windows does.
        -:  467:#if defined(UNDER_RTSS) || defined(RTX64_BUILD)
        -:  468:    #define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH
        -:  469:    #define CATCH_INTERNAL_CONFIG_NO_ASYNC
        -:  470:    #define CATCH_CONFIG_COLOUR_NONE
        -:  471:#endif
        -:  472:
        -:  473:#if !defined(_GLIBCXX_USE_C99_MATH_TR1)
        -:  474:#define CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER
        -:  475:#endif
        -:  476:
        -:  477:// Various stdlib support checks that require __has_include
        -:  478:#if defined(__has_include)
        -:  479:  // Check if string_view is available and usable
        -:  480:  #if __has_include(<string_view>) && defined(CATCH_CPP17_OR_GREATER)
        -:  481:  #    define CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW
        -:  482:  #endif
        -:  483:
        -:  484:  // Check if optional is available and usable
        -:  485:  #  if __has_include(<optional>) && defined(CATCH_CPP17_OR_GREATER)
        -:  486:  #    define CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL
        -:  487:  #  endif // __has_include(<optional>) && defined(CATCH_CPP17_OR_GREATER)
        -:  488:
        -:  489:  // Check if byte is available and usable
        -:  490:  #  if __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)
        -:  491:  #    include <cstddef>
        -:  492:  #    if __cpp_lib_byte > 0
        -:  493:  #      define CATCH_INTERNAL_CONFIG_CPP17_BYTE
        -:  494:  #    endif
        -:  495:  #  endif // __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)
        -:  496:
        -:  497:  // Check if variant is available and usable
        -:  498:  #  if __has_include(<variant>) && defined(CATCH_CPP17_OR_GREATER)
        -:  499:  #    if defined(__clang__) && (__clang_major__ < 8)
        -:  500:         // work around clang bug with libstdc++ https://bugs.llvm.org/show_bug.cgi?id=31852
        -:  501:         // fix should be in clang 8, workaround in libstdc++ 8.2
        -:  502:  #      include <ciso646>
        -:  503:  #      if defined(__GLIBCXX__) && defined(_GLIBCXX_RELEASE) && (_GLIBCXX_RELEASE < 9)
        -:  504:  #        define CATCH_CONFIG_NO_CPP17_VARIANT
        -:  505:  #      else
        -:  506:  #        define CATCH_INTERNAL_CONFIG_CPP17_VARIANT
        -:  507:  #      endif // defined(__GLIBCXX__) && defined(_GLIBCXX_RELEASE) && (_GLIBCXX_RELEASE < 9)
        -:  508:  #    else
        -:  509:  #      define CATCH_INTERNAL_CONFIG_CPP17_VARIANT
        -:  510:  #    endif // defined(__clang__) && (__clang_major__ < 8)
        -:  511:  #  endif // __has_include(<variant>) && defined(CATCH_CPP17_OR_GREATER)
        -:  512:#endif // defined(__has_include)
        -:  513:
        -:  514:
        -:  515:#if defined(CATCH_INTERNAL_CONFIG_COUNTER) && !defined(CATCH_CONFIG_NO_COUNTER) && !defined(CATCH_CONFIG_COUNTER)
        -:  516:#   define CATCH_CONFIG_COUNTER
        -:  517:#endif
        -:  518:#if defined(CATCH_INTERNAL_CONFIG_WINDOWS_SEH) && !defined(CATCH_CONFIG_NO_WINDOWS_SEH) && !defined(CATCH_CONFIG_WINDOWS_SEH) && !defined(CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH)
        -:  519:#   define CATCH_CONFIG_WINDOWS_SEH
        -:  520:#endif
        -:  521:// This is set by default, because we assume that unix compilers are posix-signal-compatible by default.
        -:  522:#if defined(CATCH_INTERNAL_CONFIG_POSIX_SIGNALS) && !defined(CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_POSIX_SIGNALS)
        -:  523:#   define CATCH_CONFIG_POSIX_SIGNALS
        -:  524:#endif
        -:  525:// This is set by default, because we assume that compilers with no wchar_t support are just rare exceptions.
        -:  526:#if !defined(CATCH_INTERNAL_CONFIG_NO_WCHAR) && !defined(CATCH_CONFIG_NO_WCHAR) && !defined(CATCH_CONFIG_WCHAR)
        -:  527:#   define CATCH_CONFIG_WCHAR
        -:  528:#endif
        -:  529:
        -:  530:#if !defined(CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING) && !defined(CATCH_CONFIG_NO_CPP11_TO_STRING) && !defined(CATCH_CONFIG_CPP11_TO_STRING)
        -:  531:#    define CATCH_CONFIG_CPP11_TO_STRING
        -:  532:#endif
        -:  533:
        -:  534:#if defined(CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL) && !defined(CATCH_CONFIG_NO_CPP17_OPTIONAL) && !defined(CATCH_CONFIG_CPP17_OPTIONAL)
        -:  535:#  define CATCH_CONFIG_CPP17_OPTIONAL
        -:  536:#endif
        -:  537:
        -:  538:#if defined(CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW) && !defined(CATCH_CONFIG_NO_CPP17_STRING_VIEW) && !defined(CATCH_CONFIG_CPP17_STRING_VIEW)
        -:  539:#  define CATCH_CONFIG_CPP17_STRING_VIEW
        -:  540:#endif
        -:  541:
        -:  542:#if defined(CATCH_INTERNAL_CONFIG_CPP17_VARIANT) && !defined(CATCH_CONFIG_NO_CPP17_VARIANT) && !defined(CATCH_CONFIG_CPP17_VARIANT)
        -:  543:#  define CATCH_CONFIG_CPP17_VARIANT
        -:  544:#endif
        -:  545:
        -:  546:#if defined(CATCH_INTERNAL_CONFIG_CPP17_BYTE) && !defined(CATCH_CONFIG_NO_CPP17_BYTE) && !defined(CATCH_CONFIG_CPP17_BYTE)
        -:  547:#  define CATCH_CONFIG_CPP17_BYTE
        -:  548:#endif
        -:  549:
        -:  550:
        -:  551:#if defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)
        -:  552:#  define CATCH_INTERNAL_CONFIG_NEW_CAPTURE
        -:  553:#endif
        -:  554:
        -:  555:#if defined(CATCH_INTERNAL_CONFIG_NEW_CAPTURE) && !defined(CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE) && !defined(CATCH_CONFIG_NO_NEW_CAPTURE) && !defined(CATCH_CONFIG_NEW_CAPTURE)
        -:  556:#  define CATCH_CONFIG_NEW_CAPTURE
        -:  557:#endif
        -:  558:
        -:  559:#if !defined(CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED) && !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
        -:  560:#  define CATCH_CONFIG_DISABLE_EXCEPTIONS
        -:  561:#endif
        -:  562:
        -:  563:#if defined(CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN) && !defined(CATCH_CONFIG_NO_POLYFILL_ISNAN) && !defined(CATCH_CONFIG_POLYFILL_ISNAN)
        -:  564:#  define CATCH_CONFIG_POLYFILL_ISNAN
        -:  565:#endif
        -:  566:
        -:  567:#if defined(CATCH_INTERNAL_CONFIG_USE_ASYNC)  && !defined(CATCH_INTERNAL_CONFIG_NO_ASYNC) && !defined(CATCH_CONFIG_NO_USE_ASYNC) && !defined(CATCH_CONFIG_USE_ASYNC)
        -:  568:#  define CATCH_CONFIG_USE_ASYNC
        -:  569:#endif
        -:  570:
        -:  571:#if defined(CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE) && !defined(CATCH_CONFIG_NO_ANDROID_LOGWRITE) && !defined(CATCH_CONFIG_ANDROID_LOGWRITE)
        -:  572:#  define CATCH_CONFIG_ANDROID_LOGWRITE
        -:  573:#endif
        -:  574:
        -:  575:#if defined(CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER) && !defined(CATCH_CONFIG_NO_GLOBAL_NEXTAFTER) && !defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
        -:  576:#  define CATCH_CONFIG_GLOBAL_NEXTAFTER
        -:  577:#endif
        -:  578:
        -:  579:
        -:  580:// Even if we do not think the compiler has that warning, we still have
        -:  581:// to provide a macro that can be used by the code.
        -:  582:#if !defined(CATCH_INTERNAL_START_WARNINGS_SUPPRESSION)
        -:  583:#   define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION
        -:  584:#endif
        -:  585:#if !defined(CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION)
        -:  586:#   define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -:  587:#endif
        -:  588:#if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS)
        -:  589:#   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS
        -:  590:#endif
        -:  591:#if !defined(CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS)
        -:  592:#   define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS
        -:  593:#endif
        -:  594:#if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS)
        -:  595:#   define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS
        -:  596:#endif
        -:  597:#if !defined(CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS)
        -:  598:#   define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS
        -:  599:#endif
        -:  600:
        -:  601:// The goal of this macro is to avoid evaluation of the arguments, but
        -:  602:// still have the compiler warn on problems inside...
        -:  603:#if !defined(CATCH_INTERNAL_IGNORE_BUT_WARN)
        -:  604:#   define CATCH_INTERNAL_IGNORE_BUT_WARN(...)
        -:  605:#endif
        -:  606:
        -:  607:#if defined(__APPLE__) && defined(__apple_build_version__) && (__clang_major__ < 10)
        -:  608:#   undef CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS
        -:  609:#elif defined(__clang__) && (__clang_major__ < 5)
        -:  610:#   undef CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS
        -:  611:#endif
        -:  612:
        -:  613:#if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS)
        -:  614:#   define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS
        -:  615:#endif
        -:  616:
        -:  617:#if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
        -:  618:#define CATCH_TRY if ((true))
        -:  619:#define CATCH_CATCH_ALL if ((false))
        -:  620:#define CATCH_CATCH_ANON(type) if ((false))
        -:  621:#else
        -:  622:#define CATCH_TRY try
        -:  623:#define CATCH_CATCH_ALL catch (...)
        -:  624:#define CATCH_CATCH_ANON(type) catch (type)
        -:  625:#endif
        -:  626:
        -:  627:#if defined(CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR) && !defined(CATCH_CONFIG_NO_TRADITIONAL_MSVC_PREPROCESSOR) && !defined(CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR)
        -:  628:#define CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -:  629:#endif
        -:  630:
        -:  631:#endif // CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED
        -:  632:
        -:  633:
        -:  634:#ifndef CATCH_STRINGREF_HPP_INCLUDED
        -:  635:#define CATCH_STRINGREF_HPP_INCLUDED
        -:  636:
        -:  637:#include <cstddef>
        -:  638:#include <string>
        -:  639:#include <iosfwd>
        -:  640:#include <cassert>
        -:  641:
        -:  642:namespace Catch {
        -:  643:
        -:  644:    /// A non-owning string class (similar to the forthcoming std::string_view)
        -:  645:    /// Note that, because a StringRef may be a substring of another string,
        -:  646:    /// it may not be null terminated.
        -:  647:    class StringRef {
        -:  648:    public:
        -:  649:        using size_type = std::size_t;
        -:  650:        using const_iterator = const char*;
        -:  651:
        -:  652:    private:
        -:  653:        static constexpr char const* const s_empty = "";
        -:  654:
        -:  655:        char const* m_start = s_empty;
        -:  656:        size_type m_size = 0;
        -:  657:
        -:  658:    public: // construction
        1:  659:        constexpr StringRef() noexcept = default;
        -:  660:
        -:  661:        StringRef( char const* rawChars ) noexcept;
        -:  662:
        -:  663:        constexpr StringRef( char const* rawChars, size_type size ) noexcept
        -:  664:        :   m_start( rawChars ),
        3:  665:            m_size( size )
        -:  666:        {}
        -:  667:
        -:  668:        StringRef( std::string const& stdString ) noexcept
        -:  669:        :   m_start( stdString.c_str() ),
        1:  670:            m_size( stdString.size() )
        -:  671:        {}
        -:  672:
        -:  673:        explicit operator std::string() const {
        1:  674:            return std::string(m_start, m_size);
        -:  675:        }
        -:  676:
        -:  677:    public: // operators
        -:  678:        auto operator == ( StringRef const& other ) const noexcept -> bool;
        -:  679:        auto operator != (StringRef const& other) const noexcept -> bool {
        -:  680:            return !(*this == other);
        -:  681:        }
        -:  682:
        -:  683:        constexpr auto operator[] ( size_type index ) const noexcept -> char {
       27:  684:            assert(index < m_size);
       23:  685:            return m_start[index];
        -:  686:        }
        -:  687:
        -:  688:        bool operator<(StringRef const& rhs) const noexcept;
        -:  689:
        -:  690:    public: // named queries
        -:  691:        constexpr auto empty() const noexcept -> bool {
        -:  692:            return m_size == 0;
        -:  693:        }
        -:  694:        constexpr auto size() const noexcept -> size_type {
        -:  695:            return m_size;
        -:  696:        }
        -:  697:
        -:  698:        // Returns the current start pointer. If the StringRef is not
        -:  699:        // null-terminated, throws std::domain_exception
        -:  700:        auto c_str() const -> char const*;
        -:  701:
        -:  702:    public: // substrings and searches
        -:  703:        // Returns a substring of [start, start + length).
        -:  704:        // If start + length > size(), then the substring is [start, start + size()).
        -:  705:        // If start > size(), then the substring is empty.
        -:  706:        constexpr StringRef substr(size_type start, size_type length) const noexcept {
        2:  707:            if (start < m_size) {
        2:  708:                const auto shortened_size = m_size - start;
        2:  709:                return StringRef(m_start + start, (shortened_size < length) ? shortened_size : length);
        -:  710:            } else {
    #####:  711:                return StringRef();
        -:  712:            }
        -:  713:        }
        -:  714:
        -:  715:        // Returns the current start pointer. May not be null-terminated.
        -:  716:        constexpr char const* data() const noexcept {
        -:  717:            return m_start;
        -:  718:        }
        -:  719:
        -:  720:        constexpr auto isNullTerminated() const noexcept -> bool {
    #####:  721:            return m_start[m_size] == '\0';
        -:  722:        }
        -:  723:
        -:  724:    public: // iterators
        -:  725:        constexpr const_iterator begin() const { return m_start; }
        -:  726:        constexpr const_iterator end() const { return m_start + m_size; }
        -:  727:
        -:  728:
        -:  729:        friend std::string& operator += (std::string& lhs, StringRef const& sr);
        -:  730:        friend std::ostream& operator << (std::ostream& os, StringRef const& sr);
        -:  731:        friend std::string operator+(StringRef lhs, StringRef rhs);
        -:  732:    };
        -:  733:
        -:  734:
        -:  735:    constexpr auto operator "" _sr( char const* rawChars, std::size_t size ) noexcept -> StringRef {
        -:  736:        return StringRef( rawChars, size );
        -:  737:    }
        -:  738:} // namespace Catch
        -:  739:
        -:  740:constexpr auto operator "" _catch_sr( char const* rawChars, std::size_t size ) noexcept -> Catch::StringRef {
        -:  741:    return Catch::StringRef( rawChars, size );
        -:  742:}
        -:  743:
        -:  744:#endif // CATCH_STRINGREF_HPP_INCLUDED
        -:  745:
        -:  746:#define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line
        -:  747:#define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )
        -:  748:#ifdef CATCH_CONFIG_COUNTER
        -:  749:#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )
        -:  750:#else
        -:  751:#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )
        -:  752:#endif
        -:  753:
        -:  754:#include <iosfwd>
        -:  755:
        -:  756:// We need a dummy global operator<< so we can bring it into Catch namespace later
        -:  757:struct Catch_global_namespace_dummy {};
        -:  758:std::ostream& operator<<(std::ostream&, Catch_global_namespace_dummy);
        -:  759:
        -:  760:namespace Catch {
        -:  761:
        -:  762:    struct SourceLineInfo {
        -:  763:
        -:  764:        SourceLineInfo() = delete;
        -:  765:        constexpr SourceLineInfo( char const* _file, std::size_t _line ) noexcept:
        -:  766:            file( _file ),
        1:  767:            line( _line )
        -:  768:        {}
        -:  769:
        -:  770:        bool operator == ( SourceLineInfo const& other ) const noexcept;
        -:  771:        bool operator < ( SourceLineInfo const& other ) const noexcept;
        -:  772:
        -:  773:        char const* file;
        -:  774:        std::size_t line;
        -:  775:
        -:  776:        friend std::ostream& operator << (std::ostream& os, SourceLineInfo const& info);
        -:  777:    };
        -:  778:
        -:  779:
        -:  780:    // Bring in operator<< from global namespace into Catch namespace
        -:  781:    // This is necessary because the overload of operator<< above makes
        -:  782:    // lookup stop at namespace Catch
        -:  783:    using ::operator<<;
        -:  784:
        -:  785:    // Use this in variadic streaming macros to allow
        -:  786:    //    >> +StreamEndStop
        -:  787:    // as well as
        -:  788:    //    >> stuff +StreamEndStop
        -:  789:    struct StreamEndStop {
        -:  790:        StringRef operator+() const {
        -:  791:            return StringRef();
        -:  792:        }
        -:  793:
        -:  794:        template<typename T>
        -:  795:        friend T const& operator + ( T const& value, StreamEndStop ) {
        -:  796:            return value;
        -:  797:        }
        -:  798:    };
        -:  799:}
        -:  800:
        -:  801:#define CATCH_INTERNAL_LINEINFO \
        -:  802:    ::Catch::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )
        -:  803:
        -:  804:#endif // CATCH_COMMON_HPP_INCLUDED
        -:  805:
        -:  806:
        -:  807:#ifndef CATCH_TOTALS_HPP_INCLUDED
        -:  808:#define CATCH_TOTALS_HPP_INCLUDED
        -:  809:
        -:  810:#include <cstddef>
        -:  811:
        -:  812:namespace Catch {
        -:  813:
        1:  814:    struct Counts {
        -:  815:        Counts operator - ( Counts const& other ) const;
        -:  816:        Counts& operator += ( Counts const& other );
        -:  817:
        -:  818:        std::size_t total() const;
        -:  819:        bool allPassed() const;
        -:  820:        bool allOk() const;
        -:  821:
        -:  822:        std::size_t passed = 0;
        -:  823:        std::size_t failed = 0;
        -:  824:        std::size_t failedButOk = 0;
        -:  825:    };
        -:  826:
        1:  827:    struct Totals {
        -:  828:
        -:  829:        Totals operator - ( Totals const& other ) const;
        -:  830:        Totals& operator += ( Totals const& other );
        -:  831:
        -:  832:        Totals delta( Totals const& prevTotals ) const;
        -:  833:
        -:  834:        int error = 0;
        -:  835:        Counts assertions;
        -:  836:        Counts testCases;
        -:  837:    };
        -:  838:}
        -:  839:
        -:  840:#endif // CATCH_TOTALS_HPP_INCLUDED
        -:  841:
        -:  842:#include <string>
        -:  843:
        -:  844:namespace Catch {
        -:  845:
        6:  846:    struct SectionInfo {
        -:  847:        // The last argument is ignored, so that people can write
        -:  848:        // SECTION("ShortName", "Proper description that is long") and
        -:  849:        // still use the `-c` flag comfortably.
        -:  850:        SectionInfo( SourceLineInfo const& _lineInfo, std::string _name,
        -:  851:                    const char* const = nullptr ):
        -:  852:            name(std::move(_name)),
        1:  853:            lineInfo(_lineInfo)
        -:  854:            {}
        -:  855:
        -:  856:        std::string name;
        -:  857:        SourceLineInfo lineInfo;
        -:  858:    };
        -:  859:
    #####:  860:    struct SectionEndInfo {
        -:  861:        SectionInfo sectionInfo;
        -:  862:        Counts prevAssertions;
        -:  863:        double durationInSeconds;
        -:  864:    };
        -:  865:
        -:  866:} // end namespace Catch
        -:  867:
        -:  868:#endif // CATCH_SECTION_INFO_HPP_INCLUDED
        -:  869:
        -:  870:
        -:  871:#ifndef CATCH_ASSERTION_RESULT_HPP_INCLUDED
        -:  872:#define CATCH_ASSERTION_RESULT_HPP_INCLUDED
        -:  873:
        -:  874:#include <string>
        -:  875:
        -:  876:
        -:  877:#ifndef CATCH_ASSERTION_INFO_HPP_INCLUDED
        -:  878:#define CATCH_ASSERTION_INFO_HPP_INCLUDED
        -:  879:
        -:  880:
        -:  881:
        -:  882:#ifndef CATCH_RESULT_TYPE_HPP_INCLUDED
        -:  883:#define CATCH_RESULT_TYPE_HPP_INCLUDED
        -:  884:
        -:  885:namespace Catch {
        -:  886:
        -:  887:    // ResultWas::OfType enum
        -:  888:    struct ResultWas { enum OfType {
        -:  889:        Unknown = -1,
        -:  890:        Ok = 0,
        -:  891:        Info = 1,
        -:  892:        Warning = 2,
        -:  893:
        -:  894:        FailureBit = 0x10,
        -:  895:
        -:  896:        ExpressionFailed = FailureBit | 1,
        -:  897:        ExplicitFailure = FailureBit | 2,
        -:  898:
        -:  899:        Exception = 0x100 | FailureBit,
        -:  900:
        -:  901:        ThrewException = Exception | 1,
        -:  902:        DidntThrowException = Exception | 2,
        -:  903:
        -:  904:        FatalErrorCondition = 0x200 | FailureBit
        -:  905:
        -:  906:    }; };
        -:  907:
        -:  908:    bool isOk( ResultWas::OfType resultType );
        -:  909:    bool isJustInfo( int flags );
        -:  910:
        -:  911:
        -:  912:    // ResultDisposition::Flags enum
        -:  913:    struct ResultDisposition { enum Flags {
        -:  914:        Normal = 0x01,
        -:  915:
        -:  916:        ContinueOnFailure = 0x02,   // Failures fail test, but execution continues
        -:  917:        FalseTest = 0x04,           // Prefix expression with !
        -:  918:        SuppressFail = 0x08         // Failures are reported but do not fail the test
        -:  919:    }; };
        -:  920:
        -:  921:    ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs );
        -:  922:
        -:  923:    bool shouldContinueOnFailure( int flags );
        4:  924:    inline bool isFalseTest( int flags ) { return ( flags & ResultDisposition::FalseTest ) != 0; }
        -:  925:    bool shouldSuppressFailure( int flags );
        -:  926:
        -:  927:} // end namespace Catch
        -:  928:
        -:  929:#endif // CATCH_RESULT_TYPE_HPP_INCLUDED
        -:  930:
        -:  931:namespace Catch {
        -:  932:
        -:  933:    struct AssertionInfo {
        -:  934:        // AssertionInfo() = delete;
        -:  935:
        -:  936:        StringRef macroName;
        -:  937:        SourceLineInfo lineInfo;
        -:  938:        StringRef capturedExpression;
        -:  939:        ResultDisposition::Flags resultDisposition;
        -:  940:    };
        -:  941:
        -:  942:} // end namespace Catch
        -:  943:
        -:  944:#endif // CATCH_ASSERTION_INFO_HPP_INCLUDED
        -:  945:
        -:  946:
        -:  947:#ifndef CATCH_LAZY_EXPR_HPP_INCLUDED
        -:  948:#define CATCH_LAZY_EXPR_HPP_INCLUDED
        -:  949:
        -:  950:#include <iosfwd>
        -:  951:
        -:  952:namespace Catch {
        -:  953:        
        -:  954:    struct ITransientExpression;
        -:  955:
        -:  956:    class LazyExpression {
        -:  957:        friend class AssertionHandler;
        -:  958:        friend struct AssertionStats;
        -:  959:        friend class RunContext;
        -:  960:
        -:  961:        ITransientExpression const* m_transientExpression = nullptr;
        -:  962:        bool m_isNegated;
        -:  963:    public:
        -:  964:        LazyExpression( bool isNegated ):
    #####:  965:            m_isNegated(isNegated)
        -:  966:        {}
        -:  967:        LazyExpression(LazyExpression const& other) = default;
        -:  968:        LazyExpression& operator = ( LazyExpression const& ) = delete;
        -:  969:
        -:  970:        explicit operator bool() const {
        -:  971:            return m_transientExpression != nullptr;
        -:  972:        }
        -:  973:
        -:  974:        friend auto operator << ( std::ostream& os, LazyExpression const& lazyExpr ) -> std::ostream&;
        -:  975:    };
        -:  976:
        -:  977:} // namespace Catch
        -:  978:
        -:  979:#endif // CATCH_LAZY_EXPR_HPP_INCLUDED
        -:  980:
        -:  981:namespace Catch {
        -:  982:
    #####:  983:    struct AssertionResultData
        -:  984:    {
        -:  985:        AssertionResultData() = delete;
        -:  986:
        -:  987:        AssertionResultData( ResultWas::OfType _resultType, LazyExpression const& _lazyExpression );
        -:  988:
        -:  989:        std::string message;
        -:  990:        mutable std::string reconstructedExpression;
        -:  991:        LazyExpression lazyExpression;
        -:  992:        ResultWas::OfType resultType;
        -:  993:
        -:  994:        std::string reconstructExpression() const;
        -:  995:    };
        -:  996:
    #####:  997:    class AssertionResult {
        -:  998:    public:
        -:  999:        AssertionResult() = delete;
        -: 1000:        AssertionResult( AssertionInfo const& info, AssertionResultData const& data );
        -: 1001:
        -: 1002:        bool isOk() const;
        -: 1003:        bool succeeded() const;
        -: 1004:        ResultWas::OfType getResultType() const;
        -: 1005:        bool hasExpression() const;
        -: 1006:        bool hasMessage() const;
        -: 1007:        std::string getExpression() const;
        -: 1008:        std::string getExpressionInMacro() const;
        -: 1009:        bool hasExpandedExpression() const;
        -: 1010:        std::string getExpandedExpression() const;
        -: 1011:        std::string getMessage() const;
        -: 1012:        SourceLineInfo getSourceInfo() const;
        -: 1013:        StringRef getTestMacroName() const;
        -: 1014:
        -: 1015:    //protected:
        -: 1016:        AssertionInfo m_info;
        -: 1017:        AssertionResultData m_resultData;
        -: 1018:    };
        -: 1019:
        -: 1020:} // end namespace Catch
        -: 1021:
        -: 1022:#endif // CATCH_ASSERTION_RESULT_HPP_INCLUDED
        -: 1023:
        -: 1024:
        -: 1025:#ifndef CATCH_MESSAGE_INFO_HPP_INCLUDED
        -: 1026:#define CATCH_MESSAGE_INFO_HPP_INCLUDED
        -: 1027:
        -: 1028:
        -: 1029:
        -: 1030:#ifndef CATCH_INTERFACES_CAPTURE_HPP_INCLUDED
        -: 1031:#define CATCH_INTERFACES_CAPTURE_HPP_INCLUDED
        -: 1032:
        -: 1033:#include <string>
        -: 1034:#include <chrono>
        -: 1035:
        -: 1036:
        -: 1037:namespace Catch {
        -: 1038:
        -: 1039:    class AssertionResult;
        -: 1040:    struct AssertionInfo;
        -: 1041:    struct SectionInfo;
        -: 1042:    struct SectionEndInfo;
        -: 1043:    struct MessageInfo;
        -: 1044:    struct MessageBuilder;
        -: 1045:    struct Counts;
        -: 1046:    struct AssertionReaction;
        -: 1047:    struct SourceLineInfo;
        -: 1048:
        -: 1049:    struct ITransientExpression;
        -: 1050:    struct IGeneratorTracker;
        -: 1051:
        -: 1052:    struct BenchmarkInfo;
        -: 1053:    template <typename Duration = std::chrono::duration<double, std::nano>>
        -: 1054:    struct BenchmarkStats;
        -: 1055:
        2: 1056:    struct IResultCapture {
        -: 1057:
        -: 1058:        virtual ~IResultCapture();
        -: 1059:
        -: 1060:        virtual bool sectionStarted(    SectionInfo const& sectionInfo,
        -: 1061:                                        Counts& assertions ) = 0;
        -: 1062:        virtual void sectionEnded( SectionEndInfo const& endInfo ) = 0;
        -: 1063:        virtual void sectionEndedEarly( SectionEndInfo const& endInfo ) = 0;
        -: 1064:
        -: 1065:        virtual auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const& lineInfo ) -> IGeneratorTracker& = 0;
        -: 1066:
        -: 1067:        virtual void benchmarkPreparing( std::string const& name ) = 0;
        -: 1068:        virtual void benchmarkStarting( BenchmarkInfo const& info ) = 0;
        -: 1069:        virtual void benchmarkEnded( BenchmarkStats<> const& stats ) = 0;
        -: 1070:        virtual void benchmarkFailed( std::string const& error ) = 0;
        -: 1071:
        -: 1072:        virtual void pushScopedMessage( MessageInfo const& message ) = 0;
        -: 1073:        virtual void popScopedMessage( MessageInfo const& message ) = 0;
        -: 1074:
        -: 1075:        virtual void emplaceUnscopedMessage( MessageBuilder const& builder ) = 0;
        -: 1076:
        -: 1077:        virtual void handleFatalErrorCondition( StringRef message ) = 0;
        -: 1078:
        -: 1079:        virtual void handleExpr
        -: 1080:                (   AssertionInfo const& info,
        -: 1081:                    ITransientExpression const& expr,
        -: 1082:                    AssertionReaction& reaction ) = 0;
        -: 1083:        virtual void handleMessage
        -: 1084:                (   AssertionInfo const& info,
        -: 1085:                    ResultWas::OfType resultType,
        -: 1086:                    StringRef const& message,
        -: 1087:                    AssertionReaction& reaction ) = 0;
        -: 1088:        virtual void handleUnexpectedExceptionNotThrown
        -: 1089:                (   AssertionInfo const& info,
        -: 1090:                    AssertionReaction& reaction ) = 0;
        -: 1091:        virtual void handleUnexpectedInflightException
        -: 1092:                (   AssertionInfo const& info,
        -: 1093:                    std::string const& message,
        -: 1094:                    AssertionReaction& reaction ) = 0;
        -: 1095:        virtual void handleIncomplete
        -: 1096:                (   AssertionInfo const& info ) = 0;
        -: 1097:        virtual void handleNonExpr
        -: 1098:                (   AssertionInfo const &info,
        -: 1099:                    ResultWas::OfType resultType,
        -: 1100:                    AssertionReaction &reaction ) = 0;
        -: 1101:
        -: 1102:
        -: 1103:
        -: 1104:        virtual bool lastAssertionPassed() = 0;
        -: 1105:        virtual void assertionPassed() = 0;
        -: 1106:
        -: 1107:        // Deprecated, do not use:
        -: 1108:        virtual std::string getCurrentTestName() const = 0;
        -: 1109:        virtual const AssertionResult* getLastResult() const = 0;
        -: 1110:        virtual void exceptionEarlyReported() = 0;
        -: 1111:    };
        -: 1112:
        -: 1113:    IResultCapture& getResultCapture();
        -: 1114:}
        -: 1115:
        -: 1116:#endif // CATCH_INTERFACES_CAPTURE_HPP_INCLUDED
        -: 1117:
        -: 1118:#include <string>
        -: 1119:
        -: 1120:namespace Catch {
        -: 1121:
    #####: 1122:    struct MessageInfo {
        -: 1123:        MessageInfo(    StringRef const& _macroName,
        -: 1124:                        SourceLineInfo const& _lineInfo,
        -: 1125:                        ResultWas::OfType _type );
        -: 1126:
        -: 1127:        StringRef macroName;
        -: 1128:        std::string message;
        -: 1129:        SourceLineInfo lineInfo;
        -: 1130:        ResultWas::OfType type;
        -: 1131:        unsigned int sequence;
        -: 1132:
        -: 1133:        bool operator == (MessageInfo const& other) const {
        -: 1134:            return sequence == other.sequence;
        -: 1135:        }
        -: 1136:        bool operator < (MessageInfo const& other) const {
        -: 1137:            return sequence < other.sequence;
        -: 1138:        }
        -: 1139:    private:
        -: 1140:        static unsigned int globalCount;
        -: 1141:    };
        -: 1142:
        -: 1143:} // end namespace Catch
        -: 1144:
        -: 1145:#endif // CATCH_MESSAGE_INFO_HPP_INCLUDED
        -: 1146:
        -: 1147:
        -: 1148:#ifndef CATCH_UNIQUE_PTR_HPP_INCLUDED
        -: 1149:#define CATCH_UNIQUE_PTR_HPP_INCLUDED
        -: 1150:
        -: 1151:#include <cassert>
        -: 1152:#include <type_traits>
        -: 1153:
        -: 1154:namespace Catch {
        -: 1155:namespace Detail {
        -: 1156:    // reimplementation of unique_ptr for improved compilation times
        -: 1157:    // Does not support custom deleters (and thus does not require EBO)
        -: 1158:    // Does not support arrays
        -: 1159:    template <typename T>
        -: 1160:    class unique_ptr {
        -: 1161:        T* m_ptr;
        -: 1162:    public:
        -: 1163:        constexpr unique_ptr(std::nullptr_t = nullptr):
        9: 1164:            m_ptr{}
        -: 1165:        {}
        -: 1166:        explicit constexpr unique_ptr(T* ptr):
        7: 1167:            m_ptr(ptr)
        -: 1168:        {}
        -: 1169:
        -: 1170:        template <typename U, typename = std::enable_if_t<std::is_base_of<T, U>::value>>
        -: 1171:        unique_ptr(unique_ptr<U>&& from):
        1: 1172:            m_ptr(from.release())
        -: 1173:        {}
        -: 1174:
        -: 1175:        template <typename U, typename = std::enable_if_t<std::is_base_of<T, U>::value>>
        -: 1176:        unique_ptr& operator=(unique_ptr<U>&& from) {
        -: 1177:            reset(from.release());
        -: 1178:
        -: 1179:            return *this;
        -: 1180:        }
        -: 1181:
        -: 1182:        unique_ptr(unique_ptr const&) = delete;
        -: 1183:        unique_ptr& operator=(unique_ptr const&) = delete;
        -: 1184:
        -: 1185:        unique_ptr(unique_ptr&& rhs) noexcept:
        6: 1186:            m_ptr(rhs.m_ptr) {
        6: 1187:            rhs.m_ptr = nullptr;
        -: 1188:        }
        -: 1189:        unique_ptr& operator=(unique_ptr&& rhs) noexcept {
        -: 1190:            reset(rhs.release());
        -: 1191:
        -: 1192:            return *this;
        -: 1193:        }
        -: 1194:
        4: 1195:        ~unique_ptr() {
       23: 1196:            delete m_ptr;
       23: 1197:        }
        -: 1198:
        -: 1199:        T& operator*() {
        3: 1200:            assert(m_ptr);
        -: 1201:            return *m_ptr;
        -: 1202:        }
        -: 1203:        T const& operator*() const {
        -: 1204:            assert(m_ptr);
        -: 1205:            return *m_ptr;
        -: 1206:        }
        -: 1207:        T* operator->() const noexcept {
       29: 1208:            assert(m_ptr);
        -: 1209:            return m_ptr;
        -: 1210:        }
        -: 1211:
        8: 1212:        T* get() { return m_ptr; }
        -: 1213:        T const* get() const { return m_ptr; }
        -: 1214:
        -: 1215:        void reset(T* ptr = nullptr) {
       10: 1216:            delete m_ptr;
       10: 1217:            m_ptr = ptr;
        -: 1218:        }
        -: 1219:
        -: 1220:        T* release() {
        2: 1221:            auto temp = m_ptr;
        1: 1222:            m_ptr = nullptr;
        -: 1223:            return temp;
        -: 1224:        }
        -: 1225:
        -: 1226:        explicit operator bool() const {
        2: 1227:            return m_ptr;
        -: 1228:        }
        -: 1229:
        -: 1230:        friend void swap(unique_ptr& lhs, unique_ptr& rhs) {
        -: 1231:            auto temp = lhs.m_ptr;
        -: 1232:            lhs.m_ptr = rhs.m_ptr;
        -: 1233:            rhs.m_ptr = temp;
        -: 1234:        }
        -: 1235:    };
        -: 1236:
        -: 1237:    // Purposefully doesn't exist
        -: 1238:    // We could also rely on compiler warning + werror for calling plain delete
        -: 1239:    // on a T[], but this seems better.
        -: 1240:    // Maybe add definition and a static assert?
        -: 1241:    template <typename T>
        -: 1242:    class unique_ptr<T[]>;
        -: 1243:
        -: 1244:    template <typename T, typename... Args>
        2: 1245:    unique_ptr<T> make_unique(Args&&... args) {
        -: 1246:        // static_cast<Args&&> does the same thing as std::forward in
        -: 1247:        // this case, but does not require including big header (<utility>)
        -: 1248:        // and compiles faster thanks to not requiring template instantiation
        -: 1249:        // and overload resolution
       12: 1250:        return unique_ptr<T>(new T(static_cast<Args&&>(args)...));
        -: 1251:    }
        -: 1252:
        -: 1253:
        -: 1254:} // end namespace Detail
        -: 1255:} // end namespace Catch
        -: 1256:
        -: 1257:#endif // CATCH_UNIQUE_PTR_HPP_INCLUDED
        -: 1258:
        -: 1259:
        -: 1260:
        -: 1261:// Adapted from donated nonius code.
        -: 1262:
        -: 1263:#ifndef CATCH_ESTIMATE_HPP_INCLUDED
        -: 1264:#define CATCH_ESTIMATE_HPP_INCLUDED
        -: 1265:
        -: 1266:namespace Catch {
        -: 1267:    namespace Benchmark {
        -: 1268:        template <typename Duration>
        -: 1269:        struct Estimate {
        -: 1270:            Duration point;
        -: 1271:            Duration lower_bound;
        -: 1272:            Duration upper_bound;
        -: 1273:            double confidence_interval;
        -: 1274:
        -: 1275:            template <typename Duration2>
        -: 1276:            operator Estimate<Duration2>() const {
        -: 1277:                return { point, lower_bound, upper_bound, confidence_interval };
        -: 1278:            }
        -: 1279:        };
        -: 1280:    } // namespace Benchmark
        -: 1281:} // namespace Catch
        -: 1282:
        -: 1283:#endif // CATCH_ESTIMATE_HPP_INCLUDED
        -: 1284:
        -: 1285:
        -: 1286:// Adapted from donated nonius code.
        -: 1287:
        -: 1288:#ifndef CATCH_OUTLIER_CLASSIFICATION_HPP_INCLUDED
        -: 1289:#define CATCH_OUTLIER_CLASSIFICATION_HPP_INCLUDED
        -: 1290:
        -: 1291:namespace Catch {
        -: 1292:    namespace Benchmark {
        -: 1293:        struct OutlierClassification {
        -: 1294:            int samples_seen = 0;
        -: 1295:            int low_severe = 0;     // more than 3 times IQR below Q1
        -: 1296:            int low_mild = 0;       // 1.5 to 3 times IQR below Q1
        -: 1297:            int high_mild = 0;      // 1.5 to 3 times IQR above Q3
        -: 1298:            int high_severe = 0;    // more than 3 times IQR above Q3
        -: 1299:
        -: 1300:            int total() const {
        -: 1301:                return low_severe + low_mild + high_mild + high_severe;
        -: 1302:            }
        -: 1303:        };
        -: 1304:    } // namespace Benchmark
        -: 1305:} // namespace Catch
        -: 1306:
        -: 1307:#endif // CATCH_OUTLIERS_CLASSIFICATION_HPP_INCLUDED
        -: 1308:
        -: 1309:
        -: 1310:#include <string>
        -: 1311:#include <vector>
        -: 1312:#include <iosfwd>
        -: 1313:
        -: 1314:namespace Catch {
        -: 1315:
        -: 1316:    struct ReporterDescription;
        -: 1317:    struct TagInfo;
        -: 1318:    struct TestCaseInfo;
        -: 1319:    class TestCaseHandle;
        -: 1320:    struct IConfig;
        -: 1321:
        -: 1322:    struct ReporterConfig {
        -: 1323:        explicit ReporterConfig( IConfig const* _fullConfig );
        -: 1324:
        -: 1325:        ReporterConfig( IConfig const* _fullConfig, std::ostream& _stream );
        -: 1326:
        -: 1327:        std::ostream& stream() const;
        -: 1328:        IConfig const* fullConfig() const;
        -: 1329:
        -: 1330:    private:
        -: 1331:        std::ostream* m_stream;
        -: 1332:        IConfig const* m_fullConfig;
        -: 1333:    };
        -: 1334:
        4: 1335:    struct TestRunInfo {
        -: 1336:        TestRunInfo( std::string const& _name );
        -: 1337:        std::string name;
        -: 1338:    };
        8: 1339:    struct GroupInfo {
        -: 1340:        GroupInfo(  std::string const& _name,
        -: 1341:                    std::size_t _groupIndex,
        -: 1342:                    std::size_t _groupsCount );
        -: 1343:
        -: 1344:        std::string name;
        -: 1345:        std::size_t groupIndex;
        -: 1346:        std::size_t groupsCounts;
        -: 1347:    };
        -: 1348:
    #####: 1349:    struct AssertionStats {
        -: 1350:        AssertionStats( AssertionResult const& _assertionResult,
        -: 1351:                        std::vector<MessageInfo> const& _infoMessages,
        -: 1352:                        Totals const& _totals );
        -: 1353:
    #####: 1354:        AssertionStats( AssertionStats const& )              = default;
    #####: 1355:        AssertionStats( AssertionStats && )                  = default;
        -: 1356:        AssertionStats& operator = ( AssertionStats const& ) = delete;
        -: 1357:        AssertionStats& operator = ( AssertionStats && )     = delete;
        -: 1358:
        -: 1359:        AssertionResult assertionResult;
        -: 1360:        std::vector<MessageInfo> infoMessages;
        -: 1361:        Totals totals;
        -: 1362:    };
        -: 1363:
        1: 1364:    struct SectionStats {
        -: 1365:        SectionStats(   SectionInfo const& _sectionInfo,
        -: 1366:                        Counts const& _assertions,
        -: 1367:                        double _durationInSeconds,
        -: 1368:                        bool _missingAssertions );
        -: 1369:
        -: 1370:        SectionInfo sectionInfo;
        -: 1371:        Counts assertions;
        -: 1372:        double durationInSeconds;
        -: 1373:        bool missingAssertions;
        -: 1374:    };
        -: 1375:
        2: 1376:    struct TestCaseStats {
        -: 1377:        TestCaseStats(  TestCaseInfo const& _testInfo,
        -: 1378:                        Totals const& _totals,
        -: 1379:                        std::string const& _stdOut,
        -: 1380:                        std::string const& _stdErr,
        -: 1381:                        bool _aborting );
        -: 1382:
        -: 1383:        TestCaseInfo const * testInfo;
        -: 1384:        Totals totals;
        -: 1385:        std::string stdOut;
        -: 1386:        std::string stdErr;
        -: 1387:        bool aborting;
        -: 1388:    };
        -: 1389:
        1: 1390:    struct TestGroupStats {
        -: 1391:        TestGroupStats( GroupInfo const& _groupInfo,
        -: 1392:                        Totals const& _totals,
        -: 1393:                        bool _aborting );
        -: 1394:        TestGroupStats( GroupInfo const& _groupInfo );
        -: 1395:
        -: 1396:        GroupInfo groupInfo;
        -: 1397:        Totals totals;
        -: 1398:        bool aborting;
        -: 1399:    };
        -: 1400:
        1: 1401:    struct TestRunStats {
        -: 1402:        TestRunStats(   TestRunInfo const& _runInfo,
        -: 1403:                        Totals const& _totals,
        -: 1404:                        bool _aborting );
        -: 1405:
        -: 1406:        TestRunInfo runInfo;
        -: 1407:        Totals totals;
        -: 1408:        bool aborting;
        -: 1409:    };
        -: 1410:
        -: 1411:
        -: 1412:    struct BenchmarkInfo {
        -: 1413:        std::string name;
        -: 1414:        double estimatedDuration;
        -: 1415:        int iterations;
        -: 1416:        int samples;
        -: 1417:        unsigned int resamples;
        -: 1418:        double clockResolution;
        -: 1419:        double clockCost;
        -: 1420:    };
        -: 1421:
        -: 1422:    template <class Duration>
        -: 1423:    struct BenchmarkStats {
        -: 1424:        BenchmarkInfo info;
        -: 1425:
        -: 1426:        std::vector<Duration> samples;
        -: 1427:        Benchmark::Estimate<Duration> mean;
        -: 1428:        Benchmark::Estimate<Duration> standardDeviation;
        -: 1429:        Benchmark::OutlierClassification outliers;
        -: 1430:        double outlierVariance;
        -: 1431:
        -: 1432:        template <typename Duration2>
        -: 1433:        operator BenchmarkStats<Duration2>() const {
        -: 1434:            std::vector<Duration2> samples2;
        -: 1435:            samples2.reserve(samples.size());
        -: 1436:            for (auto const& sample : samples) {
        -: 1437:                samples2.push_back(Duration2(sample));
        -: 1438:            }
        -: 1439:            return {
        -: 1440:                info,
        -: 1441:                std::move(samples2),
        -: 1442:                mean,
        -: 1443:                standardDeviation,
        -: 1444:                outliers,
        -: 1445:                outlierVariance,
        -: 1446:            };
        -: 1447:        }
        -: 1448:    };
        -: 1449:
        -: 1450:    //! By setting up its preferences, a reporter can modify Catch2's behaviour
        -: 1451:    //! in some regards, e.g. it can request Catch2 to capture writes to
        -: 1452:    //! stdout/stderr during test execution, and pass them to the reporter.
        1: 1453:    struct ReporterPreferences {
        -: 1454:        //! Catch2 should redirect writes to stdout and pass them to the
        -: 1455:        //! reporter
        -: 1456:        bool shouldRedirectStdOut = false;
        -: 1457:        //! Catch2 should call `Reporter::assertionEnded` even for passing
        -: 1458:        //! assertions
        -: 1459:        bool shouldReportAllAssertions = false;
        -: 1460:    };
        -: 1461:
        -: 1462:
        1: 1463:    struct IStreamingReporter {
        -: 1464:    protected:
        -: 1465:        //! Derived classes can set up their preferences here
        -: 1466:        ReporterPreferences m_preferences;
        -: 1467:    public:
        1: 1468:        virtual ~IStreamingReporter() = default;
        -: 1469:
        -: 1470:        // Implementing class must also provide the following static methods:
        -: 1471:        // static std::string getDescription();
        -: 1472:
        -: 1473:        ReporterPreferences const& getPreferences() const {
        -: 1474:            return m_preferences;
        -: 1475:        }
        -: 1476:
        -: 1477:        virtual void noMatchingTestCases( std::string const& spec ) = 0;
        -: 1478:
    #####: 1479:        virtual void reportInvalidArguments(std::string const&) {}
        -: 1480:
        -: 1481:        virtual void testRunStarting( TestRunInfo const& testRunInfo ) = 0;
        -: 1482:        virtual void testGroupStarting( GroupInfo const& groupInfo ) = 0;
        -: 1483:
        -: 1484:        virtual void testCaseStarting( TestCaseInfo const& testInfo ) = 0;
        -: 1485:        virtual void sectionStarting( SectionInfo const& sectionInfo ) = 0;
        -: 1486:
    #####: 1487:        virtual void benchmarkPreparing( std::string const& ) {}
    #####: 1488:        virtual void benchmarkStarting( BenchmarkInfo const& ) {}
    #####: 1489:        virtual void benchmarkEnded( BenchmarkStats<> const& ) {}
    #####: 1490:        virtual void benchmarkFailed( std::string const& ) {}
        -: 1491:
        -: 1492:        virtual void assertionStarting( AssertionInfo const& assertionInfo ) = 0;
        -: 1493:
        -: 1494:        // The return value indicates if the messages buffer should be cleared:
        -: 1495:        virtual bool assertionEnded( AssertionStats const& assertionStats ) = 0;
        -: 1496:
        -: 1497:        virtual void sectionEnded( SectionStats const& sectionStats ) = 0;
        -: 1498:        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) = 0;
        -: 1499:        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) = 0;
        -: 1500:        virtual void testRunEnded( TestRunStats const& testRunStats ) = 0;
        -: 1501:
        -: 1502:        virtual void skipTest( TestCaseInfo const& testInfo ) = 0;
        -: 1503:
        -: 1504:        // Default empty implementation provided
        -: 1505:        virtual void fatalErrorEncountered( StringRef name );
        -: 1506:
        -: 1507:        //! Writes out information about provided reporters using reporter-specific format
        -: 1508:        virtual void listReporters(std::vector<ReporterDescription> const& descriptions, IConfig const& config);
        -: 1509:        //! Writes out information about provided tests using reporter-specific format
        -: 1510:        virtual void listTests(std::vector<TestCaseHandle> const& tests, IConfig const& config);
        -: 1511:        //! Writes out information about the provided tags using reporter-specific format
        -: 1512:        virtual void listTags(std::vector<TagInfo> const& tags, IConfig const& config);
        -: 1513:
        -: 1514:    };
        -: 1515:    using IStreamingReporterPtr = Detail::unique_ptr<IStreamingReporter>;
        -: 1516:
        -: 1517:} // end namespace Catch
        -: 1518:
        -: 1519:#endif // CATCH_INTERFACES_REPORTER_HPP_INCLUDED
        -: 1520:
        -: 1521:
        -: 1522:
        -: 1523:// Adapted from donated nonius code.
        -: 1524:
        -: 1525:#ifndef CATCH_CHRONOMETER_HPP_INCLUDED
        -: 1526:#define CATCH_CHRONOMETER_HPP_INCLUDED
        -: 1527:
        -: 1528:
        -: 1529:
        -: 1530:// Adapted from donated nonius code.
        -: 1531:
        -: 1532:#ifndef CATCH_CLOCK_HPP_INCLUDED
        -: 1533:#define CATCH_CLOCK_HPP_INCLUDED
        -: 1534:
        -: 1535:#include <chrono>
        -: 1536:#include <ratio>
        -: 1537:
        -: 1538:namespace Catch {
        -: 1539:    namespace Benchmark {
        -: 1540:        template <typename Clock>
        -: 1541:        using ClockDuration = typename Clock::duration;
        -: 1542:        template <typename Clock>
        -: 1543:        using FloatDuration = std::chrono::duration<double, typename Clock::period>;
        -: 1544:
        -: 1545:        template <typename Clock>
        -: 1546:        using TimePoint = typename Clock::time_point;
        -: 1547:
        -: 1548:        using default_clock = std::chrono::steady_clock;
        -: 1549:
        -: 1550:        template <typename Clock>
        -: 1551:        struct now {
        -: 1552:            TimePoint<Clock> operator()() const {
        -: 1553:                return Clock::now();
        -: 1554:            }
        -: 1555:        };
        -: 1556:
        -: 1557:        using fp_seconds = std::chrono::duration<double, std::ratio<1>>;
        -: 1558:    } // namespace Benchmark
        -: 1559:} // namespace Catch
        -: 1560:
        -: 1561:#endif // CATCH_CLOCK_HPP_INCLUDED
        -: 1562:
        -: 1563:
        -: 1564:// Adapted from donated nonius code.
        -: 1565:
        -: 1566:#ifndef CATCH_OPTIMIZER_HPP_INCLUDED
        -: 1567:#define CATCH_OPTIMIZER_HPP_INCLUDED
        -: 1568:
        -: 1569:#if defined(_MSC_VER)
        -: 1570:#   include <atomic> // atomic_thread_fence
        -: 1571:#endif
        -: 1572:
        -: 1573:#include <type_traits>
        -: 1574:#include <utility>
        -: 1575:
        -: 1576:namespace Catch {
        -: 1577:    namespace Benchmark {
        -: 1578:#if defined(__GNUC__) || defined(__clang__)
        -: 1579:        template <typename T>
        -: 1580:        inline void keep_memory(T* p) {
        -: 1581:            asm volatile("" : : "g"(p) : "memory");
        -: 1582:        }
        -: 1583:        inline void keep_memory() {
        -: 1584:            asm volatile("" : : : "memory");
        -: 1585:        }
        -: 1586:
        -: 1587:        namespace Detail {
        -: 1588:            inline void optimizer_barrier() { keep_memory(); }
        -: 1589:        } // namespace Detail
        -: 1590:#elif defined(_MSC_VER)
        -: 1591:
        -: 1592:#pragma optimize("", off)
        -: 1593:        template <typename T>
        -: 1594:        inline void keep_memory(T* p) {
        -: 1595:            // thanks @milleniumbug
        -: 1596:            *reinterpret_cast<char volatile*>(p) = *reinterpret_cast<char const volatile*>(p);
        -: 1597:        }
        -: 1598:        // TODO equivalent keep_memory()
        -: 1599:#pragma optimize("", on)
        -: 1600:
        -: 1601:        namespace Detail {
        -: 1602:            inline void optimizer_barrier() {
        -: 1603:                std::atomic_thread_fence(std::memory_order_seq_cst);
        -: 1604:            }
        -: 1605:        } // namespace Detail
        -: 1606:
        -: 1607:#endif
        -: 1608:
        -: 1609:        template <typename T>
        -: 1610:        inline void deoptimize_value(T&& x) {
        -: 1611:            keep_memory(&x);
        -: 1612:        }
        -: 1613:
        -: 1614:        template <typename Fn, typename... Args>
        -: 1615:        inline auto invoke_deoptimized(Fn&& fn, Args&&... args) -> typename std::enable_if<!std::is_same<void, decltype(fn(args...))>::value>::type {
        -: 1616:            deoptimize_value(std::forward<Fn>(fn) (std::forward<Args...>(args...)));
        -: 1617:        }
        -: 1618:
        -: 1619:        template <typename Fn, typename... Args>
        -: 1620:        inline auto invoke_deoptimized(Fn&& fn, Args&&... args) -> typename std::enable_if<std::is_same<void, decltype(fn(args...))>::value>::type {
        -: 1621:            std::forward<Fn>(fn) (std::forward<Args...>(args...));
        -: 1622:        }
        -: 1623:    } // namespace Benchmark
        -: 1624:} // namespace Catch
        -: 1625:
        -: 1626:#endif // CATCH_OPTIMIZER_HPP_INCLUDED
        -: 1627:
        -: 1628:
        -: 1629:// Adapted from donated nonius code.
        -: 1630:
        -: 1631:#ifndef CATCH_COMPLETE_INVOKE_HPP_INCLUDED
        -: 1632:#define CATCH_COMPLETE_INVOKE_HPP_INCLUDED
        -: 1633:
        -: 1634:
        -: 1635:
        -: 1636:#ifndef CATCH_ENFORCE_HPP_INCLUDED
        -: 1637:#define CATCH_ENFORCE_HPP_INCLUDED
        -: 1638:
        -: 1639:
        -: 1640:
        -: 1641:#ifndef CATCH_STREAM_HPP_INCLUDED
        -: 1642:#define CATCH_STREAM_HPP_INCLUDED
        -: 1643:
        -: 1644:
        -: 1645:#include <iosfwd>
        -: 1646:#include <cstddef>
        -: 1647:#include <ostream>
        -: 1648:
        -: 1649:namespace Catch {
        -: 1650:
        -: 1651:    std::ostream& cout();
        -: 1652:    std::ostream& cerr();
        -: 1653:    std::ostream& clog();
        -: 1654:
        -: 1655:    class StringRef;
        -: 1656:
        2: 1657:    struct IStream {
        -: 1658:        virtual ~IStream();
        -: 1659:        virtual std::ostream& stream() const = 0;
        -: 1660:    };
        -: 1661:
        -: 1662:    auto makeStream( StringRef const &filename ) -> IStream const*;
        -: 1663:
        -: 1664:    class ReusableStringStream : Detail::NonCopyable {
        -: 1665:        std::size_t m_index;
        -: 1666:        std::ostream* m_oss;
        -: 1667:    public:
        -: 1668:        ReusableStringStream();
        -: 1669:        ~ReusableStringStream();
        -: 1670:
        -: 1671:        //! Returns the serialized state
        -: 1672:        std::string str() const;
        -: 1673:        //! Sets internal state to `str`
        -: 1674:        void str(std::string const& str);
        -: 1675:
        -: 1676:#if defined(__GNUC__) && !defined(__clang__)
        -: 1677:#pragma GCC diagnostic push
        -: 1678:// Old versions of GCC do not understand -Wnonnull-compare
        -: 1679:#pragma GCC diagnostic ignored "-Wpragmas"
        -: 1680:// Streaming a function pointer triggers Waddress and Wnonnull-compare
        -: 1681:// on GCC, because it implicitly converts it to bool and then decides
        -: 1682:// that the check it uses (a? true : false) is tautological and cannot
        -: 1683:// be null...
        -: 1684:#pragma GCC diagnostic ignored "-Waddress"
        -: 1685:#pragma GCC diagnostic ignored "-Wnonnull-compare"
        -: 1686:#endif
        -: 1687:
        -: 1688:        template<typename T>
        -: 1689:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####: 1690:            *m_oss << value;
        -: 1691:            return *this;
        -: 1692:        }
        -: 1693:
        -: 1694:#if defined(__GNUC__) && !defined(__clang__)
        -: 1695:#pragma GCC diagnostic pop
        -: 1696:#endif
        -: 1697:        auto get() -> std::ostream& { return *m_oss; }
        -: 1698:    };
        -: 1699:}
        -: 1700:
        -: 1701:#endif // CATCH_STREAM_HPP_INCLUDED
        -: 1702:
        -: 1703:#include <exception>
        -: 1704:
        -: 1705:namespace Catch {
        -: 1706:#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
        -: 1707:    template <typename Ex>
        -: 1708:    [[noreturn]]
    #####: 1709:    void throw_exception(Ex const& e) {
    #####: 1710:        throw e;
        -: 1711:    }
        -: 1712:#else // ^^ Exceptions are enabled //  Exceptions are disabled vv
        -: 1713:    [[noreturn]]
        -: 1714:    void throw_exception(std::exception const& e);
        -: 1715:#endif
        -: 1716:
        -: 1717:    [[noreturn]]
        -: 1718:    void throw_logic_error(std::string const& msg);
        -: 1719:    [[noreturn]]
        -: 1720:    void throw_domain_error(std::string const& msg);
        -: 1721:    [[noreturn]]
        -: 1722:    void throw_runtime_error(std::string const& msg);
        -: 1723:
        -: 1724:} // namespace Catch;
        -: 1725:
        -: 1726:#define CATCH_MAKE_MSG(...) \
        -: 1727:    (Catch::ReusableStringStream() << __VA_ARGS__).str()
        -: 1728:
        -: 1729:#define CATCH_INTERNAL_ERROR(...) \
        -: 1730:    Catch::throw_logic_error(CATCH_MAKE_MSG( CATCH_INTERNAL_LINEINFO << ": Internal Catch2 error: " << __VA_ARGS__))
        -: 1731:
        -: 1732:#define CATCH_ERROR(...) \
        -: 1733:    Catch::throw_domain_error(CATCH_MAKE_MSG( __VA_ARGS__ ))
        -: 1734:
        -: 1735:#define CATCH_RUNTIME_ERROR(...) \
        -: 1736:    Catch::throw_runtime_error(CATCH_MAKE_MSG( __VA_ARGS__ ))
        -: 1737:
        -: 1738:#define CATCH_ENFORCE( condition, ... ) \
        -: 1739:    do{ if( !(condition) ) CATCH_ERROR( __VA_ARGS__ ); } while(false)
        -: 1740:
        -: 1741:
        -: 1742:#endif // CATCH_ENFORCE_HPP_INCLUDED
        -: 1743:
        -: 1744:
        -: 1745:#ifndef CATCH_META_HPP_INCLUDED
        -: 1746:#define CATCH_META_HPP_INCLUDED
        -: 1747:
        -: 1748:#include <type_traits>
        -: 1749:
        -: 1750:namespace Catch {
        -: 1751:    template<typename T>
        -: 1752:    struct always_false : std::false_type {};
        -: 1753:
        -: 1754:    template <typename> struct true_given : std::true_type {};
        -: 1755:    struct is_callable_tester {
        -: 1756:        template <typename Fun, typename... Args>
        -: 1757:        true_given<decltype(std::declval<Fun>()(std::declval<Args>()...))> static test(int);
        -: 1758:        template <typename...>
        -: 1759:        std::false_type static test(...);
        -: 1760:    };
        -: 1761:
        -: 1762:    template <typename T>
        -: 1763:    struct is_callable;
        -: 1764:
        -: 1765:    template <typename Fun, typename... Args>
        -: 1766:    struct is_callable<Fun(Args...)> : decltype(is_callable_tester::test<Fun, Args...>(0)) {};
        -: 1767:
        -: 1768:
        -: 1769:#if defined(__cpp_lib_is_invocable) && __cpp_lib_is_invocable >= 201703
        -: 1770:    // std::result_of is deprecated in C++17 and removed in C++20. Hence, it is
        -: 1771:    // replaced with std::invoke_result here.
        -: 1772:    template <typename Func, typename... U>
        -: 1773:    using FunctionReturnType = std::remove_reference_t<std::remove_cv_t<std::invoke_result_t<Func, U...>>>;
        -: 1774:#else
        -: 1775:    template <typename Func, typename... U>
        -: 1776:    using FunctionReturnType = std::remove_reference_t<std::remove_cv_t<std::result_of_t<Func(U...)>>>;
        -: 1777:#endif
        -: 1778:
        -: 1779:} // namespace Catch
        -: 1780:
        -: 1781:namespace mpl_{
        -: 1782:    struct na;
        -: 1783:}
        -: 1784:
        -: 1785:#endif // CATCH_META_HPP_INCLUDED
        -: 1786:
        -: 1787:
        -: 1788:#ifndef CATCH_INTERFACES_REGISTRY_HUB_HPP_INCLUDED
        -: 1789:#define CATCH_INTERFACES_REGISTRY_HUB_HPP_INCLUDED
        -: 1790:
        -: 1791:
        -: 1792:#include <string>
        -: 1793:
        -: 1794:namespace Catch {
        -: 1795:
        -: 1796:    class TestCaseHandle;
        -: 1797:    struct TestCaseInfo;
        -: 1798:    struct ITestCaseRegistry;
        -: 1799:    struct IExceptionTranslatorRegistry;
        -: 1800:    struct IExceptionTranslator;
        -: 1801:    struct IReporterRegistry;
        -: 1802:    struct IReporterFactory;
        -: 1803:    struct ITagAliasRegistry;
        -: 1804:    struct ITestInvoker;
        -: 1805:    struct IMutableEnumValuesRegistry;
        -: 1806:    struct SourceLineInfo;
        -: 1807:
        -: 1808:    class StartupExceptionRegistry;
        -: 1809:
        -: 1810:    using IReporterFactoryPtr = Detail::unique_ptr<IReporterFactory>;
        -: 1811:
        2: 1812:    struct IRegistryHub {
        -: 1813:        virtual ~IRegistryHub();
        -: 1814:
        -: 1815:        virtual IReporterRegistry const& getReporterRegistry() const = 0;
        -: 1816:        virtual ITestCaseRegistry const& getTestCaseRegistry() const = 0;
        -: 1817:        virtual ITagAliasRegistry const& getTagAliasRegistry() const = 0;
        -: 1818:        virtual IExceptionTranslatorRegistry const& getExceptionTranslatorRegistry() const = 0;
        -: 1819:
        -: 1820:
        -: 1821:        virtual StartupExceptionRegistry const& getStartupExceptionRegistry() const = 0;
        -: 1822:    };
        -: 1823:
        2: 1824:    struct IMutableRegistryHub {
        -: 1825:        virtual ~IMutableRegistryHub();
        -: 1826:        virtual void registerReporter( std::string const& name, IReporterFactoryPtr factory ) = 0;
        -: 1827:        virtual void registerListener( IReporterFactoryPtr factory ) = 0;
        -: 1828:        virtual void registerTest(Detail::unique_ptr<TestCaseInfo>&& testInfo, Detail::unique_ptr<ITestInvoker>&& invoker) = 0;
        -: 1829:        virtual void registerTranslator( const IExceptionTranslator* translator ) = 0;
        -: 1830:        virtual void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) = 0;
        -: 1831:        virtual void registerStartupException() noexcept = 0;
        -: 1832:        virtual IMutableEnumValuesRegistry& getMutableEnumValuesRegistry() = 0;
        -: 1833:    };
        -: 1834:
        -: 1835:    IRegistryHub const& getRegistryHub();
        -: 1836:    IMutableRegistryHub& getMutableRegistryHub();
        -: 1837:    void cleanUp();
        -: 1838:    std::string translateActiveException();
        -: 1839:
        -: 1840:}
        -: 1841:
        -: 1842:#endif // CATCH_INTERFACES_REGISTRY_HUB_HPP_INCLUDED
        -: 1843:
        -: 1844:#include <type_traits>
        -: 1845:#include <utility>
        -: 1846:
        -: 1847:namespace Catch {
        -: 1848:    namespace Benchmark {
        -: 1849:        namespace Detail {
        -: 1850:            template <typename T>
        -: 1851:            struct CompleteType { using type = T; };
        -: 1852:            template <>
        -: 1853:            struct CompleteType<void> { struct type {}; };
        -: 1854:
        -: 1855:            template <typename T>
        -: 1856:            using CompleteType_t = typename CompleteType<T>::type;
        -: 1857:
        -: 1858:            template <typename Result>
        -: 1859:            struct CompleteInvoker {
        -: 1860:                template <typename Fun, typename... Args>
        -: 1861:                static Result invoke(Fun&& fun, Args&&... args) {
        -: 1862:                    return std::forward<Fun>(fun)(std::forward<Args>(args)...);
        -: 1863:                }
        -: 1864:            };
        -: 1865:            template <>
        -: 1866:            struct CompleteInvoker<void> {
        -: 1867:                template <typename Fun, typename... Args>
        -: 1868:                static CompleteType_t<void> invoke(Fun&& fun, Args&&... args) {
        -: 1869:                    std::forward<Fun>(fun)(std::forward<Args>(args)...);
        -: 1870:                    return {};
        -: 1871:                }
        -: 1872:            };
        -: 1873:
        -: 1874:            // invoke and not return void :(
        -: 1875:            template <typename Fun, typename... Args>
        -: 1876:            CompleteType_t<FunctionReturnType<Fun, Args...>> complete_invoke(Fun&& fun, Args&&... args) {
        -: 1877:                return CompleteInvoker<FunctionReturnType<Fun, Args...>>::invoke(std::forward<Fun>(fun), std::forward<Args>(args)...);
        -: 1878:            }
        -: 1879:
        -: 1880:            extern const std::string benchmarkErrorMsg;
        -: 1881:        } // namespace Detail
        -: 1882:
        -: 1883:        template <typename Fun>
        -: 1884:        Detail::CompleteType_t<FunctionReturnType<Fun>> user_code(Fun&& fun) {
        -: 1885:            CATCH_TRY{
        -: 1886:                return Detail::complete_invoke(std::forward<Fun>(fun));
        -: 1887:            } CATCH_CATCH_ALL{
        -: 1888:                getResultCapture().benchmarkFailed(translateActiveException());
        -: 1889:                CATCH_RUNTIME_ERROR(Detail::benchmarkErrorMsg);
        -: 1890:            }
        -: 1891:        }
        -: 1892:    } // namespace Benchmark
        -: 1893:} // namespace Catch
        -: 1894:
        -: 1895:#endif // CATCH_COMPLETE_INVOKE_HPP_INCLUDED
        -: 1896:
        -: 1897:namespace Catch {
        -: 1898:    namespace Benchmark {
        -: 1899:        namespace Detail {
    #####: 1900:            struct ChronometerConcept {
        -: 1901:                virtual void start() = 0;
        -: 1902:                virtual void finish() = 0;
        -: 1903:                virtual ~ChronometerConcept(); // = default;
        -: 1904:
        -: 1905:                ChronometerConcept() = default;
        -: 1906:                ChronometerConcept(ChronometerConcept const&) = default;
        -: 1907:                ChronometerConcept& operator=(ChronometerConcept const&) = default;
        -: 1908:            };
        -: 1909:            template <typename Clock>
        -: 1910:            struct ChronometerModel final : public ChronometerConcept {
        -: 1911:                void start() override { started = Clock::now(); }
        -: 1912:                void finish() override { finished = Clock::now(); }
        -: 1913:
        -: 1914:                ClockDuration<Clock> elapsed() const { return finished - started; }
        -: 1915:
        -: 1916:                TimePoint<Clock> started;
        -: 1917:                TimePoint<Clock> finished;
        -: 1918:            };
        -: 1919:        } // namespace Detail
        -: 1920:
        -: 1921:        struct Chronometer {
        -: 1922:        public:
        -: 1923:            template <typename Fun>
        -: 1924:            void measure(Fun&& fun) { measure(std::forward<Fun>(fun), is_callable<Fun(int)>()); }
        -: 1925:
        -: 1926:            int runs() const { return repeats; }
        -: 1927:
        -: 1928:            Chronometer(Detail::ChronometerConcept& meter, int repeats_)
        -: 1929:                : impl(&meter)
        -: 1930:                , repeats(repeats_) {}
        -: 1931:
        -: 1932:        private:
        -: 1933:            template <typename Fun>
        -: 1934:            void measure(Fun&& fun, std::false_type) {
        -: 1935:                measure([&fun](int) { return fun(); }, std::true_type());
        -: 1936:            }
        -: 1937:
        -: 1938:            template <typename Fun>
        -: 1939:            void measure(Fun&& fun, std::true_type) {
        -: 1940:                Detail::optimizer_barrier();
        -: 1941:                impl->start();
        -: 1942:                for (int i = 0; i < repeats; ++i) invoke_deoptimized(fun, i);
        -: 1943:                impl->finish();
        -: 1944:                Detail::optimizer_barrier();
        -: 1945:            }
        -: 1946:
        -: 1947:            Detail::ChronometerConcept* impl;
        -: 1948:            int repeats;
        -: 1949:        };
        -: 1950:    } // namespace Benchmark
        -: 1951:} // namespace Catch
        -: 1952:
        -: 1953:#endif // CATCH_CHRONOMETER_HPP_INCLUDED
        -: 1954:
        -: 1955:
        -: 1956:// Adapted from donated nonius code.
        -: 1957:
        -: 1958:#ifndef CATCH_ENVIRONMENT_HPP_INCLUDED
        -: 1959:#define CATCH_ENVIRONMENT_HPP_INCLUDED
        -: 1960:
        -: 1961:
        -: 1962:namespace Catch {
        -: 1963:    namespace Benchmark {
        -: 1964:        template <typename Duration>
        -: 1965:        struct EnvironmentEstimate {
        -: 1966:            Duration mean;
        -: 1967:            OutlierClassification outliers;
        -: 1968:
        -: 1969:            template <typename Duration2>
        -: 1970:            operator EnvironmentEstimate<Duration2>() const {
        -: 1971:                return { mean, outliers };
        -: 1972:            }
        -: 1973:        };
        -: 1974:        template <typename Clock>
        -: 1975:        struct Environment {
        -: 1976:            using clock_type = Clock;
        -: 1977:            EnvironmentEstimate<FloatDuration<Clock>> clock_resolution;
        -: 1978:            EnvironmentEstimate<FloatDuration<Clock>> clock_cost;
        -: 1979:        };
        -: 1980:    } // namespace Benchmark
        -: 1981:} // namespace Catch
        -: 1982:
        -: 1983:#endif // CATCH_ENVIRONMENT_HPP_INCLUDED
        -: 1984:
        -: 1985:
        -: 1986:// Adapted from donated nonius code.
        -: 1987:
        -: 1988:#ifndef CATCH_EXECUTION_PLAN_HPP_INCLUDED
        -: 1989:#define CATCH_EXECUTION_PLAN_HPP_INCLUDED
        -: 1990:
        -: 1991:
        -: 1992:
        -: 1993:// Adapted from donated nonius code.
        -: 1994:
        -: 1995:#ifndef CATCH_BENCHMARK_FUNCTION_HPP_INCLUDED
        -: 1996:#define CATCH_BENCHMARK_FUNCTION_HPP_INCLUDED
        -: 1997:
        -: 1998:
        -: 1999:#include <cassert>
        -: 2000:#include <type_traits>
        -: 2001:#include <utility>
        -: 2002:
        -: 2003:namespace Catch {
        -: 2004:    namespace Benchmark {
        -: 2005:        namespace Detail {
        -: 2006:            template <typename T>
        -: 2007:            using Decay = typename std::decay<T>::type;
        -: 2008:            template <typename T, typename U>
        -: 2009:            struct is_related
        -: 2010:                : std::is_same<Decay<T>, Decay<U>> {};
        -: 2011:
        -: 2012:            /// We need to reinvent std::function because every piece of code that might add overhead
        -: 2013:            /// in a measurement context needs to have consistent performance characteristics so that we
        -: 2014:            /// can account for it in the measurement.
        -: 2015:            /// Implementations of std::function with optimizations that aren't always applicable, like
        -: 2016:            /// small buffer optimizations, are not uncommon.
        -: 2017:            /// This is effectively an implementation of std::function without any such optimizations;
        -: 2018:            /// it may be slow, but it is consistently slow.
        -: 2019:            struct BenchmarkFunction {
        -: 2020:            private:
    #####: 2021:                struct callable {
        -: 2022:                    virtual void call(Chronometer meter) const = 0;
        -: 2023:                    virtual callable* clone() const = 0;
        -: 2024:                    virtual ~callable(); // = default;
        -: 2025:
        -: 2026:                    callable() = default;
        -: 2027:                    callable(callable const&) = default;
        -: 2028:                    callable& operator=(callable const&) = default;
        -: 2029:                };
        -: 2030:                template <typename Fun>
        -: 2031:                struct model : public callable {
        -: 2032:                    model(Fun&& fun_) : fun(std::move(fun_)) {}
        -: 2033:                    model(Fun const& fun_) : fun(fun_) {}
        -: 2034:
        -: 2035:                    model<Fun>* clone() const override { return new model<Fun>(*this); }
        -: 2036:
        -: 2037:                    void call(Chronometer meter) const override {
        -: 2038:                        call(meter, is_callable<Fun(Chronometer)>());
        -: 2039:                    }
        -: 2040:                    void call(Chronometer meter, std::true_type) const {
        -: 2041:                        fun(meter);
        -: 2042:                    }
        -: 2043:                    void call(Chronometer meter, std::false_type) const {
        -: 2044:                        meter.measure(fun);
        -: 2045:                    }
        -: 2046:
        -: 2047:                    Fun fun;
        -: 2048:                };
        -: 2049:
        -: 2050:                struct do_nothing { void operator()() const {} };
        -: 2051:
        -: 2052:                template <typename T>
        -: 2053:                BenchmarkFunction(model<T>* c) : f(c) {}
        -: 2054:
        -: 2055:            public:
        -: 2056:                BenchmarkFunction()
        -: 2057:                    : f(new model<do_nothing>{ {} }) {}
        -: 2058:
        -: 2059:                template <typename Fun,
        -: 2060:                    typename std::enable_if<!is_related<Fun, BenchmarkFunction>::value, int>::type = 0>
        -: 2061:                    BenchmarkFunction(Fun&& fun)
        -: 2062:                    : f(new model<typename std::decay<Fun>::type>(std::forward<Fun>(fun))) {}
        -: 2063:
        -: 2064:                BenchmarkFunction( BenchmarkFunction&& that ) noexcept:
        -: 2065:                    f( std::move( that.f ) ) {}
        -: 2066:
        -: 2067:                BenchmarkFunction(BenchmarkFunction const& that)
        -: 2068:                    : f(that.f->clone()) {}
        -: 2069:
        -: 2070:                BenchmarkFunction&
        -: 2071:                operator=( BenchmarkFunction&& that ) noexcept {
        -: 2072:                    f = std::move( that.f );
        -: 2073:                    return *this;
        -: 2074:                }
        -: 2075:
        -: 2076:                BenchmarkFunction& operator=(BenchmarkFunction const& that) {
        -: 2077:                    f.reset(that.f->clone());
        -: 2078:                    return *this;
        -: 2079:                }
        -: 2080:
        -: 2081:                void operator()(Chronometer meter) const { f->call(meter); }
        -: 2082:
        -: 2083:            private:
        -: 2084:                Catch::Detail::unique_ptr<callable> f;
        -: 2085:            };
        -: 2086:        } // namespace Detail
        -: 2087:    } // namespace Benchmark
        -: 2088:} // namespace Catch
        -: 2089:
        -: 2090:#endif // CATCH_BENCHMARK_FUNCTION_HPP_INCLUDED
        -: 2091:
        -: 2092:
        -: 2093:// Adapted from donated nonius code.
        -: 2094:
        -: 2095:#ifndef CATCH_REPEAT_HPP_INCLUDED
        -: 2096:#define CATCH_REPEAT_HPP_INCLUDED
        -: 2097:
        -: 2098:#include <type_traits>
        -: 2099:#include <utility>
        -: 2100:
        -: 2101:namespace Catch {
        -: 2102:    namespace Benchmark {
        -: 2103:        namespace Detail {
        -: 2104:            template <typename Fun>
        -: 2105:            struct repeater {
        -: 2106:                void operator()(int k) const {
        -: 2107:                    for (int i = 0; i < k; ++i) {
        -: 2108:                        fun();
        -: 2109:                    }
        -: 2110:                }
        -: 2111:                Fun fun;
        -: 2112:            };
        -: 2113:            template <typename Fun>
        -: 2114:            repeater<typename std::decay<Fun>::type> repeat(Fun&& fun) {
        -: 2115:                return { std::forward<Fun>(fun) };
        -: 2116:            }
        -: 2117:        } // namespace Detail
        -: 2118:    } // namespace Benchmark
        -: 2119:} // namespace Catch
        -: 2120:
        -: 2121:#endif // CATCH_REPEAT_HPP_INCLUDED
        -: 2122:
        -: 2123:
        -: 2124:// Adapted from donated nonius code.
        -: 2125:
        -: 2126:#ifndef CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED
        -: 2127:#define CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED
        -: 2128:
        -: 2129:
        -: 2130:
        -: 2131:// Adapted from donated nonius code.
        -: 2132:
        -: 2133:#ifndef CATCH_MEASURE_HPP_INCLUDED
        -: 2134:#define CATCH_MEASURE_HPP_INCLUDED
        -: 2135:
        -: 2136:
        -: 2137:
        -: 2138:// Adapted from donated nonius code.
        -: 2139:
        -: 2140:#ifndef CATCH_TIMING_HPP_INCLUDED
        -: 2141:#define CATCH_TIMING_HPP_INCLUDED
        -: 2142:
        -: 2143:
        -: 2144:#include <type_traits>
        -: 2145:
        -: 2146:namespace Catch {
        -: 2147:    namespace Benchmark {
        -: 2148:        template <typename Duration, typename Result>
        -: 2149:        struct Timing {
        -: 2150:            Duration elapsed;
        -: 2151:            Result result;
        -: 2152:            int iterations;
        -: 2153:        };
        -: 2154:        template <typename Clock, typename Func, typename... Args>
        -: 2155:        using TimingOf = Timing<ClockDuration<Clock>, Detail::CompleteType_t<FunctionReturnType<Func, Args...>>>;
        -: 2156:    } // namespace Benchmark
        -: 2157:} // namespace Catch
        -: 2158:
        -: 2159:#endif // CATCH_TIMING_HPP_INCLUDED
        -: 2160:
        -: 2161:#include <utility>
        -: 2162:
        -: 2163:namespace Catch {
        -: 2164:    namespace Benchmark {
        -: 2165:        namespace Detail {
        -: 2166:            template <typename Clock, typename Fun, typename... Args>
        -: 2167:            TimingOf<Clock, Fun, Args...> measure(Fun&& fun, Args&&... args) {
        -: 2168:                auto start = Clock::now();
        -: 2169:                auto&& r = Detail::complete_invoke(fun, std::forward<Args>(args)...);
        -: 2170:                auto end = Clock::now();
        -: 2171:                auto delta = end - start;
        -: 2172:                return { delta, std::forward<decltype(r)>(r), 1 };
        -: 2173:            }
        -: 2174:        } // namespace Detail
        -: 2175:    } // namespace Benchmark
        -: 2176:} // namespace Catch
        -: 2177:
        -: 2178:#endif // CATCH_MEASURE_HPP_INCLUDED
        -: 2179:
        -: 2180:#include <utility>
        -: 2181:#include <type_traits>
        -: 2182:
        -: 2183:namespace Catch {
        -: 2184:    namespace Benchmark {
        -: 2185:        namespace Detail {
        -: 2186:            template <typename Clock, typename Fun>
        -: 2187:            TimingOf<Clock, Fun, int> measure_one(Fun&& fun, int iters, std::false_type) {
        -: 2188:                return Detail::measure<Clock>(fun, iters);
        -: 2189:            }
        -: 2190:            template <typename Clock, typename Fun>
        -: 2191:            TimingOf<Clock, Fun, Chronometer> measure_one(Fun&& fun, int iters, std::true_type) {
        -: 2192:                Detail::ChronometerModel<Clock> meter;
        -: 2193:                auto&& result = Detail::complete_invoke(fun, Chronometer(meter, iters));
        -: 2194:
        -: 2195:                return { meter.elapsed(), std::move(result), iters };
        -: 2196:            }
        -: 2197:
        -: 2198:            template <typename Clock, typename Fun>
        -: 2199:            using run_for_at_least_argument_t = typename std::conditional<is_callable<Fun(Chronometer)>::value, Chronometer, int>::type;
        -: 2200:
        -: 2201:
        -: 2202:            [[noreturn]]
        -: 2203:            void throw_optimized_away_error();
        -: 2204:
        -: 2205:            template <typename Clock, typename Fun>
        -: 2206:            TimingOf<Clock, Fun, run_for_at_least_argument_t<Clock, Fun>> run_for_at_least(ClockDuration<Clock> how_long, int seed, Fun&& fun) {
        -: 2207:                auto iters = seed;
        -: 2208:                while (iters < (1 << 30)) {
        -: 2209:                    auto&& Timing = measure_one<Clock>(fun, iters, is_callable<Fun(Chronometer)>());
        -: 2210:
        -: 2211:                    if (Timing.elapsed >= how_long) {
        -: 2212:                        return { Timing.elapsed, std::move(Timing.result), iters };
        -: 2213:                    }
        -: 2214:                    iters *= 2;
        -: 2215:                }
        -: 2216:                throw_optimized_away_error();
        -: 2217:            }
        -: 2218:        } // namespace Detail
        -: 2219:    } // namespace Benchmark
        -: 2220:} // namespace Catch
        -: 2221:
        -: 2222:#endif // CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED
        -: 2223:
        -: 2224:#include <algorithm>
        -: 2225:
        -: 2226:namespace Catch {
        -: 2227:    namespace Benchmark {
        -: 2228:        template <typename Duration>
        -: 2229:        struct ExecutionPlan {
        -: 2230:            int iterations_per_sample;
        -: 2231:            Duration estimated_duration;
        -: 2232:            Detail::BenchmarkFunction benchmark;
        -: 2233:            Duration warmup_time;
        -: 2234:            int warmup_iterations;
        -: 2235:
        -: 2236:            template <typename Duration2>
        -: 2237:            operator ExecutionPlan<Duration2>() const {
        -: 2238:                return { iterations_per_sample, estimated_duration, benchmark, warmup_time, warmup_iterations };
        -: 2239:            }
        -: 2240:
        -: 2241:            template <typename Clock>
        -: 2242:            std::vector<FloatDuration<Clock>> run(const IConfig &cfg, Environment<FloatDuration<Clock>> env) const {
        -: 2243:                // warmup a bit
        -: 2244:                Detail::run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(warmup_time), warmup_iterations, Detail::repeat(now<Clock>{}));
        -: 2245:
        -: 2246:                std::vector<FloatDuration<Clock>> times;
        -: 2247:                times.reserve(cfg.benchmarkSamples());
        -: 2248:                std::generate_n(std::back_inserter(times), cfg.benchmarkSamples(), [this, env] {
        -: 2249:                    Detail::ChronometerModel<Clock> model;
        -: 2250:                    this->benchmark(Chronometer(model, iterations_per_sample));
        -: 2251:                    auto sample_time = model.elapsed() - env.clock_cost.mean;
        -: 2252:                    if (sample_time < FloatDuration<Clock>::zero()) sample_time = FloatDuration<Clock>::zero();
        -: 2253:                    return sample_time / iterations_per_sample;
        -: 2254:                });
        -: 2255:                return times;
        -: 2256:            }
        -: 2257:        };
        -: 2258:    } // namespace Benchmark
        -: 2259:} // namespace Catch
        -: 2260:
        -: 2261:#endif // CATCH_EXECUTION_PLAN_HPP_INCLUDED
        -: 2262:
        -: 2263:
        -: 2264:// Adapted from donated nonius code.
        -: 2265:
        -: 2266:#ifndef CATCH_ESTIMATE_CLOCK_HPP_INCLUDED
        -: 2267:#define CATCH_ESTIMATE_CLOCK_HPP_INCLUDED
        -: 2268:
        -: 2269:
        -: 2270:
        -: 2271:// Adapted from donated nonius code.
        -: 2272:
        -: 2273:#ifndef CATCH_STATS_HPP_INCLUDED
        -: 2274:#define CATCH_STATS_HPP_INCLUDED
        -: 2275:
        -: 2276:
        -: 2277:#include <algorithm>
        -: 2278:#include <vector>
        -: 2279:#include <numeric>
        -: 2280:#include <tuple>
        -: 2281:#include <cmath>
        -: 2282:#include <utility>
        -: 2283:
        -: 2284:namespace Catch {
        -: 2285:    namespace Benchmark {
        -: 2286:        namespace Detail {
        -: 2287:            using sample = std::vector<double>;
        -: 2288:
        -: 2289:            double weighted_average_quantile(int k, int q, std::vector<double>::iterator first, std::vector<double>::iterator last);
        -: 2290:
        -: 2291:            template <typename Iterator>
        -: 2292:            OutlierClassification classify_outliers(Iterator first, Iterator last) {
        -: 2293:                std::vector<double> copy(first, last);
        -: 2294:
        -: 2295:                auto q1 = weighted_average_quantile(1, 4, copy.begin(), copy.end());
        -: 2296:                auto q3 = weighted_average_quantile(3, 4, copy.begin(), copy.end());
        -: 2297:                auto iqr = q3 - q1;
        -: 2298:                auto los = q1 - (iqr * 3.);
        -: 2299:                auto lom = q1 - (iqr * 1.5);
        -: 2300:                auto him = q3 + (iqr * 1.5);
        -: 2301:                auto his = q3 + (iqr * 3.);
        -: 2302:
        -: 2303:                OutlierClassification o;
        -: 2304:                for (; first != last; ++first) {
        -: 2305:                    auto&& t = *first;
        -: 2306:                    if (t < los) ++o.low_severe;
        -: 2307:                    else if (t < lom) ++o.low_mild;
        -: 2308:                    else if (t > his) ++o.high_severe;
        -: 2309:                    else if (t > him) ++o.high_mild;
        -: 2310:                    ++o.samples_seen;
        -: 2311:                }
        -: 2312:                return o;
        -: 2313:            }
        -: 2314:
        -: 2315:            template <typename Iterator>
    #####: 2316:            double mean(Iterator first, Iterator last) {
        -: 2317:                auto count = last - first;
        -: 2318:                double sum = std::accumulate(first, last, 0.);
    #####: 2319:                return sum / count;
        -: 2320:            }
        -: 2321:
        -: 2322:            template <typename Estimator, typename Iterator>
    #####: 2323:            sample jackknife(Estimator&& estimator, Iterator first, Iterator last) {
        -: 2324:                auto n = last - first;
        -: 2325:                auto second = first;
        -: 2326:                ++second;
        -: 2327:                sample results;
    #####: 2328:                results.reserve(n);
        -: 2329:
    #####: 2330:                for (auto it = first; it != last; ++it) {
        -: 2331:                    std::iter_swap(it, first);
    #####: 2332:                    results.push_back(estimator(second, last));
        -: 2333:                }
        -: 2334:
    #####: 2335:                return results;
        -: 2336:            }
        -: 2337:
        -: 2338:            inline double normal_cdf(double x) {
    #####: 2339:                return std::erfc(-x / std::sqrt(2.0)) / 2.0;
        -: 2340:            }
        -: 2341:
        -: 2342:            double erfc_inv(double x);
        -: 2343:
        -: 2344:            double normal_quantile(double p);
        -: 2345:
        -: 2346:            template <typename Iterator, typename Estimator>
    #####: 2347:            Estimate<double> bootstrap(double confidence_level, Iterator first, Iterator last, sample const& resample, Estimator&& estimator) {
        -: 2348:                auto n_samples = last - first;
        -: 2349:
    #####: 2350:                double point = estimator(first, last);
        -: 2351:                // Degenerate case with a single sample
    #####: 2352:                if (n_samples == 1) return { point, point, point, confidence_level };
        -: 2353:
    #####: 2354:                sample jack = jackknife(estimator, first, last);
        -: 2355:                double jack_mean = mean(jack.begin(), jack.end());
        -: 2356:                double sum_squares, sum_cubes;
        -: 2357:                std::tie(sum_squares, sum_cubes) = std::accumulate(jack.begin(), jack.end(), std::make_pair(0., 0.), [jack_mean](std::pair<double, double> sqcb, double x) -> std::pair<double, double> {
    #####: 2358:                    auto d = jack_mean - x;
    #####: 2359:                    auto d2 = d * d;
    #####: 2360:                    auto d3 = d2 * d;
    #####: 2361:                    return { sqcb.first + d2, sqcb.second + d3 };
        -: 2362:                });
        -: 2363:
    #####: 2364:                double accel = sum_cubes / (6 * std::pow(sum_squares, 1.5));
        -: 2365:                int n = static_cast<int>(resample.size());
    #####: 2366:                double prob_n = std::count_if(resample.begin(), resample.end(), [point](double x) { return x < point; }) / (double)n;
        -: 2367:                // degenerate case with uniform samples
    #####: 2368:                if (prob_n == 0) return { point, point, point, confidence_level };
        -: 2369:
    #####: 2370:                double bias = normal_quantile(prob_n);
    #####: 2371:                double z1 = normal_quantile((1. - confidence_level) / 2.);
        -: 2372:
    #####: 2373:                auto cumn = [n](double x) -> int {
    #####: 2374:                    return std::lround(normal_cdf(x) * n); };
    #####: 2375:                auto a = [bias, accel](double b) { return bias + b / (1. - accel * b); };
    #####: 2376:                double b1 = bias + z1;
    #####: 2377:                double b2 = bias - z1;
        -: 2378:                double a1 = a(b1);
        -: 2379:                double a2 = a(b2);
    #####: 2380:                auto lo = std::max(cumn(a1), 0);
    #####: 2381:                auto hi = std::min(cumn(a2), n - 1);
        -: 2382:
    #####: 2383:                return { point, resample[lo], resample[hi], confidence_level };
        -: 2384:            }
        -: 2385:
        -: 2386:            double outlier_variance(Estimate<double> mean, Estimate<double> stddev, int n);
        -: 2387:
        -: 2388:            struct bootstrap_analysis {
        -: 2389:                Estimate<double> mean;
        -: 2390:                Estimate<double> standard_deviation;
        -: 2391:                double outlier_variance;
        -: 2392:            };
        -: 2393:
        -: 2394:            bootstrap_analysis analyse_samples(double confidence_level, int n_resamples, std::vector<double>::iterator first, std::vector<double>::iterator last);
        -: 2395:        } // namespace Detail
        -: 2396:    } // namespace Benchmark
        -: 2397:} // namespace Catch
        -: 2398:
        -: 2399:#endif // CATCH_STATS_HPP_INCLUDED
        -: 2400:
        -: 2401:#include <algorithm>
        -: 2402:#include <iterator>
        -: 2403:#include <vector>
        -: 2404:#include <cmath>
        -: 2405:
        -: 2406:namespace Catch {
        -: 2407:    namespace Benchmark {
        -: 2408:        namespace Detail {
        -: 2409:            template <typename Clock>
        -: 2410:            std::vector<double> resolution(int k) {
        -: 2411:                std::vector<TimePoint<Clock>> times;
        -: 2412:                times.reserve(k + 1);
        -: 2413:                std::generate_n(std::back_inserter(times), k + 1, now<Clock>{});
        -: 2414:
        -: 2415:                std::vector<double> deltas;
        -: 2416:                deltas.reserve(k);
        -: 2417:                std::transform(std::next(times.begin()), times.end(), times.begin(),
        -: 2418:                    std::back_inserter(deltas),
        -: 2419:                    [](TimePoint<Clock> a, TimePoint<Clock> b) { return static_cast<double>((a - b).count()); });
        -: 2420:
        -: 2421:                return deltas;
        -: 2422:            }
        -: 2423:
        -: 2424:            const auto warmup_iterations = 10000;
        -: 2425:            const auto warmup_time = std::chrono::milliseconds(100);
        -: 2426:            const auto minimum_ticks = 1000;
        -: 2427:            const auto warmup_seed = 10000;
        -: 2428:            const auto clock_resolution_estimation_time = std::chrono::milliseconds(500);
        -: 2429:            const auto clock_cost_estimation_time_limit = std::chrono::seconds(1);
        -: 2430:            const auto clock_cost_estimation_tick_limit = 100000;
        -: 2431:            const auto clock_cost_estimation_time = std::chrono::milliseconds(10);
        -: 2432:            const auto clock_cost_estimation_iterations = 10000;
        -: 2433:
        -: 2434:            template <typename Clock>
        -: 2435:            int warmup() {
        -: 2436:                return run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(warmup_time), warmup_seed, &resolution<Clock>)
        -: 2437:                    .iterations;
        -: 2438:            }
        -: 2439:            template <typename Clock>
        -: 2440:            EnvironmentEstimate<FloatDuration<Clock>> estimate_clock_resolution(int iterations) {
        -: 2441:                auto r = run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(clock_resolution_estimation_time), iterations, &resolution<Clock>)
        -: 2442:                    .result;
        -: 2443:                return {
        -: 2444:                    FloatDuration<Clock>(mean(r.begin(), r.end())),
        -: 2445:                    classify_outliers(r.begin(), r.end()),
        -: 2446:                };
        -: 2447:            }
        -: 2448:            template <typename Clock>
        -: 2449:            EnvironmentEstimate<FloatDuration<Clock>> estimate_clock_cost(FloatDuration<Clock> resolution) {
        -: 2450:                auto time_limit = std::min(resolution * clock_cost_estimation_tick_limit, FloatDuration<Clock>(clock_cost_estimation_time_limit));
        -: 2451:                auto time_clock = [](int k) {
        -: 2452:                    return Detail::measure<Clock>([k] {
        -: 2453:                        for (int i = 0; i < k; ++i) {
        -: 2454:                            volatile auto ignored = Clock::now();
        -: 2455:                            (void)ignored;
        -: 2456:                        }
        -: 2457:                    }).elapsed;
        -: 2458:                };
        -: 2459:                time_clock(1);
        -: 2460:                int iters = clock_cost_estimation_iterations;
        -: 2461:                auto&& r = run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(clock_cost_estimation_time), iters, time_clock);
        -: 2462:                std::vector<double> times;
        -: 2463:                int nsamples = static_cast<int>(std::ceil(time_limit / r.elapsed));
        -: 2464:                times.reserve(nsamples);
        -: 2465:                std::generate_n(std::back_inserter(times), nsamples, [time_clock, &r] {
        -: 2466:                    return static_cast<double>((time_clock(r.iterations) / r.iterations).count());
        -: 2467:                });
        -: 2468:                return {
        -: 2469:                    FloatDuration<Clock>(mean(times.begin(), times.end())),
        -: 2470:                    classify_outliers(times.begin(), times.end()),
        -: 2471:                };
        -: 2472:            }
        -: 2473:
        -: 2474:            template <typename Clock>
        -: 2475:            Environment<FloatDuration<Clock>> measure_environment() {
        -: 2476:                static Environment<FloatDuration<Clock>>* env = nullptr;
        -: 2477:                if (env) {
        -: 2478:                    return *env;
        -: 2479:                }
        -: 2480:
        -: 2481:                auto iters = Detail::warmup<Clock>();
        -: 2482:                auto resolution = Detail::estimate_clock_resolution<Clock>(iters);
        -: 2483:                auto cost = Detail::estimate_clock_cost<Clock>(resolution.mean);
        -: 2484:
        -: 2485:                env = new Environment<FloatDuration<Clock>>{ resolution, cost };
        -: 2486:                return *env;
        -: 2487:            }
        -: 2488:        } // namespace Detail
        -: 2489:    } // namespace Benchmark
        -: 2490:} // namespace Catch
        -: 2491:
        -: 2492:#endif // CATCH_ESTIMATE_CLOCK_HPP_INCLUDED
        -: 2493:
        -: 2494:
        -: 2495:// Adapted from donated nonius code.
        -: 2496:
        -: 2497:#ifndef CATCH_ANALYSE_HPP_INCLUDED
        -: 2498:#define CATCH_ANALYSE_HPP_INCLUDED
        -: 2499:
        -: 2500:
        -: 2501:
        -: 2502:// Adapted from donated nonius code.
        -: 2503:
        -: 2504:#ifndef CATCH_SAMPLE_ANALYSIS_HPP_INCLUDED
        -: 2505:#define CATCH_SAMPLE_ANALYSIS_HPP_INCLUDED
        -: 2506:
        -: 2507:
        -: 2508:#include <algorithm>
        -: 2509:#include <vector>
        -: 2510:#include <string>
        -: 2511:#include <iterator>
        -: 2512:
        -: 2513:namespace Catch {
        -: 2514:    namespace Benchmark {
        -: 2515:        template <typename Duration>
        -: 2516:        struct SampleAnalysis {
        -: 2517:            std::vector<Duration> samples;
        -: 2518:            Estimate<Duration> mean;
        -: 2519:            Estimate<Duration> standard_deviation;
        -: 2520:            OutlierClassification outliers;
        -: 2521:            double outlier_variance;
        -: 2522:
        -: 2523:            template <typename Duration2>
        -: 2524:            operator SampleAnalysis<Duration2>() const {
        -: 2525:                std::vector<Duration2> samples2;
        -: 2526:                samples2.reserve(samples.size());
        -: 2527:                std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](Duration d) { return Duration2(d); });
        -: 2528:                return {
        -: 2529:                    std::move(samples2),
        -: 2530:                    mean,
        -: 2531:                    standard_deviation,
        -: 2532:                    outliers,
        -: 2533:                    outlier_variance,
        -: 2534:                };
        -: 2535:            }
        -: 2536:        };
        -: 2537:    } // namespace Benchmark
        -: 2538:} // namespace Catch
        -: 2539:
        -: 2540:#endif // CATCH_SAMPLE_ANALYSIS_HPP_INCLUDED
        -: 2541:
        -: 2542:#include <algorithm>
        -: 2543:#include <iterator>
        -: 2544:#include <vector>
        -: 2545:
        -: 2546:namespace Catch {
        -: 2547:    namespace Benchmark {
        -: 2548:        namespace Detail {
        -: 2549:            template <typename Duration, typename Iterator>
        -: 2550:            SampleAnalysis<Duration> analyse(const IConfig &cfg, Environment<Duration>, Iterator first, Iterator last) {
        -: 2551:                if (!cfg.benchmarkNoAnalysis()) {
        -: 2552:                    std::vector<double> samples;
        -: 2553:                    samples.reserve(last - first);
        -: 2554:                    std::transform(first, last, std::back_inserter(samples), [](Duration d) { return d.count(); });
        -: 2555:
        -: 2556:                    auto analysis = Catch::Benchmark::Detail::analyse_samples(cfg.benchmarkConfidenceInterval(), cfg.benchmarkResamples(), samples.begin(), samples.end());
        -: 2557:                    auto outliers = Catch::Benchmark::Detail::classify_outliers(samples.begin(), samples.end());
        -: 2558:
        -: 2559:                    auto wrap_estimate = [](Estimate<double> e) {
        -: 2560:                        return Estimate<Duration> {
        -: 2561:                            Duration(e.point),
        -: 2562:                                Duration(e.lower_bound),
        -: 2563:                                Duration(e.upper_bound),
        -: 2564:                                e.confidence_interval,
        -: 2565:                        };
        -: 2566:                    };
        -: 2567:                    std::vector<Duration> samples2;
        -: 2568:                    samples2.reserve(samples.size());
        -: 2569:                    std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](double d) { return Duration(d); });
        -: 2570:                    return {
        -: 2571:                        std::move(samples2),
        -: 2572:                        wrap_estimate(analysis.mean),
        -: 2573:                        wrap_estimate(analysis.standard_deviation),
        -: 2574:                        outliers,
        -: 2575:                        analysis.outlier_variance,
        -: 2576:                    };
        -: 2577:                } else {
        -: 2578:                    std::vector<Duration> samples; 
        -: 2579:                    samples.reserve(last - first);
        -: 2580:
        -: 2581:                    Duration mean = Duration(0);
        -: 2582:                    int i = 0;
        -: 2583:                    for (auto it = first; it < last; ++it, ++i) {
        -: 2584:                        samples.push_back(Duration(*it));
        -: 2585:                        mean += Duration(*it);
        -: 2586:                    }
        -: 2587:                    mean /= i;
        -: 2588:
        -: 2589:                    return {
        -: 2590:                        std::move(samples),
        -: 2591:                        Estimate<Duration>{mean, mean, mean, 0.0},
        -: 2592:                        Estimate<Duration>{Duration(0), Duration(0), Duration(0), 0.0},
        -: 2593:                        OutlierClassification{},
        -: 2594:                        0.0
        -: 2595:                    };
        -: 2596:                }
        -: 2597:            }
        -: 2598:        } // namespace Detail
        -: 2599:    } // namespace Benchmark
        -: 2600:} // namespace Catch
        -: 2601:
        -: 2602:#endif // CATCH_ANALYSE_HPP_INCLUDED
        -: 2603:
        -: 2604:#include <algorithm>
        -: 2605:#include <functional>
        -: 2606:#include <string>
        -: 2607:#include <vector>
        -: 2608:#include <cmath>
        -: 2609:
        -: 2610:namespace Catch {
        -: 2611:    namespace Benchmark {
        -: 2612:        struct Benchmark {
        -: 2613:            Benchmark(std::string&& benchmarkName)
        -: 2614:                : name(std::move(benchmarkName)) {}
        -: 2615:
        -: 2616:            template <class FUN>
        -: 2617:            Benchmark(std::string&& benchmarkName , FUN &&func)
        -: 2618:                : fun(std::move(func)), name(std::move(benchmarkName)) {}
        -: 2619:
        -: 2620:            template <typename Clock>
        -: 2621:            ExecutionPlan<FloatDuration<Clock>> prepare(const IConfig &cfg, Environment<FloatDuration<Clock>> env) const {
        -: 2622:                auto min_time = env.clock_resolution.mean * Detail::minimum_ticks;
        -: 2623:                auto run_time = std::max(min_time, std::chrono::duration_cast<decltype(min_time)>(cfg.benchmarkWarmupTime()));
        -: 2624:                auto&& test = Detail::run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(run_time), 1, fun);
        -: 2625:                int new_iters = static_cast<int>(std::ceil(min_time * test.iterations / test.elapsed));
        -: 2626:                return { new_iters, test.elapsed / test.iterations * new_iters * cfg.benchmarkSamples(), fun, std::chrono::duration_cast<FloatDuration<Clock>>(cfg.benchmarkWarmupTime()), Detail::warmup_iterations };
        -: 2627:            }
        -: 2628:
        -: 2629:            template <typename Clock = default_clock>
        -: 2630:            void run() {
        -: 2631:                auto const* cfg = getCurrentContext().getConfig();
        -: 2632:
        -: 2633:                auto env = Detail::measure_environment<Clock>();
        -: 2634:
        -: 2635:                getResultCapture().benchmarkPreparing(name);
        -: 2636:                CATCH_TRY{
        -: 2637:                    auto plan = user_code([&] {
        -: 2638:                        return prepare<Clock>(*cfg, env);
        -: 2639:                    });
        -: 2640:
        -: 2641:                    BenchmarkInfo info {
        -: 2642:                        name,
        -: 2643:                        plan.estimated_duration.count(),
        -: 2644:                        plan.iterations_per_sample,
        -: 2645:                        cfg->benchmarkSamples(),
        -: 2646:                        cfg->benchmarkResamples(),
        -: 2647:                        env.clock_resolution.mean.count(),
        -: 2648:                        env.clock_cost.mean.count()
        -: 2649:                    };
        -: 2650:
        -: 2651:                    getResultCapture().benchmarkStarting(info);
        -: 2652:
        -: 2653:                    auto samples = user_code([&] {
        -: 2654:                        return plan.template run<Clock>(*cfg, env);
        -: 2655:                    });
        -: 2656:
        -: 2657:                    auto analysis = Detail::analyse(*cfg, env, samples.begin(), samples.end());
        -: 2658:                    BenchmarkStats<FloatDuration<Clock>> stats{ info, analysis.samples, analysis.mean, analysis.standard_deviation, analysis.outliers, analysis.outlier_variance };
        -: 2659:                    getResultCapture().benchmarkEnded(stats);
        -: 2660:
        -: 2661:                } CATCH_CATCH_ALL{
        -: 2662:                    if (translateActiveException() != Detail::benchmarkErrorMsg) // benchmark errors have been reported, otherwise rethrow.
        -: 2663:                        std::rethrow_exception(std::current_exception());
        -: 2664:                }
        -: 2665:            }
        -: 2666:
        -: 2667:            // sets lambda to be used in fun *and* executes benchmark!
        -: 2668:            template <typename Fun,
        -: 2669:                typename std::enable_if<!Detail::is_related<Fun, Benchmark>::value, int>::type = 0>
        -: 2670:                Benchmark & operator=(Fun func) {
        -: 2671:                fun = Detail::BenchmarkFunction(func);
        -: 2672:                run();
        -: 2673:                return *this;
        -: 2674:            }
        -: 2675:
        -: 2676:            explicit operator bool() {
        -: 2677:                return true;
        -: 2678:            }
        -: 2679:
        -: 2680:        private:
        -: 2681:            Detail::BenchmarkFunction fun;
        -: 2682:            std::string name;
        -: 2683:        };
        -: 2684:    }
        -: 2685:} // namespace Catch
        -: 2686:
        -: 2687:#define INTERNAL_CATCH_GET_1_ARG(arg1, arg2, ...) arg1
        -: 2688:#define INTERNAL_CATCH_GET_2_ARG(arg1, arg2, ...) arg2
        -: 2689:
        -: 2690:#define INTERNAL_CATCH_BENCHMARK(BenchmarkName, name, benchmarkIndex)\
        -: 2691:    if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \
        -: 2692:        BenchmarkName = [&](int benchmarkIndex)
        -: 2693:
        -: 2694:#define INTERNAL_CATCH_BENCHMARK_ADVANCED(BenchmarkName, name)\
        -: 2695:    if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \
        -: 2696:        BenchmarkName = [&]
        -: 2697:
        -: 2698:#if defined(CATCH_CONFIG_PREFIX_ALL)
        -: 2699:
        -: 2700:#define CATCH_BENCHMARK(...) \
        -: 2701:    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
        -: 2702:#define CATCH_BENCHMARK_ADVANCED(name) \
        -: 2703:    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)
        -: 2704:
        -: 2705:#else
        -: 2706:
        -: 2707:#define BENCHMARK(...) \
        -: 2708:    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
        -: 2709:#define BENCHMARK_ADVANCED(name) \
        -: 2710:    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)
        -: 2711:
        -: 2712:#endif
        -: 2713:
        -: 2714:#endif // CATCH_BENCHMARK_HPP_INCLUDED
        -: 2715:
        -: 2716:
        -: 2717:// Adapted from donated nonius code.
        -: 2718:
        -: 2719:#ifndef CATCH_CONSTRUCTOR_HPP_INCLUDED
        -: 2720:#define CATCH_CONSTRUCTOR_HPP_INCLUDED
        -: 2721:
        -: 2722:#include <type_traits>
        -: 2723:
        -: 2724:namespace Catch {
        -: 2725:    namespace Benchmark {
        -: 2726:        namespace Detail {
        -: 2727:            template <typename T, bool Destruct>
        -: 2728:            struct ObjectStorage
        -: 2729:            {
        -: 2730:                using TStorage = typename std::aligned_storage<sizeof(T), std::alignment_of<T>::value>::type;
        -: 2731:
        -: 2732:                ObjectStorage() : data() {}
        -: 2733:
        -: 2734:                ObjectStorage(const ObjectStorage& other)
        -: 2735:                {
        -: 2736:                    new(&data) T(other.stored_object());
        -: 2737:                }
        -: 2738:
        -: 2739:                ObjectStorage(ObjectStorage&& other)
        -: 2740:                {
        -: 2741:                    new(&data) T(std::move(other.stored_object()));
        -: 2742:                }
        -: 2743:
        -: 2744:                ~ObjectStorage() { destruct_on_exit<T>(); }
        -: 2745:
        -: 2746:                template <typename... Args>
        -: 2747:                void construct(Args&&... args)
        -: 2748:                {
        -: 2749:                    new (&data) T(std::forward<Args>(args)...);
        -: 2750:                }
        -: 2751:
        -: 2752:                template <bool AllowManualDestruction = !Destruct>
        -: 2753:                typename std::enable_if<AllowManualDestruction>::type destruct()
        -: 2754:                {
        -: 2755:                    stored_object().~T();
        -: 2756:                }
        -: 2757:
        -: 2758:            private:
        -: 2759:                // If this is a constructor benchmark, destruct the underlying object
        -: 2760:                template <typename U>
        -: 2761:                void destruct_on_exit(typename std::enable_if<Destruct, U>::type* = 0) { destruct<true>(); }
        -: 2762:                // Otherwise, don't
        -: 2763:                template <typename U>
        -: 2764:                void destruct_on_exit(typename std::enable_if<!Destruct, U>::type* = 0) { }
        -: 2765:
        -: 2766:                T& stored_object() {
        -: 2767:                    return *static_cast<T*>(static_cast<void*>(&data));
        -: 2768:                }
        -: 2769:
        -: 2770:                T const& stored_object() const {
        -: 2771:                    return *static_cast<T*>(static_cast<void*>(&data));
        -: 2772:                }
        -: 2773:
        -: 2774:
        -: 2775:                TStorage data;
        -: 2776:            };
        -: 2777:        } // namespace Detail
        -: 2778:
        -: 2779:        template <typename T>
        -: 2780:        using storage_for = Detail::ObjectStorage<T, true>;
        -: 2781:
        -: 2782:        template <typename T>
        -: 2783:        using destructable_object = Detail::ObjectStorage<T, false>;
        -: 2784:    } // namespace Benchmark
        -: 2785:} // namespace Catch
        -: 2786:
        -: 2787:#endif // CATCH_CONSTRUCTOR_HPP_INCLUDED
        -: 2788:
        -: 2789:#endif // CATCH_BENCHMARK_ALL_HPP_INCLUDED
        -: 2790:
        -: 2791:
        -: 2792:#ifndef CATCH_APPROX_HPP_INCLUDED
        -: 2793:#define CATCH_APPROX_HPP_INCLUDED
        -: 2794:
        -: 2795:
        -: 2796:
        -: 2797:#ifndef CATCH_TOSTRING_HPP_INCLUDED
        -: 2798:#define CATCH_TOSTRING_HPP_INCLUDED
        -: 2799:
        -: 2800:
        -: 2801:#include <vector>
        -: 2802:#include <cstddef>
        -: 2803:#include <type_traits>
        -: 2804:#include <string>
        -: 2805:
        -: 2806:
        -: 2807:#ifndef CATCH_INTERFACES_ENUM_VALUES_REGISTRY_HPP_INCLUDED
        -: 2808:#define CATCH_INTERFACES_ENUM_VALUES_REGISTRY_HPP_INCLUDED
        -: 2809:
        -: 2810:
        -: 2811:#include <vector>
        -: 2812:
        -: 2813:namespace Catch {
        -: 2814:
        -: 2815:    namespace Detail {
        -: 2816:        struct EnumInfo {
        -: 2817:            StringRef m_name;
        -: 2818:            std::vector<std::pair<int, StringRef>> m_values;
        -: 2819:
        -: 2820:            ~EnumInfo();
        -: 2821:
        -: 2822:            StringRef lookup( int value ) const;
        -: 2823:        };
        -: 2824:    } // namespace Detail
        -: 2825:
        1: 2826:    struct IMutableEnumValuesRegistry {
        -: 2827:        virtual ~IMutableEnumValuesRegistry();
        -: 2828:
        -: 2829:        virtual Detail::EnumInfo const& registerEnum( StringRef enumName, StringRef allEnums, std::vector<int> const& values ) = 0;
        -: 2830:
        -: 2831:        template<typename E>
        -: 2832:        Detail::EnumInfo const& registerEnum( StringRef enumName, StringRef allEnums, std::initializer_list<E> values ) {
        -: 2833:            static_assert(sizeof(int) >= sizeof(E), "Cannot serialize enum to int");
        -: 2834:            std::vector<int> intValues;
        -: 2835:            intValues.reserve( values.size() );
        -: 2836:            for( auto enumValue : values )
        -: 2837:                intValues.push_back( static_cast<int>( enumValue ) );
        -: 2838:            return registerEnum( enumName, allEnums, intValues );
        -: 2839:        }
        -: 2840:    };
        -: 2841:
        -: 2842:} // Catch
        -: 2843:
        -: 2844:#endif // CATCH_INTERFACES_ENUM_VALUES_REGISTRY_HPP_INCLUDED
        -: 2845:
        -: 2846:#ifdef CATCH_CONFIG_CPP17_STRING_VIEW
        -: 2847:#include <string_view>
        -: 2848:#endif
        -: 2849:
        -: 2850:#ifdef _MSC_VER
        -: 2851:#pragma warning(push)
        -: 2852:#pragma warning(disable:4180) // We attempt to stream a function (address) by const&, which MSVC complains about but is harmless
        -: 2853:#endif
        -: 2854:
        -: 2855:namespace Catch {
        -: 2856:    namespace Detail {
        -: 2857:
        -: 2858:        extern const std::string unprintableString;
        -: 2859:
        -: 2860:        std::string rawMemoryToString( const void *object, std::size_t size );
        -: 2861:
        -: 2862:        template<typename T>
        -: 2863:        std::string rawMemoryToString( const T& object ) {
        -: 2864:          return rawMemoryToString( &object, sizeof(object) );
        -: 2865:        }
        -: 2866:
        -: 2867:        template<typename T>
        -: 2868:        class IsStreamInsertable {
        -: 2869:            template<typename Stream, typename U>
        -: 2870:            static auto test(int)
        -: 2871:                -> decltype(std::declval<Stream&>() << std::declval<U>(), std::true_type());
        -: 2872:
        -: 2873:            template<typename, typename>
        -: 2874:            static auto test(...)->std::false_type;
        -: 2875:
        -: 2876:        public:
        -: 2877:            static const bool value = decltype(test<std::ostream, const T&>(0))::value;
        -: 2878:        };
        -: 2879:
        -: 2880:        template<typename E>
        -: 2881:        std::string convertUnknownEnumToString( E e );
        -: 2882:
        -: 2883:        template<typename T>
        -: 2884:        std::enable_if_t<
        -: 2885:            !std::is_enum<T>::value && !std::is_base_of<std::exception, T>::value,
        -: 2886:        std::string> convertUnstreamable( T const& ) {
        -: 2887:            return Detail::unprintableString;
        -: 2888:        }
        -: 2889:        template<typename T>
        -: 2890:        std::enable_if_t<
        -: 2891:            !std::is_enum<T>::value && std::is_base_of<std::exception, T>::value,
        -: 2892:         std::string> convertUnstreamable(T const& ex) {
        -: 2893:            return ex.what();
        -: 2894:        }
        -: 2895:
        -: 2896:
        -: 2897:        template<typename T>
        -: 2898:        std::enable_if_t<
        -: 2899:            std::is_enum<T>::value,
        -: 2900:        std::string> convertUnstreamable( T const& value ) {
        -: 2901:            return convertUnknownEnumToString( value );
        -: 2902:        }
        -: 2903:
        -: 2904:#if defined(_MANAGED)
        -: 2905:        //! Convert a CLR string to a utf8 std::string
        -: 2906:        template<typename T>
        -: 2907:        std::string clrReferenceToString( T^ ref ) {
        -: 2908:            if (ref == nullptr)
        -: 2909:                return std::string("null");
        -: 2910:            auto bytes = System::Text::Encoding::UTF8->GetBytes(ref->ToString());
        -: 2911:            cli::pin_ptr<System::Byte> p = &bytes[0];
        -: 2912:            return std::string(reinterpret_cast<char const *>(p), bytes->Length);
        -: 2913:        }
        -: 2914:#endif
        -: 2915:
        -: 2916:    } // namespace Detail
        -: 2917:
        -: 2918:
        -: 2919:    // If we decide for C++14, change these to enable_if_ts
        -: 2920:    template <typename T, typename = void>
        -: 2921:    struct StringMaker {
        -: 2922:        template <typename Fake = T>
        -: 2923:        static
        -: 2924:        std::enable_if_t<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>
    #####: 2925:            convert(const Fake& value) {
    #####: 2926:                ReusableStringStream rss;
        -: 2927:                // NB: call using the function-like syntax to avoid ambiguity with
        -: 2928:                // user-defined templated operator<< under clang.
        -: 2929:                rss.operator<<(value);
    #####: 2930:                return rss.str();
        -: 2931:        }
        -: 2932:
        -: 2933:        template <typename Fake = T>
        -: 2934:        static
        -: 2935:        std::enable_if_t<!::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>
        -: 2936:            convert( const Fake& value ) {
        -: 2937:#if !defined(CATCH_CONFIG_FALLBACK_STRINGIFIER)
        -: 2938:            return Detail::convertUnstreamable(value);
        -: 2939:#else
        -: 2940:            return CATCH_CONFIG_FALLBACK_STRINGIFIER(value);
        -: 2941:#endif
        -: 2942:        }
        -: 2943:    };
        -: 2944:
        -: 2945:    namespace Detail {
        -: 2946:
        -: 2947:        // This function dispatches all stringification requests inside of Catch.
        -: 2948:        // Should be preferably called fully qualified, like ::Catch::Detail::stringify
        -: 2949:        template <typename T>
        -: 2950:        std::string stringify(const T& e) {
    #####: 2951:            return ::Catch::StringMaker<std::remove_cv_t<std::remove_reference_t<T>>>::convert(e);
        -: 2952:        }
        -: 2953:
        -: 2954:        template<typename E>
        -: 2955:        std::string convertUnknownEnumToString( E e ) {
        -: 2956:            return ::Catch::Detail::stringify(static_cast<std::underlying_type_t<E>>(e));
        -: 2957:        }
        -: 2958:
        -: 2959:#if defined(_MANAGED)
        -: 2960:        template <typename T>
        -: 2961:        std::string stringify( T^ e ) {
        -: 2962:            return ::Catch::StringMaker<T^>::convert(e);
        -: 2963:        }
        -: 2964:#endif
        -: 2965:
        -: 2966:    } // namespace Detail
        -: 2967:
        -: 2968:    // Some predefined specializations
        -: 2969:
        -: 2970:    template<>
        -: 2971:    struct StringMaker<std::string> {
        -: 2972:        static std::string convert(const std::string& str);
        -: 2973:    };
        -: 2974:
        -: 2975:#ifdef CATCH_CONFIG_CPP17_STRING_VIEW
        -: 2976:    template<>
        -: 2977:    struct StringMaker<std::string_view> {
        -: 2978:        static std::string convert(std::string_view str);
        -: 2979:    };
        -: 2980:#endif
        -: 2981:
        -: 2982:    template<>
        -: 2983:    struct StringMaker<char const *> {
        -: 2984:        static std::string convert(char const * str);
        -: 2985:    };
        -: 2986:    template<>
        -: 2987:    struct StringMaker<char *> {
        -: 2988:        static std::string convert(char * str);
        -: 2989:    };
        -: 2990:
        -: 2991:#ifdef CATCH_CONFIG_WCHAR
        -: 2992:    template<>
        -: 2993:    struct StringMaker<std::wstring> {
        -: 2994:        static std::string convert(const std::wstring& wstr);
        -: 2995:    };
        -: 2996:
        -: 2997:# ifdef CATCH_CONFIG_CPP17_STRING_VIEW
        -: 2998:    template<>
        -: 2999:    struct StringMaker<std::wstring_view> {
        -: 3000:        static std::string convert(std::wstring_view str);
        -: 3001:    };
        -: 3002:# endif
        -: 3003:
        -: 3004:    template<>
        -: 3005:    struct StringMaker<wchar_t const *> {
        -: 3006:        static std::string convert(wchar_t const * str);
        -: 3007:    };
        -: 3008:    template<>
        -: 3009:    struct StringMaker<wchar_t *> {
        -: 3010:        static std::string convert(wchar_t * str);
        -: 3011:    };
        -: 3012:#endif
        -: 3013:
        -: 3014:    // TBD: Should we use `strnlen` to ensure that we don't go out of the buffer,
        -: 3015:    //      while keeping string semantics?
        -: 3016:    template<int SZ>
        -: 3017:    struct StringMaker<char[SZ]> {
        -: 3018:        static std::string convert(char const* str) {
        -: 3019:            return ::Catch::Detail::stringify(std::string{ str });
        -: 3020:        }
        -: 3021:    };
        -: 3022:    template<int SZ>
        -: 3023:    struct StringMaker<signed char[SZ]> {
        -: 3024:        static std::string convert(signed char const* str) {
        -: 3025:            return ::Catch::Detail::stringify(std::string{ reinterpret_cast<char const *>(str) });
        -: 3026:        }
        -: 3027:    };
        -: 3028:    template<int SZ>
        -: 3029:    struct StringMaker<unsigned char[SZ]> {
        -: 3030:        static std::string convert(unsigned char const* str) {
        -: 3031:            return ::Catch::Detail::stringify(std::string{ reinterpret_cast<char const *>(str) });
        -: 3032:        }
        -: 3033:    };
        -: 3034:
        -: 3035:#if defined(CATCH_CONFIG_CPP17_BYTE)
        -: 3036:    template<>
        -: 3037:    struct StringMaker<std::byte> {
        -: 3038:        static std::string convert(std::byte value);
        -: 3039:    };
        -: 3040:#endif // defined(CATCH_CONFIG_CPP17_BYTE)
        -: 3041:    template<>
        -: 3042:    struct StringMaker<int> {
        -: 3043:        static std::string convert(int value);
        -: 3044:    };
        -: 3045:    template<>
        -: 3046:    struct StringMaker<long> {
        -: 3047:        static std::string convert(long value);
        -: 3048:    };
        -: 3049:    template<>
        -: 3050:    struct StringMaker<long long> {
        -: 3051:        static std::string convert(long long value);
        -: 3052:    };
        -: 3053:    template<>
        -: 3054:    struct StringMaker<unsigned int> {
        -: 3055:        static std::string convert(unsigned int value);
        -: 3056:    };
        -: 3057:    template<>
        -: 3058:    struct StringMaker<unsigned long> {
        -: 3059:        static std::string convert(unsigned long value);
        -: 3060:    };
        -: 3061:    template<>
        -: 3062:    struct StringMaker<unsigned long long> {
        -: 3063:        static std::string convert(unsigned long long value);
        -: 3064:    };
        -: 3065:
        -: 3066:    template<>
        -: 3067:    struct StringMaker<bool> {
        -: 3068:        static std::string convert(bool b) {
        -: 3069:            using namespace std::string_literals;
        -: 3070:            return b ? "true"s : "false"s;
        -: 3071:        }
        -: 3072:    };
        -: 3073:
        -: 3074:    template<>
        -: 3075:    struct StringMaker<char> {
        -: 3076:        static std::string convert(char c);
        -: 3077:    };
        -: 3078:    template<>
        -: 3079:    struct StringMaker<signed char> {
        -: 3080:        static std::string convert(signed char c);
        -: 3081:    };
        -: 3082:    template<>
        -: 3083:    struct StringMaker<unsigned char> {
        -: 3084:        static std::string convert(unsigned char c);
        -: 3085:    };
        -: 3086:
        -: 3087:    template<>
        -: 3088:    struct StringMaker<std::nullptr_t> {
        -: 3089:        static std::string convert(std::nullptr_t) {
        -: 3090:            using namespace std::string_literals;
        -: 3091:            return "nullptr"s;
        -: 3092:        }
        -: 3093:    };
        -: 3094:
        -: 3095:    template<>
        -: 3096:    struct StringMaker<float> {
        -: 3097:        static std::string convert(float value);
        -: 3098:        static int precision;
        -: 3099:    };
        -: 3100:
        -: 3101:    template<>
        -: 3102:    struct StringMaker<double> {
        -: 3103:        static std::string convert(double value);
        -: 3104:        static int precision;
        -: 3105:    };
        -: 3106:
        -: 3107:    template <typename T>
        -: 3108:    struct StringMaker<T*> {
        -: 3109:        template <typename U>
        -: 3110:        static std::string convert(U* p) {
        -: 3111:            if (p) {
        -: 3112:                return ::Catch::Detail::rawMemoryToString(p);
        -: 3113:            } else {
        -: 3114:                return "nullptr";
        -: 3115:            }
        -: 3116:        }
        -: 3117:    };
        -: 3118:
        -: 3119:    template <typename R, typename C>
        -: 3120:    struct StringMaker<R C::*> {
        -: 3121:        static std::string convert(R C::* p) {
        -: 3122:            if (p) {
        -: 3123:                return ::Catch::Detail::rawMemoryToString(p);
        -: 3124:            } else {
        -: 3125:                return "nullptr";
        -: 3126:            }
        -: 3127:        }
        -: 3128:    };
        -: 3129:
        -: 3130:#if defined(_MANAGED)
        -: 3131:    template <typename T>
        -: 3132:    struct StringMaker<T^> {
        -: 3133:        static std::string convert( T^ ref ) {
        -: 3134:            return ::Catch::Detail::clrReferenceToString(ref);
        -: 3135:        }
        -: 3136:    };
        -: 3137:#endif
        -: 3138:
        -: 3139:    namespace Detail {
        -: 3140:        template<typename InputIterator, typename Sentinel = InputIterator>
        -: 3141:        std::string rangeToString(InputIterator first, Sentinel last) {
        -: 3142:            ReusableStringStream rss;
        -: 3143:            rss << "{ ";
        -: 3144:            if (first != last) {
        -: 3145:                rss << ::Catch::Detail::stringify(*first);
        -: 3146:                for (++first; first != last; ++first)
        -: 3147:                    rss << ", " << ::Catch::Detail::stringify(*first);
        -: 3148:            }
        -: 3149:            rss << " }";
        -: 3150:            return rss.str();
        -: 3151:        }
        -: 3152:    }
        -: 3153:
        -: 3154:} // namespace Catch
        -: 3155:
        -: 3156://////////////////////////////////////////////////////
        -: 3157:// Separate std-lib types stringification, so it can be selectively enabled
        -: 3158:// This means that we do not bring in their headers
        -: 3159:
        -: 3160:#if defined(CATCH_CONFIG_ENABLE_ALL_STRINGMAKERS)
        -: 3161:#  define CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER
        -: 3162:#  define CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER
        -: 3163:#  define CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER
        -: 3164:#  define CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER
        -: 3165:#endif
        -: 3166:
        -: 3167:// Separate std::pair specialization
        -: 3168:#if defined(CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER)
        -: 3169:#include <utility>
        -: 3170:namespace Catch {
        -: 3171:    template<typename T1, typename T2>
        -: 3172:    struct StringMaker<std::pair<T1, T2> > {
        -: 3173:        static std::string convert(const std::pair<T1, T2>& pair) {
        -: 3174:            ReusableStringStream rss;
        -: 3175:            rss << "{ "
        -: 3176:                << ::Catch::Detail::stringify(pair.first)
        -: 3177:                << ", "
        -: 3178:                << ::Catch::Detail::stringify(pair.second)
        -: 3179:                << " }";
        -: 3180:            return rss.str();
        -: 3181:        }
        -: 3182:    };
        -: 3183:}
        -: 3184:#endif // CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER
        -: 3185:
        -: 3186:#if defined(CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER) && defined(CATCH_CONFIG_CPP17_OPTIONAL)
        -: 3187:#include <optional>
        -: 3188:namespace Catch {
        -: 3189:    template<typename T>
        -: 3190:    struct StringMaker<std::optional<T> > {
        -: 3191:        static std::string convert(const std::optional<T>& optional) {
        -: 3192:            ReusableStringStream rss;
        -: 3193:            if (optional.has_value()) {
        -: 3194:                rss << ::Catch::Detail::stringify(*optional);
        -: 3195:            } else {
        -: 3196:                rss << "{ }";
        -: 3197:            }
        -: 3198:            return rss.str();
        -: 3199:        }
        -: 3200:    };
        -: 3201:}
        -: 3202:#endif // CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER
        -: 3203:
        -: 3204:// Separate std::tuple specialization
        -: 3205:#if defined(CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER)
        -: 3206:#include <tuple>
        -: 3207:namespace Catch {
        -: 3208:    namespace Detail {
        -: 3209:        template<
        -: 3210:            typename Tuple,
        -: 3211:            std::size_t N = 0,
        -: 3212:            bool = (N < std::tuple_size<Tuple>::value)
        -: 3213:            >
        -: 3214:            struct TupleElementPrinter {
        -: 3215:            static void print(const Tuple& tuple, std::ostream& os) {
        -: 3216:                os << (N ? ", " : " ")
        -: 3217:                    << ::Catch::Detail::stringify(std::get<N>(tuple));
        -: 3218:                TupleElementPrinter<Tuple, N + 1>::print(tuple, os);
        -: 3219:            }
        -: 3220:        };
        -: 3221:
        -: 3222:        template<
        -: 3223:            typename Tuple,
        -: 3224:            std::size_t N
        -: 3225:        >
        -: 3226:            struct TupleElementPrinter<Tuple, N, false> {
        -: 3227:            static void print(const Tuple&, std::ostream&) {}
        -: 3228:        };
        -: 3229:
        -: 3230:    }
        -: 3231:
        -: 3232:
        -: 3233:    template<typename ...Types>
        -: 3234:    struct StringMaker<std::tuple<Types...>> {
        -: 3235:        static std::string convert(const std::tuple<Types...>& tuple) {
        -: 3236:            ReusableStringStream rss;
        -: 3237:            rss << '{';
        -: 3238:            Detail::TupleElementPrinter<std::tuple<Types...>>::print(tuple, rss.get());
        -: 3239:            rss << " }";
        -: 3240:            return rss.str();
        -: 3241:        }
        -: 3242:    };
        -: 3243:}
        -: 3244:#endif // CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER
        -: 3245:
        -: 3246:#if defined(CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER) && defined(CATCH_CONFIG_CPP17_VARIANT)
        -: 3247:#include <variant>
        -: 3248:namespace Catch {
        -: 3249:    template<>
        -: 3250:    struct StringMaker<std::monostate> {
        -: 3251:        static std::string convert(const std::monostate&) {
        -: 3252:            return "{ }";
        -: 3253:        }
        -: 3254:    };
        -: 3255:
        -: 3256:    template<typename... Elements>
        -: 3257:    struct StringMaker<std::variant<Elements...>> {
        -: 3258:        static std::string convert(const std::variant<Elements...>& variant) {
        -: 3259:            if (variant.valueless_by_exception()) {
        -: 3260:                return "{valueless variant}";
        -: 3261:            } else {
        -: 3262:                return std::visit(
        -: 3263:                    [](const auto& value) {
        -: 3264:                        return ::Catch::Detail::stringify(value);
        -: 3265:                    },
        -: 3266:                    variant
        -: 3267:                );
        -: 3268:            }
        -: 3269:        }
        -: 3270:    };
        -: 3271:}
        -: 3272:#endif // CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER
        -: 3273:
        -: 3274:namespace Catch {
        -: 3275:    // Import begin/ end from std here
        -: 3276:    using std::begin;
        -: 3277:    using std::end;
        -: 3278:
        -: 3279:    namespace detail {
        -: 3280:        template <typename...>
        -: 3281:        struct void_type {
        -: 3282:            using type = void;
        -: 3283:        };
        -: 3284:
        -: 3285:        template <typename T, typename = void>
        -: 3286:        struct is_range_impl : std::false_type {
        -: 3287:        };
        -: 3288:
        -: 3289:        template <typename T>
        -: 3290:        struct is_range_impl<T, typename void_type<decltype(begin(std::declval<T>()))>::type> : std::true_type {
        -: 3291:        };
        -: 3292:    } // namespace detail
        -: 3293:
        -: 3294:    template <typename T>
        -: 3295:    struct is_range : detail::is_range_impl<T> {
        -: 3296:    };
        -: 3297:
        -: 3298:#if defined(_MANAGED) // Managed types are never ranges
        -: 3299:    template <typename T>
        -: 3300:    struct is_range<T^> {
        -: 3301:        static const bool value = false;
        -: 3302:    };
        -: 3303:#endif
        -: 3304:
        -: 3305:    template<typename Range>
        -: 3306:    std::string rangeToString( Range const& range ) {
        -: 3307:        return ::Catch::Detail::rangeToString( begin( range ), end( range ) );
        -: 3308:    }
        -: 3309:
        -: 3310:    // Handle vector<bool> specially
        -: 3311:    template<typename Allocator>
        -: 3312:    std::string rangeToString( std::vector<bool, Allocator> const& v ) {
        -: 3313:        ReusableStringStream rss;
        -: 3314:        rss << "{ ";
        -: 3315:        bool first = true;
        -: 3316:        for( bool b : v ) {
        -: 3317:            if( first )
        -: 3318:                first = false;
        -: 3319:            else
        -: 3320:                rss << ", ";
        -: 3321:            rss << ::Catch::Detail::stringify( b );
        -: 3322:        }
        -: 3323:        rss << " }";
        -: 3324:        return rss.str();
        -: 3325:    }
        -: 3326:
        -: 3327:    template<typename R>
        -: 3328:    struct StringMaker<R, std::enable_if_t<is_range<R>::value && !::Catch::Detail::IsStreamInsertable<R>::value>> {
        -: 3329:        static std::string convert( R const& range ) {
        -: 3330:            return rangeToString( range );
        -: 3331:        }
        -: 3332:    };
        -: 3333:
        -: 3334:    template <typename T, int SZ>
        -: 3335:    struct StringMaker<T[SZ]> {
        -: 3336:        static std::string convert(T const(&arr)[SZ]) {
        -: 3337:            return rangeToString(arr);
        -: 3338:        }
        -: 3339:    };
        -: 3340:
        -: 3341:
        -: 3342:} // namespace Catch
        -: 3343:
        -: 3344:// Separate std::chrono::duration specialization
        -: 3345:#include <ctime>
        -: 3346:#include <ratio>
        -: 3347:#include <chrono>
        -: 3348:
        -: 3349:
        -: 3350:namespace Catch {
        -: 3351:
        -: 3352:template <class Ratio>
        -: 3353:struct ratio_string {
        -: 3354:    static std::string symbol() {
        -: 3355:        Catch::ReusableStringStream rss;
        -: 3356:        rss << '[' << Ratio::num << '/'
        -: 3357:            << Ratio::den << ']';
        -: 3358:        return rss.str();
        -: 3359:    }
        -: 3360:};
        -: 3361:
        -: 3362:template <>
        -: 3363:struct ratio_string<std::atto> {
        -: 3364:    static std::string symbol() { return "a"; }
        -: 3365:};
        -: 3366:template <>
        -: 3367:struct ratio_string<std::femto> {
        -: 3368:    static std::string symbol() { return "f"; }
        -: 3369:};
        -: 3370:template <>
        -: 3371:struct ratio_string<std::pico> {
        -: 3372:    static std::string symbol() { return "p"; }
        -: 3373:};
        -: 3374:template <>
        -: 3375:struct ratio_string<std::nano> {
        -: 3376:    static std::string symbol() { return "n"; }
        -: 3377:};
        -: 3378:template <>
        -: 3379:struct ratio_string<std::micro> {
        -: 3380:    static std::string symbol() { return "u"; }
        -: 3381:};
        -: 3382:template <>
        -: 3383:struct ratio_string<std::milli> {
        -: 3384:    static std::string symbol() { return "m"; }
        -: 3385:};
        -: 3386:
        -: 3387:    ////////////
        -: 3388:    // std::chrono::duration specializations
        -: 3389:    template<typename Value, typename Ratio>
        -: 3390:    struct StringMaker<std::chrono::duration<Value, Ratio>> {
        -: 3391:        static std::string convert(std::chrono::duration<Value, Ratio> const& duration) {
        -: 3392:            ReusableStringStream rss;
        -: 3393:            rss << duration.count() << ' ' << ratio_string<Ratio>::symbol() << 's';
        -: 3394:            return rss.str();
        -: 3395:        }
        -: 3396:    };
        -: 3397:    template<typename Value>
        -: 3398:    struct StringMaker<std::chrono::duration<Value, std::ratio<1>>> {
        -: 3399:        static std::string convert(std::chrono::duration<Value, std::ratio<1>> const& duration) {
        -: 3400:            ReusableStringStream rss;
        -: 3401:            rss << duration.count() << " s";
        -: 3402:            return rss.str();
        -: 3403:        }
        -: 3404:    };
        -: 3405:    template<typename Value>
        -: 3406:    struct StringMaker<std::chrono::duration<Value, std::ratio<60>>> {
        -: 3407:        static std::string convert(std::chrono::duration<Value, std::ratio<60>> const& duration) {
        -: 3408:            ReusableStringStream rss;
        -: 3409:            rss << duration.count() << " m";
        -: 3410:            return rss.str();
        -: 3411:        }
        -: 3412:    };
        -: 3413:    template<typename Value>
        -: 3414:    struct StringMaker<std::chrono::duration<Value, std::ratio<3600>>> {
        -: 3415:        static std::string convert(std::chrono::duration<Value, std::ratio<3600>> const& duration) {
        -: 3416:            ReusableStringStream rss;
        -: 3417:            rss << duration.count() << " h";
        -: 3418:            return rss.str();
        -: 3419:        }
        -: 3420:    };
        -: 3421:
        -: 3422:    ////////////
        -: 3423:    // std::chrono::time_point specialization
        -: 3424:    // Generic time_point cannot be specialized, only std::chrono::time_point<system_clock>
        -: 3425:    template<typename Clock, typename Duration>
        -: 3426:    struct StringMaker<std::chrono::time_point<Clock, Duration>> {
        -: 3427:        static std::string convert(std::chrono::time_point<Clock, Duration> const& time_point) {
        -: 3428:            return ::Catch::Detail::stringify(time_point.time_since_epoch()) + " since epoch";
        -: 3429:        }
        -: 3430:    };
        -: 3431:    // std::chrono::time_point<system_clock> specialization
        -: 3432:    template<typename Duration>
        -: 3433:    struct StringMaker<std::chrono::time_point<std::chrono::system_clock, Duration>> {
        -: 3434:        static std::string convert(std::chrono::time_point<std::chrono::system_clock, Duration> const& time_point) {
        -: 3435:            auto converted = std::chrono::system_clock::to_time_t(time_point);
        -: 3436:
        -: 3437:#ifdef _MSC_VER
        -: 3438:            std::tm timeInfo = {};
        -: 3439:            gmtime_s(&timeInfo, &converted);
        -: 3440:#else
        -: 3441:            std::tm* timeInfo = std::gmtime(&converted);
        -: 3442:#endif
        -: 3443:
        -: 3444:            auto const timeStampSize = sizeof("2017-01-16T17:06:45Z");
        -: 3445:            char timeStamp[timeStampSize];
        -: 3446:            const char * const fmt = "%Y-%m-%dT%H:%M:%SZ";
        -: 3447:
        -: 3448:#ifdef _MSC_VER
        -: 3449:            std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);
        -: 3450:#else
        -: 3451:            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
        -: 3452:#endif
        -: 3453:            return std::string(timeStamp);
        -: 3454:        }
        -: 3455:    };
        -: 3456:}
        -: 3457:
        -: 3458:
        -: 3459:#define INTERNAL_CATCH_REGISTER_ENUM( enumName, ... ) \
        -: 3460:namespace Catch { \
        -: 3461:    template<> struct StringMaker<enumName> { \
        -: 3462:        static std::string convert( enumName value ) { \
        -: 3463:            static const auto& enumInfo = ::Catch::getMutableRegistryHub().getMutableEnumValuesRegistry().registerEnum( #enumName, #__VA_ARGS__, { __VA_ARGS__ } ); \
        -: 3464:            return static_cast<std::string>(enumInfo.lookup( static_cast<int>( value ) )); \
        -: 3465:        } \
        -: 3466:    }; \
        -: 3467:}
        -: 3468:
        -: 3469:#define CATCH_REGISTER_ENUM( enumName, ... ) INTERNAL_CATCH_REGISTER_ENUM( enumName, __VA_ARGS__ )
        -: 3470:
        -: 3471:#ifdef _MSC_VER
        -: 3472:#pragma warning(pop)
        -: 3473:#endif
        -: 3474:
        -: 3475:#endif // CATCH_TOSTRING_HPP_INCLUDED
        -: 3476:
        -: 3477:#include <type_traits>
        -: 3478:
        -: 3479:namespace Catch {
        -: 3480:
        -: 3481:    class Approx {
        -: 3482:    private:
        -: 3483:        bool equalityComparisonImpl(double other) const;
        -: 3484:        // Sets and validates the new margin (margin >= 0)
        -: 3485:        void setMargin(double margin);
        -: 3486:        // Sets and validates the new epsilon (0 < epsilon < 1)
        -: 3487:        void setEpsilon(double epsilon);
        -: 3488:
        -: 3489:    public:
        -: 3490:        explicit Approx ( double value );
        -: 3491:
        -: 3492:        static Approx custom();
        -: 3493:
        -: 3494:        Approx operator-() const;
        -: 3495:
        -: 3496:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3497:        Approx operator()( T const& value ) {
        -: 3498:            Approx approx( static_cast<double>(value) );
        -: 3499:            approx.m_epsilon = m_epsilon;
        -: 3500:            approx.m_margin = m_margin;
        -: 3501:            approx.m_scale = m_scale;
        -: 3502:            return approx;
        -: 3503:        }
        -: 3504:
        -: 3505:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
    #####: 3506:        explicit Approx( T const& value ): Approx(static_cast<double>(value))
        -: 3507:        {}
        -: 3508:
        -: 3509:
        -: 3510:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3511:        friend bool operator == ( const T& lhs, Approx const& rhs ) {
        -: 3512:            auto lhs_v = static_cast<double>(lhs);
        -: 3513:            return rhs.equalityComparisonImpl(lhs_v);
        -: 3514:        }
        -: 3515:
        -: 3516:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3517:        friend bool operator == ( Approx const& lhs, const T& rhs ) {
        -: 3518:            return operator==( rhs, lhs );
        -: 3519:        }
        -: 3520:
        -: 3521:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3522:        friend bool operator != ( T const& lhs, Approx const& rhs ) {
        -: 3523:            return !operator==( lhs, rhs );
        -: 3524:        }
        -: 3525:
        -: 3526:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3527:        friend bool operator != ( Approx const& lhs, T const& rhs ) {
        -: 3528:            return !operator==( rhs, lhs );
        -: 3529:        }
        -: 3530:
        -: 3531:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3532:        friend bool operator <= ( T const& lhs, Approx const& rhs ) {
        -: 3533:            return static_cast<double>(lhs) < rhs.m_value || lhs == rhs;
        -: 3534:        }
        -: 3535:
        -: 3536:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3537:        friend bool operator <= ( Approx const& lhs, T const& rhs ) {
        -: 3538:            return lhs.m_value < static_cast<double>(rhs) || lhs == rhs;
        -: 3539:        }
        -: 3540:
        -: 3541:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3542:        friend bool operator >= ( T const& lhs, Approx const& rhs ) {
        -: 3543:            return static_cast<double>(lhs) > rhs.m_value || lhs == rhs;
        -: 3544:        }
        -: 3545:
        -: 3546:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3547:        friend bool operator >= ( Approx const& lhs, T const& rhs ) {
        -: 3548:            return lhs.m_value > static_cast<double>(rhs) || lhs == rhs;
        -: 3549:        }
        -: 3550:
        -: 3551:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3552:        Approx& epsilon( T const& newEpsilon ) {
        -: 3553:            double epsilonAsDouble = static_cast<double>(newEpsilon);
        -: 3554:            setEpsilon(epsilonAsDouble);
        -: 3555:            return *this;
        -: 3556:        }
        -: 3557:
        -: 3558:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3559:        Approx& margin( T const& newMargin ) {
        -: 3560:            double marginAsDouble = static_cast<double>(newMargin);
        -: 3561:            setMargin(marginAsDouble);
        -: 3562:            return *this;
        -: 3563:        }
        -: 3564:
        -: 3565:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3566:        Approx& scale( T const& newScale ) {
        -: 3567:            m_scale = static_cast<double>(newScale);
        -: 3568:            return *this;
        -: 3569:        }
        -: 3570:
        -: 3571:        std::string toString() const;
        -: 3572:
        -: 3573:    private:
        -: 3574:        double m_epsilon;
        -: 3575:        double m_margin;
        -: 3576:        double m_scale;
        -: 3577:        double m_value;
        -: 3578:    };
        -: 3579:
        -: 3580:namespace literals {
        -: 3581:    Approx operator "" _a(long double val);
        -: 3582:    Approx operator "" _a(unsigned long long val);
        -: 3583:} // end namespace literals
        -: 3584:
        -: 3585:template<>
        -: 3586:struct StringMaker<Catch::Approx> {
        -: 3587:    static std::string convert(Catch::Approx const& value);
        -: 3588:};
        -: 3589:
        -: 3590:} // end namespace Catch
        -: 3591:
        -: 3592:#endif // CATCH_APPROX_HPP_INCLUDED
        -: 3593:
        -: 3594:
        -: 3595:#ifndef CATCH_CONFIG_HPP_INCLUDED
        -: 3596:#define CATCH_CONFIG_HPP_INCLUDED
        -: 3597:
        -: 3598:
        -: 3599:
        -: 3600:#ifndef CATCH_TEST_SPEC_HPP_INCLUDED
        -: 3601:#define CATCH_TEST_SPEC_HPP_INCLUDED
        -: 3602:
        -: 3603:#ifdef __clang__
        -: 3604:#pragma clang diagnostic push
        -: 3605:#pragma clang diagnostic ignored "-Wpadded"
        -: 3606:#endif
        -: 3607:
        -: 3608:
        -: 3609:
        -: 3610:#ifndef CATCH_WILDCARD_PATTERN_HPP_INCLUDED
        -: 3611:#define CATCH_WILDCARD_PATTERN_HPP_INCLUDED
        -: 3612:
        -: 3613:
        -: 3614:
        -: 3615:#ifndef CATCH_CASE_SENSITIVE_HPP_INCLUDED
        -: 3616:#define CATCH_CASE_SENSITIVE_HPP_INCLUDED
        -: 3617:
        -: 3618:namespace Catch {
        -: 3619:
        -: 3620:    enum class CaseSensitive { Yes, No };
        -: 3621:
        -: 3622:} // namespace Catch
        -: 3623:
        -: 3624:#endif // CATCH_CASE_SENSITIVE_HPP_INCLUDED
        -: 3625:
        -: 3626:#include <string>
        -: 3627:
        -: 3628:namespace Catch
        -: 3629:{
        -: 3630:    class WildcardPattern {
        -: 3631:        enum WildcardPosition {
        -: 3632:            NoWildcard = 0,
        -: 3633:            WildcardAtStart = 1,
        -: 3634:            WildcardAtEnd = 2,
        -: 3635:            WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd
        -: 3636:        };
        -: 3637:
        -: 3638:    public:
        -: 3639:
        -: 3640:        WildcardPattern( std::string const& pattern, CaseSensitive caseSensitivity );
    #####: 3641:        virtual ~WildcardPattern() = default;
        -: 3642:        virtual bool matches( std::string const& str ) const;
        -: 3643:
        -: 3644:    private:
        -: 3645:        std::string normaliseString( std::string const& str ) const;
        -: 3646:        CaseSensitive m_caseSensitivity;
        -: 3647:        WildcardPosition m_wildcard = NoWildcard;
        -: 3648:        std::string m_pattern;
        -: 3649:    };
        -: 3650:}
        -: 3651:
        -: 3652:#endif // CATCH_WILDCARD_PATTERN_HPP_INCLUDED
        -: 3653:
        -: 3654:#include <string>
        -: 3655:#include <vector>
        -: 3656:
        -: 3657:namespace Catch {
        -: 3658:
        -: 3659:    struct IConfig;
        -: 3660:    struct TestCaseInfo;
        -: 3661:    class TestCaseHandle;
        -: 3662:
        5: 3663:    class TestSpec {
        -: 3664:
    #####: 3665:        class Pattern {
        -: 3666:        public:
        -: 3667:            explicit Pattern( std::string const& name );
        -: 3668:            virtual ~Pattern();
        -: 3669:            virtual bool matches( TestCaseInfo const& testCase ) const = 0;
        -: 3670:            std::string const& name() const;
        -: 3671:        private:
        -: 3672:            std::string const m_name;
        -: 3673:        };
        -: 3674:
    #####: 3675:        class NamePattern : public Pattern {
        -: 3676:        public:
        -: 3677:            explicit NamePattern( std::string const& name, std::string const& filterString );
        -: 3678:            bool matches( TestCaseInfo const& testCase ) const override;
        -: 3679:        private:
        -: 3680:            WildcardPattern m_wildcardPattern;
        -: 3681:        };
        -: 3682:
    #####: 3683:        class TagPattern : public Pattern {
        -: 3684:        public:
        -: 3685:            explicit TagPattern( std::string const& tag, std::string const& filterString );
        -: 3686:            bool matches( TestCaseInfo const& testCase ) const override;
        -: 3687:        private:
        -: 3688:            std::string m_tag;
        -: 3689:        };
        -: 3690:
        1: 3691:        struct Filter {
        -: 3692:            std::vector<Detail::unique_ptr<Pattern>> m_required;
        -: 3693:            std::vector<Detail::unique_ptr<Pattern>> m_forbidden;
        -: 3694:
        -: 3695:            bool matches( TestCaseInfo const& testCase ) const;
        -: 3696:            std::string name() const;
        -: 3697:        };
        -: 3698:
        -: 3699:    public:
    #####: 3700:        struct FilterMatch {
        -: 3701:            std::string name;
        -: 3702:            std::vector<TestCaseHandle const*> tests;
        -: 3703:        };
        -: 3704:        using Matches = std::vector<FilterMatch>;
        -: 3705:        using vectorStrings = std::vector<std::string>;
        -: 3706:
        -: 3707:        bool hasFilters() const;
        -: 3708:        bool matches( TestCaseInfo const& testCase ) const;
        -: 3709:        Matches matchesByFilter( std::vector<TestCaseHandle> const& testCases, IConfig const& config ) const;
        -: 3710:        const vectorStrings & getInvalidArgs() const;
        -: 3711:
        -: 3712:    private:
        -: 3713:        std::vector<Filter> m_filters;
        -: 3714:        std::vector<std::string> m_invalidArgs;
        -: 3715:        friend class TestSpecParser;
        -: 3716:    };
        -: 3717:}
        -: 3718:
        -: 3719:#ifdef __clang__
        -: 3720:#pragma clang diagnostic pop
        -: 3721:#endif
        -: 3722:
        -: 3723:#endif // CATCH_TEST_SPEC_HPP_INCLUDED
        -: 3724:
        -: 3725:#include <vector>
        -: 3726:#include <string>
        -: 3727:
        -: 3728:namespace Catch {
        -: 3729:
        -: 3730:    struct IStream;
        -: 3731:
       12: 3732:    struct ConfigData {
        -: 3733:        bool listTests = false;
        -: 3734:        bool listTags = false;
        -: 3735:        bool listReporters = false;
        -: 3736:
        -: 3737:        bool showSuccessfulTests = false;
        -: 3738:        bool shouldDebugBreak = false;
        -: 3739:        bool noThrow = false;
        -: 3740:        bool showHelp = false;
        -: 3741:        bool showInvisibles = false;
        -: 3742:        bool filenamesAsTags = false;
        -: 3743:        bool libIdentify = false;
        -: 3744:
        -: 3745:        int abortAfter = -1;
        -: 3746:        unsigned int rngSeed = 0;
        -: 3747:
        -: 3748:        bool benchmarkNoAnalysis = false;
        -: 3749:        unsigned int benchmarkSamples = 100;
        -: 3750:        double benchmarkConfidenceInterval = 0.95;
        -: 3751:        unsigned int benchmarkResamples = 100000;
        -: 3752:        std::chrono::milliseconds::rep benchmarkWarmupTime = 100;
        -: 3753:
        -: 3754:        Verbosity verbosity = Verbosity::Normal;
        -: 3755:        WarnAbout::What warnings = WarnAbout::Nothing;
        -: 3756:        ShowDurations showDurations = ShowDurations::DefaultForReporter;
        -: 3757:        double minDuration = -1;
        -: 3758:        TestRunOrder runOrder = TestRunOrder::Declared;
        -: 3759:        UseColour useColour = UseColour::Auto;
        -: 3760:        WaitForKeypress::When waitForKeypress = WaitForKeypress::Never;
        -: 3761:
        -: 3762:        std::string outputFilename;
        -: 3763:        std::string name;
        -: 3764:        std::string processName;
        -: 3765:#ifndef CATCH_CONFIG_DEFAULT_REPORTER
        -: 3766:#define CATCH_CONFIG_DEFAULT_REPORTER "console"
        -: 3767:#endif
        -: 3768:        std::string reporterName = CATCH_CONFIG_DEFAULT_REPORTER;
        -: 3769:#undef CATCH_CONFIG_DEFAULT_REPORTER
        -: 3770:
        -: 3771:        std::vector<std::string> testsOrTags;
        -: 3772:        std::vector<std::string> sectionsToRun;
        -: 3773:    };
        -: 3774:
        -: 3775:
        4: 3776:    class Config : public IConfig {
        -: 3777:    public:
        -: 3778:
        -: 3779:        Config() = default;
        -: 3780:        Config( ConfigData const& data );
        -: 3781:        ~Config() override; // = default in the cpp file
        -: 3782:
        -: 3783:        std::string const& getFilename() const;
        -: 3784:
        -: 3785:        bool listTests() const;
        -: 3786:        bool listTags() const;
        -: 3787:        bool listReporters() const;
        -: 3788:
        -: 3789:        std::string getProcessName() const;
        -: 3790:        std::string const& getReporterName() const;
        -: 3791:
        -: 3792:        std::vector<std::string> const& getTestsOrTags() const override;
        -: 3793:        std::vector<std::string> const& getSectionsToRun() const override;
        -: 3794:
        -: 3795:        TestSpec const& testSpec() const override;
        -: 3796:        bool hasTestFilters() const override;
        -: 3797:
        -: 3798:        bool showHelp() const;
        -: 3799:
        -: 3800:        // IConfig interface
        -: 3801:        bool allowThrows() const override;
        -: 3802:        std::ostream& stream() const override;
        -: 3803:        std::string name() const override;
        -: 3804:        bool includeSuccessfulResults() const override;
        -: 3805:        bool warnAboutMissingAssertions() const override;
        -: 3806:        bool warnAboutNoTests() const override;
        -: 3807:        ShowDurations showDurations() const override;
        -: 3808:        double minDuration() const override;
        -: 3809:        TestRunOrder runOrder() const override;
        -: 3810:        unsigned int rngSeed() const override;
        -: 3811:        UseColour useColour() const override;
        -: 3812:        bool shouldDebugBreak() const override;
        -: 3813:        int abortAfter() const override;
        -: 3814:        bool showInvisibles() const override;
        -: 3815:        Verbosity verbosity() const override;
        -: 3816:        bool benchmarkNoAnalysis() const override;
        -: 3817:        int benchmarkSamples() const override;
        -: 3818:        double benchmarkConfidenceInterval() const override;
        -: 3819:        unsigned int benchmarkResamples() const override;
        -: 3820:        std::chrono::milliseconds benchmarkWarmupTime() const override;
        -: 3821:
        -: 3822:    private:
        -: 3823:
        -: 3824:        IStream const* openStream();
        -: 3825:        ConfigData m_data;
        -: 3826:
        -: 3827:        Detail::unique_ptr<IStream const> m_stream;
        -: 3828:        TestSpec m_testSpec;
        -: 3829:        bool m_hasTestFilters = false;
        -: 3830:    };
        -: 3831:
        -: 3832:} // end namespace Catch
        -: 3833:
        -: 3834:#endif // CATCH_CONFIG_HPP_INCLUDED
        -: 3835:
        -: 3836:
        -: 3837:#ifndef CATCH_MESSAGE_HPP_INCLUDED
        -: 3838:#define CATCH_MESSAGE_HPP_INCLUDED
        -: 3839:
        -: 3840:
        -: 3841:#include <string>
        -: 3842:#include <vector>
        -: 3843:
        -: 3844:namespace Catch {
        -: 3845:
    #####: 3846:    struct MessageStream {
        -: 3847:
        -: 3848:        template<typename T>
        -: 3849:        MessageStream& operator << ( T const& value ) {
        -: 3850:            m_stream << value;
        -: 3851:            return *this;
        -: 3852:        }
        -: 3853:
        -: 3854:        ReusableStringStream m_stream;
        -: 3855:    };
        -: 3856:
    #####: 3857:    struct MessageBuilder : MessageStream {
        -: 3858:        MessageBuilder( StringRef const& macroName,
        -: 3859:                        SourceLineInfo const& lineInfo,
        -: 3860:                        ResultWas::OfType type );
        -: 3861:
        -: 3862:        template<typename T>
        -: 3863:        MessageBuilder& operator << ( T const& value ) {
        -: 3864:            m_stream << value;
        -: 3865:            return *this;
        -: 3866:        }
        -: 3867:
        -: 3868:        MessageInfo m_info;
        -: 3869:    };
        -: 3870:
        -: 3871:    class ScopedMessage {
        -: 3872:    public:
        -: 3873:        explicit ScopedMessage( MessageBuilder const& builder );
        -: 3874:        ScopedMessage( ScopedMessage& duplicate ) = delete;
        -: 3875:        ScopedMessage( ScopedMessage&& old ) noexcept;
        -: 3876:        ~ScopedMessage();
        -: 3877:
        -: 3878:        MessageInfo m_info;
        -: 3879:        bool m_moved = false;
        -: 3880:    };
        -: 3881:
        -: 3882:    class Capturer {
        -: 3883:        std::vector<MessageInfo> m_messages;
    #####: 3884:        IResultCapture& m_resultCapture = getResultCapture();
        -: 3885:        size_t m_captured = 0;
        -: 3886:    public:
        -: 3887:        Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names );
        -: 3888:
        -: 3889:        Capturer(Capturer const&) = delete;
        -: 3890:        Capturer& operator=(Capturer const&) = delete;
        -: 3891:
        -: 3892:        ~Capturer();
        -: 3893:
        -: 3894:        void captureValue( size_t index, std::string const& value );
        -: 3895:
        -: 3896:        template<typename T>
        -: 3897:        void captureValues( size_t index, T const& value ) {
        -: 3898:            captureValue( index, Catch::Detail::stringify( value ) );
        -: 3899:        }
        -: 3900:
        -: 3901:        template<typename T, typename... Ts>
        -: 3902:        void captureValues( size_t index, T const& value, Ts const&... values ) {
        -: 3903:            captureValue( index, Catch::Detail::stringify(value) );
        -: 3904:            captureValues( index+1, values... );
        -: 3905:        }
        -: 3906:    };
        -: 3907:
        -: 3908:} // end namespace Catch
        -: 3909:
        -: 3910:///////////////////////////////////////////////////////////////////////////////
        -: 3911:#define INTERNAL_CATCH_MSG( macroName, messageType, resultDisposition, ... ) \
        -: 3912:    do { \
        -: 3913:        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::StringRef(), resultDisposition ); \
        -: 3914:        catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() << __VA_ARGS__ + ::Catch::StreamEndStop() ).m_stream.str() ); \
        -: 3915:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 3916:    } while( false )
        -: 3917:
        -: 3918:///////////////////////////////////////////////////////////////////////////////
        -: 3919:#define INTERNAL_CATCH_CAPTURE( varName, macroName, ... ) \
        -: 3920:    Catch::Capturer varName( macroName, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info, #__VA_ARGS__ ); \
        -: 3921:    varName.captureValues( 0, __VA_ARGS__ )
        -: 3922:
        -: 3923:///////////////////////////////////////////////////////////////////////////////
        -: 3924:#define INTERNAL_CATCH_INFO( macroName, log ) \
        -: 3925:    Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage )( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log )
        -: 3926:
        -: 3927:///////////////////////////////////////////////////////////////////////////////
        -: 3928:#define INTERNAL_CATCH_UNSCOPED_INFO( macroName, log ) \
        -: 3929:    Catch::getResultCapture().emplaceUnscopedMessage( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log )
        -: 3930:
        -: 3931:
        -: 3932:#if defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)
        -: 3933:
        -: 3934:  #define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( "CATCH_INFO", msg )
        -: 3935:  #define CATCH_UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( "CATCH_UNSCOPED_INFO", msg )
        -: 3936:  #define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( "CATCH_WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
        -: 3937:  #define CATCH_CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), "CATCH_CAPTURE", __VA_ARGS__ )
        -: 3938:
        -: 3939:#elif defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)
        -: 3940:
        -: 3941:  #define CATCH_INFO( msg )          (void)(0)
        -: 3942:  #define CATCH_UNSCOPED_INFO( msg ) (void)(0)
        -: 3943:  #define CATCH_WARN( msg )          (void)(0)
        -: 3944:  #define CATCH_CAPTURE( ... )       (void)(0)
        -: 3945:
        -: 3946:#elif !defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)
        -: 3947:
        -: 3948:  #define INFO( msg ) INTERNAL_CATCH_INFO( "INFO", msg )
        -: 3949:  #define UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( "UNSCOPED_INFO", msg )
        -: 3950:  #define WARN( msg ) INTERNAL_CATCH_MSG( "WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
        -: 3951:  #define CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), "CAPTURE", __VA_ARGS__ )
        -: 3952:
        -: 3953:#elif !defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)
        -: 3954:
        -: 3955:  #define INFO( msg )          (void)(0)
        -: 3956:  #define UNSCOPED_INFO( msg ) (void)(0)
        -: 3957:  #define WARN( msg )          (void)(0)
        -: 3958:  #define CAPTURE( ... )       (void)(0)
        -: 3959:
        -: 3960:#endif // end of user facing macro declarations
        -: 3961:
        -: 3962:
        -: 3963:
        -: 3964:
        -: 3965:#endif // CATCH_MESSAGE_HPP_INCLUDED
        -: 3966:
        -: 3967:
        -: 3968:#ifndef CATCH_REPORTER_REGISTRARS_HPP_INCLUDED
        -: 3969:#define CATCH_REPORTER_REGISTRARS_HPP_INCLUDED
        -: 3970:
        -: 3971:
        -: 3972:
        -: 3973:#ifndef CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED
        -: 3974:#define CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED
        -: 3975:
        -: 3976:namespace Catch {
        -: 3977:
        -: 3978:    struct ReporterConfig;
        -: 3979:
       16: 3980:    struct IReporterFactory {
        -: 3981:        virtual ~IReporterFactory(); // = default
        -: 3982:
        -: 3983:        virtual IStreamingReporterPtr
        -: 3984:        create( ReporterConfig const& config ) const = 0;
        -: 3985:        virtual std::string getDescription() const = 0;
        -: 3986:    };
        -: 3987:    using IReporterFactoryPtr = Detail::unique_ptr<IReporterFactory>;
        -: 3988:} // namespace Catch
        -: 3989:
        -: 3990:#endif // CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED
        -: 3991:
        -: 3992:namespace Catch {
        -: 3993:
        -: 3994:    template <typename T>
       24: 3995:    class ReporterFactory : public IReporterFactory {
        -: 3996:
        1: 3997:        IStreamingReporterPtr create( ReporterConfig const& config ) const override {
        2: 3998:            return Detail::make_unique<T>( config );
        -: 3999:        }
        -: 4000:
    #####: 4001:        std::string getDescription() const override {
    #####: 4002:            return T::getDescription();
        -: 4003:        }
        -: 4004:    };
        -: 4005:
        -: 4006:
        -: 4007:    template<typename T>
        -: 4008:    class ReporterRegistrar {
        -: 4009:    public:
        -: 4010:        explicit ReporterRegistrar( std::string const& name ) {
        -: 4011:            getMutableRegistryHub().registerReporter( name, Detail::make_unique<ReporterFactory<T>>() );
        -: 4012:        }
        -: 4013:    };
        -: 4014:
        -: 4015:    template<typename T>
        -: 4016:    class ListenerRegistrar {
        -: 4017:
        -: 4018:        class ListenerFactory : public IReporterFactory {
        -: 4019:
        -: 4020:            IStreamingReporterPtr create( ReporterConfig const& config ) const override {
        -: 4021:                return Detail::make_unique<T>(config);
        -: 4022:            }
        -: 4023:            std::string getDescription() const override {
        -: 4024:                return std::string();
        -: 4025:            }
        -: 4026:        };
        -: 4027:
        -: 4028:    public:
        -: 4029:
        -: 4030:        ListenerRegistrar() {
        -: 4031:            getMutableRegistryHub().registerListener( Detail::make_unique<ListenerFactory>() );
        -: 4032:        }
        -: 4033:    };
        -: 4034:}
        -: 4035:
        -: 4036:#if !defined(CATCH_CONFIG_DISABLE)
        -: 4037:
        -: 4038:#define CATCH_REGISTER_REPORTER( name, reporterType ) \
        -: 4039:    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION         \
        -: 4040:    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS          \
        -: 4041:    namespace{ Catch::ReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); } \
        -: 4042:    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -: 4043:
        -: 4044:#define CATCH_REGISTER_LISTENER( listenerType ) \
        -: 4045:    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION   \
        -: 4046:    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS    \
        -: 4047:    namespace{ Catch::ListenerRegistrar<listenerType> catch_internal_RegistrarFor##listenerType; } \
        -: 4048:    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -: 4049:#else // CATCH_CONFIG_DISABLE
        -: 4050:
        -: 4051:#define CATCH_REGISTER_REPORTER(name, reporterType)
        -: 4052:#define CATCH_REGISTER_LISTENER(listenerType)
        -: 4053:
        -: 4054:#endif // CATCH_CONFIG_DISABLE
        -: 4055:
        -: 4056:#endif // CATCH_REPORTER_REGISTRARS_HPP_INCLUDED
        -: 4057:
        -: 4058:
        -: 4059:#ifndef CATCH_SESSION_HPP_INCLUDED
        -: 4060:#define CATCH_SESSION_HPP_INCLUDED
        -: 4061:
        -: 4062:
        -: 4063:
        -: 4064:#ifndef CATCH_COMMANDLINE_HPP_INCLUDED
        -: 4065:#define CATCH_COMMANDLINE_HPP_INCLUDED
        -: 4066:
        -: 4067:
        -: 4068:
        -: 4069:#ifndef CATCH_CLARA_HPP_INCLUDED
        -: 4070:#define CATCH_CLARA_HPP_INCLUDED
        -: 4071:
        -: 4072:#if defined( __clang__ )
        -: 4073:#    pragma clang diagnostic push
        -: 4074:#    pragma clang diagnostic ignored "-Wweak-vtables"
        -: 4075:#    pragma clang diagnostic ignored "-Wshadow"
        -: 4076:#    pragma clang diagnostic ignored "-Wdeprecated"
        -: 4077:#endif
        -: 4078:
        -: 4079:#if defined( __GNUC__ )
        -: 4080:#    pragma GCC diagnostic push
        -: 4081:#    pragma GCC diagnostic ignored "-Wsign-conversion"
        -: 4082:#endif
        -: 4083:
        -: 4084:#ifndef CLARA_CONFIG_OPTIONAL_TYPE
        -: 4085:#    ifdef __has_include
        -: 4086:#        if __has_include( <optional>) && __cplusplus >= 201703L
        -: 4087:#            include <optional>
        -: 4088:#            define CLARA_CONFIG_OPTIONAL_TYPE std::optional
        -: 4089:#        endif
        -: 4090:#    endif
        -: 4091:#endif
        -: 4092:
        -: 4093:
        -: 4094:#include <cassert>
        -: 4095:#include <cctype>
        -: 4096:#include <memory>
        -: 4097:#include <ostream>
        -: 4098:#include <sstream>
        -: 4099:#include <string>
        -: 4100:#include <vector>
        -: 4101:
        -: 4102:namespace Catch {
        -: 4103:    namespace Clara {
        -: 4104:
        -: 4105:        class Args;
        -: 4106:        class Parser;
        -: 4107:
        -: 4108:        // enum of result types from a parse
        -: 4109:        enum class ParseResultType {
        -: 4110:            Matched,
        -: 4111:            NoMatch,
        -: 4112:            ShortCircuitAll,
        -: 4113:            ShortCircuitSame
        -: 4114:        };
        -: 4115:
        -: 4116:        namespace Detail {
        -: 4117:
        -: 4118:            // Traits for extracting arg and return type of lambdas (for single
        -: 4119:            // argument lambdas)
        -: 4120:            template <typename L>
        -: 4121:            struct UnaryLambdaTraits
        -: 4122:                : UnaryLambdaTraits<decltype( &L::operator() )> {};
        -: 4123:
        -: 4124:            template <typename ClassT, typename ReturnT, typename... Args>
        -: 4125:            struct UnaryLambdaTraits<ReturnT ( ClassT::* )( Args... ) const> {
        -: 4126:                static const bool isValid = false;
        -: 4127:            };
        -: 4128:
        -: 4129:            template <typename ClassT, typename ReturnT, typename ArgT>
        -: 4130:            struct UnaryLambdaTraits<ReturnT ( ClassT::* )( ArgT ) const> {
        -: 4131:                static const bool isValid = true;
        -: 4132:                using ArgType = typename std::remove_const<
        -: 4133:                    typename std::remove_reference<ArgT>::type>::type;
        -: 4134:                using ReturnType = ReturnT;
        -: 4135:            };
        -: 4136:
        -: 4137:            class TokenStream;
        -: 4138:
        -: 4139:            // Wraps a token coming from a token stream. These may not directly
        -: 4140:            // correspond to strings as a single string may encode an option +
        -: 4141:            // its argument if the : or = form is used
        -: 4142:            enum class TokenType { Option, Argument };
    #####: 4143:            struct Token {
        -: 4144:                TokenType type;
        -: 4145:                std::string token;
        -: 4146:            };
        -: 4147:
        -: 4148:            // Abstracts iterators into args as a stream of tokens, with option
        -: 4149:            // arguments uniformly handled
        7: 4150:            class TokenStream {
        -: 4151:                using Iterator = std::vector<std::string>::const_iterator;
        -: 4152:                Iterator it;
        -: 4153:                Iterator itEnd;
        -: 4154:                std::vector<Token> m_tokenBuffer;
        -: 4155:
        -: 4156:                void loadBuffer();
        -: 4157:
        -: 4158:            public:
        -: 4159:                explicit TokenStream( Args const& args );
        -: 4160:                TokenStream( Iterator it, Iterator itEnd );
        -: 4161:
        -: 4162:                explicit operator bool() const {
        2: 4163:                    return !m_tokenBuffer.empty() || it != itEnd;
        -: 4164:                }
        -: 4165:
        -: 4166:                size_t count() const {
        -: 4167:                    return m_tokenBuffer.size() + ( itEnd - it );
        -: 4168:                }
        -: 4169:
    #####: 4170:                Token operator*() const {
    #####: 4171:                    assert( !m_tokenBuffer.empty() );
    #####: 4172:                    return m_tokenBuffer.front();
        -: 4173:                }
        -: 4174:
        -: 4175:                Token const* operator->() const {
    #####: 4176:                    assert( !m_tokenBuffer.empty() );
        -: 4177:                    return &m_tokenBuffer.front();
        -: 4178:                }
        -: 4179:
        -: 4180:                TokenStream& operator++();
        -: 4181:            };
        -: 4182:
        -: 4183:            //! Denotes type of a parsing result
        -: 4184:            enum class ResultType {
        -: 4185:                Ok,          ///< No errors
        -: 4186:                LogicError,  ///< Error in user-specified arguments for
        -: 4187:                             ///< construction
        -: 4188:                RuntimeError ///< Error in parsing inputs
        -: 4189:            };
        -: 4190:
        3: 4191:            class ResultBase {
        -: 4192:            protected:
        2: 4193:                ResultBase( ResultType type ): m_type( type ) {}
        -: 4194:                virtual ~ResultBase(); // = default;
        -: 4195:
        -: 4196:
        1: 4197:                ResultBase(ResultBase const&) = default;
        -: 4198:                ResultBase& operator=(ResultBase const&) = default;
    #####: 4199:                ResultBase(ResultBase&&) = default;
        -: 4200:                ResultBase& operator=(ResultBase&&) = default;
        -: 4201:
        -: 4202:                virtual void enforceOk() const = 0;
        -: 4203:
        -: 4204:                ResultType m_type;
        -: 4205:            };
        -: 4206:
        -: 4207:            template <typename T> class ResultValueBase : public ResultBase {
        -: 4208:            public:
        -: 4209:                auto value() const -> T const& {
        1: 4210:                    enforceOk();
        -: 4211:                    return m_value;
        -: 4212:                }
        -: 4213:
        -: 4214:            protected:
    #####: 4215:                ResultValueBase( ResultType type ): ResultBase( type ) {}
        -: 4216:
        1: 4217:                ResultValueBase( ResultValueBase const& other ):
        1: 4218:                    ResultBase( other ) {
        1: 4219:                    if ( m_type == ResultType::Ok )
        1: 4220:                        new ( &m_value ) T( other.m_value );
        1: 4221:                }
        -: 4222:
        3: 4223:                ResultValueBase( ResultType, T const& value ): ResultBase( ResultType::Ok ) {
        2: 4224:                    new ( &m_value ) T( value );
        1: 4225:                }
        -: 4226:
    #####: 4227:                auto operator=( ResultValueBase const& other )
        -: 4228:                    -> ResultValueBase& {
    #####: 4229:                    if ( m_type == ResultType::Ok )
        -: 4230:                        m_value.~T();
        -: 4231:                    ResultBase::operator=( other );
    #####: 4232:                    if ( m_type == ResultType::Ok )
    #####: 4233:                        new ( &m_value ) T( other.m_value );
    #####: 4234:                    return *this;
        -: 4235:                }
        -: 4236:
        -: 4237:                ~ResultValueBase() override {
        2: 4238:                    if ( m_type == ResultType::Ok )
        -: 4239:                        m_value.~T();
        6: 4240:                }
        -: 4241:
        -: 4242:                union {
        -: 4243:                    T m_value;
        -: 4244:                };
        -: 4245:            };
        -: 4246:
    #####: 4247:            template <> class ResultValueBase<void> : public ResultBase {
        -: 4248:            protected:
    #####: 4249:                using ResultBase::ResultBase;
        -: 4250:            };
        -: 4251:
        -: 4252:            template <typename T = void>
        8: 4253:            class BasicResult : public ResultValueBase<T> {
        -: 4254:            public:
        -: 4255:                template <typename U>
    #####: 4256:                explicit BasicResult( BasicResult<U> const& other ):
        -: 4257:                    ResultValueBase<T>( other.type() ),
    #####: 4258:                    m_errorMessage( other.errorMessage() ) {
    #####: 4259:                    assert( type() != ResultType::Ok );
    #####: 4260:                }
        -: 4261:
        -: 4262:                template <typename U>
        -: 4263:                static auto ok( U const& value ) -> BasicResult {
        -: 4264:                    return { ResultType::Ok, value };
        -: 4265:                }
        -: 4266:                static auto ok() -> BasicResult { return { ResultType::Ok }; }
        -: 4267:                static auto logicError( std::string const& message )
        -: 4268:                    -> BasicResult {
    #####: 4269:                    return { ResultType::LogicError, message };
        -: 4270:                }
        -: 4271:                static auto runtimeError( std::string const& message )
        -: 4272:                    -> BasicResult {
    #####: 4273:                    return { ResultType::RuntimeError, message };
        -: 4274:                }
        -: 4275:
        -: 4276:                explicit operator bool() const {
        -: 4277:                    return m_type == ResultType::Ok;
        -: 4278:                }
        -: 4279:                auto type() const -> ResultType { return m_type; }
        -: 4280:                auto errorMessage() const -> std::string {
        -: 4281:                    return m_errorMessage;
        -: 4282:                }
        -: 4283:
        -: 4284:            protected:
        1: 4285:                void enforceOk() const override {
        -: 4286:
        -: 4287:                    // Errors shouldn't reach this point, but if they do
        -: 4288:                    // the actual error message will be in m_errorMessage
        1: 4289:                    assert( m_type != ResultType::LogicError );
        1: 4290:                    assert( m_type != ResultType::RuntimeError );
        1: 4291:                    if ( m_type != ResultType::Ok )
    #####: 4292:                        std::abort();
        1: 4293:                }
        -: 4294:
        -: 4295:                std::string
        -: 4296:                    m_errorMessage; // Only populated if resultType is an error
        -: 4297:
    #####: 4298:                BasicResult( ResultType type,
        -: 4299:                             std::string const& message ):
    #####: 4300:                    ResultValueBase<T>( type ), m_errorMessage( message ) {
    #####: 4301:                    assert( m_type != ResultType::Ok );
    #####: 4302:                }
        -: 4303:
        2: 4304:                using ResultValueBase<T>::ResultValueBase;
        -: 4305:                using ResultBase::m_type;
        -: 4306:            };
        -: 4307:
        5: 4308:            class ParseState {
        -: 4309:            public:
        -: 4310:                ParseState( ParseResultType type,
        -: 4311:                            TokenStream const& remainingTokens );
        -: 4312:
        -: 4313:                ParseResultType type() const { return m_type; }
        -: 4314:                TokenStream const& remainingTokens() const {
        -: 4315:                    return m_remainingTokens;
        -: 4316:                }
        -: 4317:
        -: 4318:            private:
        -: 4319:                ParseResultType m_type;
        -: 4320:                TokenStream m_remainingTokens;
        -: 4321:            };
        -: 4322:
        -: 4323:            using Result = BasicResult<void>;
        -: 4324:            using ParserResult = BasicResult<ParseResultType>;
        -: 4325:            using InternalParseResult = BasicResult<ParseState>;
        -: 4326:
    #####: 4327:            struct HelpColumns {
        -: 4328:                std::string left;
        -: 4329:                std::string right;
        -: 4330:            };
        -: 4331:
        -: 4332:            template <typename T>
    #####: 4333:            ParserResult convertInto( std::string const& source, T& target ) {
    #####: 4334:                std::stringstream ss( source );
    #####: 4335:                ss >> target;
    #####: 4336:                if ( ss.fail() ) {
        -: 4337:                    return ParserResult::runtimeError(
        -: 4338:                        "Unable to convert '" + source +
    #####: 4339:                        "' to destination type" );
        -: 4340:                } else {
        -: 4341:                    return ParserResult::ok( ParseResultType::Matched );
        -: 4342:                }
        -: 4343:            }
        -: 4344:            ParserResult convertInto( std::string const& source,
        -: 4345:                                      std::string& target );
        -: 4346:            ParserResult convertInto( std::string const& source, bool& target );
        -: 4347:
        -: 4348:#ifdef CLARA_CONFIG_OPTIONAL_TYPE
        -: 4349:            template <typename T>
        -: 4350:            auto convertInto( std::string const& source,
        -: 4351:                              CLARA_CONFIG_OPTIONAL_TYPE<T>& target )
        -: 4352:                -> ParserResult {
        -: 4353:                T temp;
        -: 4354:                auto result = convertInto( source, temp );
        -: 4355:                if ( result )
        -: 4356:                    target = std::move( temp );
        -: 4357:                return result;
        -: 4358:            }
        -: 4359:#endif // CLARA_CONFIG_OPTIONAL_TYPE
        -: 4360:
       32: 4361:            struct BoundRef : Catch::Detail::NonCopyable {
       32: 4362:                virtual ~BoundRef() = default;
        -: 4363:                virtual bool isContainer() const;
        -: 4364:                virtual bool isFlag() const;
        -: 4365:            };
       60: 4366:            struct BoundValueRefBase : BoundRef {
        -: 4367:                virtual auto setValue( std::string const& arg )
        -: 4368:                    -> ParserResult = 0;
        -: 4369:            };
       36: 4370:            struct BoundFlagRefBase : BoundRef {
        -: 4371:                virtual auto setFlag( bool flag ) -> ParserResult = 0;
        -: 4372:                bool isFlag() const override;
        -: 4373:            };
        -: 4374:
       16: 4375:            template <typename T> struct BoundValueRef : BoundValueRefBase {
        -: 4376:                T& m_ref;
        -: 4377:
        8: 4378:                explicit BoundValueRef( T& ref ): m_ref( ref ) {}
        -: 4379:
        1: 4380:                ParserResult setValue( std::string const& arg ) override {
        2: 4381:                    return convertInto( arg, m_ref );
        -: 4382:                }
        -: 4383:            };
        -: 4384:
        -: 4385:            template <typename T>
        4: 4386:            struct BoundValueRef<std::vector<T>> : BoundValueRefBase {
        -: 4387:                std::vector<T>& m_ref;
        -: 4388:
        2: 4389:                explicit BoundValueRef( std::vector<T>& ref ): m_ref( ref ) {}
        -: 4390:
    #####: 4391:                auto isContainer() const -> bool override { return true; }
        -: 4392:
    #####: 4393:                auto setValue( std::string const& arg )
        -: 4394:                    -> ParserResult override {
        -: 4395:                    T temp;
        -: 4396:                    auto result = convertInto( arg, temp );
        -: 4397:                    if ( result )
    #####: 4398:                        m_ref.push_back( temp );
    #####: 4399:                    return result;
        -: 4400:                }
        -: 4401:            };
        -: 4402:
       20: 4403:            struct BoundFlagRef : BoundFlagRefBase {
        -: 4404:                bool& m_ref;
        -: 4405:
       10: 4406:                explicit BoundFlagRef( bool& ref ): m_ref( ref ) {}
        -: 4407:
        -: 4408:                ParserResult setFlag( bool flag ) override;
        -: 4409:            };
        -: 4410:
        -: 4411:            template <typename ReturnType> struct LambdaInvoker {
        -: 4412:                static_assert(
        -: 4413:                    std::is_same<ReturnType, ParserResult>::value,
        -: 4414:                    "Lambda must return void or clara::ParserResult" );
        -: 4415:
        -: 4416:                template <typename L, typename ArgType>
        -: 4417:                static auto invoke( L const& lambda, ArgType const& arg )
        -: 4418:                    -> ParserResult {
    #####: 4419:                    return lambda( arg );
        -: 4420:                }
        -: 4421:            };
        -: 4422:
        -: 4423:            template <> struct LambdaInvoker<void> {
        -: 4424:                template <typename L, typename ArgType>
        -: 4425:                static auto invoke( L const& lambda, ArgType const& arg )
        -: 4426:                    -> ParserResult {
        -: 4427:                    lambda( arg );
        -: 4428:                    return ParserResult::ok( ParseResultType::Matched );
        -: 4429:                }
        -: 4430:            };
        -: 4431:
        -: 4432:            template <typename ArgType, typename L>
    #####: 4433:            auto invokeLambda( L const& lambda, std::string const& arg )
        -: 4434:                -> ParserResult {
    #####: 4435:                ArgType temp{};
    #####: 4436:                auto result = convertInto( arg, temp );
        -: 4437:                return !result ? result
        -: 4438:                               : LambdaInvoker<typename UnaryLambdaTraits<
    #####: 4439:                                     L>::ReturnType>::invoke( lambda, temp );
        -: 4440:            }
        -: 4441:
       20: 4442:            template <typename L> struct BoundLambda : BoundValueRefBase {
        -: 4443:                L m_lambda;
        -: 4444:
        -: 4445:                static_assert(
        -: 4446:                    UnaryLambdaTraits<L>::isValid,
        -: 4447:                    "Supplied lambda must take exactly one argument" );
       10: 4448:                explicit BoundLambda( L const& lambda ): m_lambda( lambda ) {}
        -: 4449:
    #####: 4450:                auto setValue( std::string const& arg )
        -: 4451:                    -> ParserResult override {
        -: 4452:                    return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>(
    #####: 4453:                        m_lambda, arg );
        -: 4454:                }
        -: 4455:            };
        -: 4456:
        4: 4457:            template <typename L> struct BoundFlagLambda : BoundFlagRefBase {
        -: 4458:                L m_lambda;
        -: 4459:
        -: 4460:                static_assert(
        -: 4461:                    UnaryLambdaTraits<L>::isValid,
        -: 4462:                    "Supplied lambda must take exactly one argument" );
        -: 4463:                static_assert(
        -: 4464:                    std::is_same<typename UnaryLambdaTraits<L>::ArgType,
        -: 4465:                                 bool>::value,
        -: 4466:                    "flags must be boolean" );
        -: 4467:
        -: 4468:                explicit BoundFlagLambda( L const& lambda ):
        2: 4469:                    m_lambda( lambda ) {}
        -: 4470:
    #####: 4471:                auto setFlag( bool flag ) -> ParserResult override {
        -: 4472:                    return LambdaInvoker<typename UnaryLambdaTraits<
    #####: 4473:                        L>::ReturnType>::invoke( m_lambda, flag );
        -: 4474:                }
        -: 4475:            };
        -: 4476:
        -: 4477:            enum class Optionality { Optional, Required };
        -: 4478:
     1591: 4479:            class ParserBase {
        -: 4480:            public:
     1591: 4481:                virtual ~ParserBase() = default;
    #####: 4482:                virtual auto validate() const -> Result { return Result::ok(); }
        -: 4483:                virtual auto parse( std::string const& exeName,
        -: 4484:                                    TokenStream const& tokens ) const
        -: 4485:                    -> InternalParseResult = 0;
        -: 4486:                virtual size_t cardinality() const;
        -: 4487:
        -: 4488:                InternalParseResult parse( Args const& args ) const;
        -: 4489:            };
        -: 4490:
        -: 4491:            template <typename DerivedT>
     4575: 4492:            class ComposableParserImpl : public ParserBase {
        -: 4493:            public:
        -: 4494:                template <typename T>
        -: 4495:                auto operator|( T const& other ) const -> Parser;
        -: 4496:            };
        -: 4497:
        -: 4498:            // Common code and state for Args and Opts
        -: 4499:            template <typename DerivedT>
     9181: 4500:            class ParserRefImpl : public ComposableParserImpl<DerivedT> {
        -: 4501:            protected:
        -: 4502:                Optionality m_optionality = Optionality::Optional;
        -: 4503:                std::shared_ptr<BoundRef> m_ref;
        -: 4504:                std::string m_hint;
        -: 4505:                std::string m_description;
        -: 4506:
        -: 4507:                explicit ParserRefImpl( std::shared_ptr<BoundRef> const& ref ):
       12: 4508:                    m_ref( ref ) {}
        -: 4509:
        -: 4510:            public:
        -: 4511:                template <typename T>
        9: 4512:                ParserRefImpl( T& ref, std::string const& hint ):
        -: 4513:                    m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),
       27: 4514:                    m_hint( hint ) {}
        -: 4515:
        -: 4516:                template <typename LambdaT>
       10: 4517:                ParserRefImpl( LambdaT const& ref, std::string const& hint ):
        -: 4518:                    m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),
       30: 4519:                    m_hint( hint ) {}
        -: 4520:
        -: 4521:                auto operator()( std::string const& description ) -> DerivedT& {
        1: 4522:                    m_description = description;
        -: 4523:                    return static_cast<DerivedT&>( *this );
        -: 4524:                }
        -: 4525:
        -: 4526:                auto optional() -> DerivedT& {
        1: 4527:                    m_optionality = Optionality::Optional;
        -: 4528:                    return static_cast<DerivedT&>( *this );
        -: 4529:                }
        -: 4530:
        -: 4531:                auto required() -> DerivedT& {
        -: 4532:                    m_optionality = Optionality::Required;
        -: 4533:                    return static_cast<DerivedT&>( *this );
        -: 4534:                }
        -: 4535:
        -: 4536:                auto isOptional() const -> bool {
        -: 4537:                    return m_optionality == Optionality::Optional;
        -: 4538:                }
        -: 4539:
    #####: 4540:                auto cardinality() const -> size_t override {
    #####: 4541:                    if ( m_ref->isContainer() )
        -: 4542:                        return 0;
        -: 4543:                    else
    #####: 4544:                        return 1;
        -: 4545:                }
        -: 4546:
        -: 4547:                std::string const& hint() const { return m_hint; }
        -: 4548:            };
        -: 4549:
        -: 4550:        } // namespace detail
        -: 4551:
        -: 4552:
        -: 4553:        // A parser for arguments
        5: 4554:        class Arg : public Detail::ParserRefImpl<Arg> {
        -: 4555:        public:
        1: 4556:            using ParserRefImpl::ParserRefImpl;
        -: 4557:
        -: 4558:            Detail::InternalParseResult
        -: 4559:                parse(std::string const&,
        -: 4560:                      Detail::TokenStream const& tokens) const override;
        -: 4561:        };
        -: 4562:
        -: 4563:        // A parser for options
     3315: 4564:        class Opt : public Detail::ParserRefImpl<Opt> {
        -: 4565:        protected:
        -: 4566:            std::vector<std::string> m_optNames;
        -: 4567:
        -: 4568:        public:
        -: 4569:            template <typename LambdaT>
        2: 4570:            explicit Opt(LambdaT const& ref) :
        -: 4571:                ParserRefImpl(
        6: 4572:                    std::make_shared<Detail::BoundFlagLambda<LambdaT>>(ref)) {}
        -: 4573:
        -: 4574:            explicit Opt(bool& ref);
        -: 4575:
        -: 4576:            template <typename LambdaT>
        -: 4577:            Opt(LambdaT const& ref, std::string const& hint) :
       10: 4578:                ParserRefImpl(ref, hint) {}
        -: 4579:
        -: 4580:            template <typename T>
        -: 4581:            Opt(T& ref, std::string const& hint) :
        8: 4582:                ParserRefImpl(ref, hint) {}
        -: 4583:
        -: 4584:            auto operator[](std::string const& optName) -> Opt& {
       30: 4585:                m_optNames.push_back(optName);
        -: 4586:                return *this;
        -: 4587:            }
        -: 4588:
        -: 4589:            std::vector<Detail::HelpColumns> getHelpColumns() const;
        -: 4590:
        -: 4591:            bool isMatch(std::string const& optToken) const;
        -: 4592:
        -: 4593:            using ParserBase::parse;
        -: 4594:
        -: 4595:            Detail::InternalParseResult
        -: 4596:                parse(std::string const&,
        -: 4597:                      Detail::TokenStream const& tokens) const override;
        -: 4598:
        -: 4599:            Detail::Result validate() const override;
        -: 4600:        };
        -: 4601:
        -: 4602:        // Specifies the name of the executable
      330: 4603:        class ExeName : public Detail::ComposableParserImpl<ExeName> {
        -: 4604:            std::shared_ptr<std::string> m_name;
        -: 4605:            std::shared_ptr<Detail::BoundValueRefBase> m_ref;
        -: 4606:
        -: 4607:            template <typename LambdaT>
        -: 4608:            static auto makeRef(LambdaT const& lambda)
        -: 4609:                -> std::shared_ptr<Detail::BoundValueRefBase> {
        -: 4610:                return std::make_shared<Detail::BoundLambda<LambdaT>>(lambda);
        -: 4611:            }
        -: 4612:
        -: 4613:        public:
        -: 4614:            ExeName();
        -: 4615:            explicit ExeName(std::string& ref);
        -: 4616:
        -: 4617:            template <typename LambdaT>
        -: 4618:            explicit ExeName(LambdaT const& lambda) : ExeName() {
        -: 4619:                m_ref = std::make_shared<Detail::BoundLambda<LambdaT>>(lambda);
        -: 4620:            }
        -: 4621:
        -: 4622:            // The exe name is not parsed out of the normal tokens, but is
        -: 4623:            // handled specially
        -: 4624:            Detail::InternalParseResult
        -: 4625:                parse(std::string const&,
        -: 4626:                      Detail::TokenStream const& tokens) const override;
        -: 4627:
        -: 4628:            std::string const& name() const { return *m_name; }
        -: 4629:            Detail::ParserResult set(std::string const& newName);
        -: 4630:        };
        -: 4631:
        -: 4632:
        -: 4633:        // A Combined parser
      265: 4634:        class Parser : Detail::ParserBase {
        -: 4635:            mutable ExeName m_exeName;
        -: 4636:            std::vector<Opt> m_options;
        -: 4637:            std::vector<Arg> m_args;
        -: 4638:
        -: 4639:        public:
        -: 4640:
        -: 4641:            auto operator|=(ExeName const& exeName) -> Parser& {
        1: 4642:                m_exeName = exeName;
        -: 4643:                return *this;
        -: 4644:            }
        -: 4645:
        -: 4646:            auto operator|=(Arg const& arg) -> Parser& {
        1: 4647:                m_args.push_back(arg);
        -: 4648:                return *this;
        -: 4649:            }
        -: 4650:
        -: 4651:            auto operator|=(Opt const& opt) -> Parser& {
       30: 4652:                m_options.push_back(opt);
        -: 4653:                return *this;
        -: 4654:            }
        -: 4655:
        -: 4656:            Parser& operator|=(Parser const& other);
        -: 4657:
        -: 4658:            template <typename T>
       32: 4659:            auto operator|(T const& other) const -> Parser {
       64: 4660:                return Parser(*this) |= other;
        -: 4661:            }
        -: 4662:
        -: 4663:            std::vector<Detail::HelpColumns> getHelpColumns() const;
        -: 4664:
        -: 4665:            void writeToStream(std::ostream& os) const;
        -: 4666:
        -: 4667:            friend auto operator<<(std::ostream& os, Parser const& parser)
        -: 4668:                -> std::ostream& {
    #####: 4669:                parser.writeToStream(os);
        -: 4670:                return os;
        -: 4671:            }
        -: 4672:
        -: 4673:            Detail::Result validate() const override;
        -: 4674:
        -: 4675:            using ParserBase::parse;
        -: 4676:            Detail::InternalParseResult
        -: 4677:                parse(std::string const& exeName,
        -: 4678:                      Detail::TokenStream const& tokens) const override;
        -: 4679:        };
        -: 4680:
        -: 4681:        // Transport for raw args (copied from main args, or supplied via
        -: 4682:        // init list for testing)
        2: 4683:        class Args {
        -: 4684:            friend Detail::TokenStream;
        -: 4685:            std::string m_exeName;
        -: 4686:            std::vector<std::string> m_args;
        -: 4687:
        -: 4688:        public:
        -: 4689:            Args(int argc, char const* const* argv);
        -: 4690:            Args(std::initializer_list<std::string> args);
        -: 4691:
        1: 4692:            std::string const& exeName() const { return m_exeName; }
        -: 4693:        };
        -: 4694:
        -: 4695:
        -: 4696:        // Convenience wrapper for option parser that specifies the help option
        2: 4697:        struct Help : Opt {
        -: 4698:            Help(bool& showHelpFlag);
        -: 4699:        };
        -: 4700:
        -: 4701:        // Result type for parser operation
        -: 4702:        using Detail::ParserResult;
        -: 4703:
        -: 4704:        namespace Detail {
        -: 4705:            template <typename DerivedT>
        -: 4706:            template <typename T>
        -: 4707:            Parser
        1: 4708:                ComposableParserImpl<DerivedT>::operator|(T const& other) const {
        2: 4709:                return Parser() | static_cast<DerivedT const&>(*this) | other;
        -: 4710:            }
        -: 4711:        }
        -: 4712:
        -: 4713:    } // namespace Clara
        -: 4714:} // namespace Catch
        -: 4715:
        -: 4716:#if defined( __clang__ )
        -: 4717:#    pragma clang diagnostic pop
        -: 4718:#endif
        -: 4719:
        -: 4720:#if defined( __GNUC__ )
        -: 4721:#    pragma GCC diagnostic pop
        -: 4722:#endif
        -: 4723:
        -: 4724:#endif // CATCH_CLARA_HPP_INCLUDED
        -: 4725:
        -: 4726:namespace Catch {
        -: 4727:
        -: 4728:    struct ConfigData;
        -: 4729:
        -: 4730:    Clara::Parser makeCommandLineParser( ConfigData& config );
        -: 4731:
        -: 4732:} // end namespace Catch
        -: 4733:
        -: 4734:#endif // CATCH_COMMANDLINE_HPP_INCLUDED
        -: 4735:
        -: 4736:namespace Catch {
        -: 4737:
        -: 4738:    class Session : Detail::NonCopyable {
        -: 4739:    public:
        -: 4740:
        -: 4741:        Session();
        -: 4742:        ~Session();
        -: 4743:
        -: 4744:        void showHelp() const;
        -: 4745:        void libIdentify();
        -: 4746:
        -: 4747:        int applyCommandLine( int argc, char const * const * argv );
        -: 4748:    #if defined(CATCH_CONFIG_WCHAR) && defined(_WIN32) && defined(UNICODE)
        -: 4749:        int applyCommandLine( int argc, wchar_t const * const * argv );
        -: 4750:    #endif
        -: 4751:
        -: 4752:        void useConfigData( ConfigData const& configData );
        -: 4753:
        -: 4754:        template<typename CharT>
        1: 4755:        int run(int argc, CharT const * const argv[]) {
        1: 4756:            if (m_startupExceptions)
        -: 4757:                return 1;
        1: 4758:            int returnCode = applyCommandLine(argc, argv);
        1: 4759:            if (returnCode == 0)
        1: 4760:                returnCode = run();
        -: 4761:            return returnCode;
        -: 4762:        }
        -: 4763:
        -: 4764:        int run();
        -: 4765:
        -: 4766:        Clara::Parser const& cli() const;
        -: 4767:        void cli( Clara::Parser const& newParser );
        -: 4768:        ConfigData& configData();
        -: 4769:        Config& config();
        -: 4770:    private:
        -: 4771:        int runInternal();
        -: 4772:
        -: 4773:        Clara::Parser m_cli;
        -: 4774:        ConfigData m_configData;
        -: 4775:        Detail::unique_ptr<Config> m_config;
        -: 4776:        bool m_startupExceptions = false;
        -: 4777:    };
        -: 4778:
        -: 4779:} // end namespace Catch
        -: 4780:
        -: 4781:#endif // CATCH_SESSION_HPP_INCLUDED
        -: 4782:
        -: 4783:
        -: 4784:#ifndef CATCH_TAG_ALIAS_HPP_INCLUDED
        -: 4785:#define CATCH_TAG_ALIAS_HPP_INCLUDED
        -: 4786:
        -: 4787:
        -: 4788:#include <string>
        -: 4789:
        -: 4790:namespace Catch {
        -: 4791:
    #####: 4792:    struct TagAlias {
        -: 4793:        TagAlias(std::string const& _tag, SourceLineInfo _lineInfo):
        -: 4794:            tag(_tag),
    #####: 4795:            lineInfo(_lineInfo)
        -: 4796:        {}
        -: 4797:
        -: 4798:        std::string tag;
        -: 4799:        SourceLineInfo lineInfo;
        -: 4800:    };
        -: 4801:
        -: 4802:} // end namespace Catch
        -: 4803:
        -: 4804:#endif // CATCH_TAG_ALIAS_HPP_INCLUDED
        -: 4805:
        -: 4806:
        -: 4807:#ifndef CATCH_TAG_ALIAS_AUTOREGISTRAR_HPP_INCLUDED
        -: 4808:#define CATCH_TAG_ALIAS_AUTOREGISTRAR_HPP_INCLUDED
        -: 4809:
        -: 4810:
        -: 4811:namespace Catch {
        -: 4812:
        -: 4813:    struct RegistrarForTagAliases {
        -: 4814:        RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo );
        -: 4815:    };
        -: 4816:
        -: 4817:} // end namespace Catch
        -: 4818:
        -: 4819:#define CATCH_REGISTER_TAG_ALIAS( alias, spec ) \
        -: 4820:    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 4821:    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 4822:    namespace{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); } \
        -: 4823:    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -: 4824:
        -: 4825:#endif // CATCH_TAG_ALIAS_AUTOREGISTRAR_HPP_INCLUDED
        -: 4826:
        -: 4827:
        -: 4828:#ifndef CATCH_TEMPLATE_TEST_MACROS_HPP_INCLUDED
        -: 4829:#define CATCH_TEMPLATE_TEST_MACROS_HPP_INCLUDED
        -: 4830:
        -: 4831:// We need this suppression to leak, because it took until GCC 10
        -: 4832:// for the front end to handle local suppression via _Pragma properly
        -: 4833:// inside templates (so `TEMPLATE_TEST_CASE` and co).
        -: 4834:// **THIS IS DIFFERENT FOR STANDARD TESTS, WHERE GCC 9 IS SUFFICIENT**
        -: 4835:#if defined(__GNUC__) && !defined(__clang__) && !defined(__ICC) && __GNUC__ < 10
        -: 4836:#pragma GCC diagnostic ignored "-Wparentheses"
        -: 4837:#endif
        -: 4838:
        -: 4839:
        -: 4840:
        -: 4841:
        -: 4842:#ifndef CATCH_TEST_MACROS_HPP_INCLUDED
        -: 4843:#define CATCH_TEST_MACROS_HPP_INCLUDED
        -: 4844:
        -: 4845:
        -: 4846:
        -: 4847:#ifndef CATCH_TEST_MACRO_IMPL_HPP_INCLUDED
        -: 4848:#define CATCH_TEST_MACRO_IMPL_HPP_INCLUDED
        -: 4849:
        -: 4850:
        -: 4851:
        -: 4852:#ifndef CATCH_ASSERTION_HANDLER_HPP_INCLUDED
        -: 4853:#define CATCH_ASSERTION_HANDLER_HPP_INCLUDED
        -: 4854:
        -: 4855:
        -: 4856:
        -: 4857:#ifndef CATCH_DECOMPOSER_HPP_INCLUDED
        -: 4858:#define CATCH_DECOMPOSER_HPP_INCLUDED
        -: 4859:
        -: 4860:
        -: 4861:#include <iosfwd>
        -: 4862:
        -: 4863:#ifdef _MSC_VER
        -: 4864:#pragma warning(push)
        -: 4865:#pragma warning(disable:4389) // '==' : signed/unsigned mismatch
        -: 4866:#pragma warning(disable:4018) // more "signed/unsigned mismatch"
        -: 4867:#pragma warning(disable:4312) // Converting int to T* using reinterpret_cast (issue on x64 platform)
        -: 4868:#pragma warning(disable:4180) // qualifier applied to function type has no meaning
        -: 4869:#pragma warning(disable:4800) // Forcing result to true or false
        -: 4870:#endif
        -: 4871:
        -: 4872:#ifdef __clang__
        -: 4873:#  pragma clang diagnostic push
        -: 4874:#  pragma clang diagnostic ignored "-Wsign-compare"
        -: 4875:#elif defined __GNUC__
        -: 4876:#  pragma GCC diagnostic push
        -: 4877:#  pragma GCC diagnostic ignored "-Wsign-compare"
        -: 4878:#endif
        -: 4879:
        -: 4880:namespace Catch {
        -: 4881:
        4: 4882:    struct ITransientExpression {
        -: 4883:        auto isBinaryExpression() const -> bool { return m_isBinaryExpression; }
        -: 4884:        auto getResult() const -> bool { return m_result; }
        -: 4885:        virtual void streamReconstructedExpression( std::ostream &os ) const = 0;
        -: 4886:
        -: 4887:        ITransientExpression( bool isBinaryExpression, bool result )
        -: 4888:        :   m_isBinaryExpression( isBinaryExpression ),
        4: 4889:            m_result( result )
        -: 4890:        {}
        -: 4891:
        -: 4892:        ITransientExpression() = default;
        -: 4893:        ITransientExpression(ITransientExpression const&) = default;
        -: 4894:        ITransientExpression& operator=(ITransientExpression const&) = default;
        -: 4895:
        -: 4896:        // We don't actually need a virtual destructor, but many static analysers
        -: 4897:        // complain if it's not here :-(
        -: 4898:        virtual ~ITransientExpression(); // = default;
        -: 4899:
        -: 4900:        bool m_isBinaryExpression;
        -: 4901:        bool m_result;
        -: 4902:        friend std::ostream& operator<<(std::ostream& out, ITransientExpression const& expr) {
    #####: 4903:            expr.streamReconstructedExpression(out);
        -: 4904:            return out;
        -: 4905:        }
        -: 4906:    };
        -: 4907:
        -: 4908:    void formatReconstructedExpression( std::ostream &os, std::string const& lhs, StringRef op, std::string const& rhs );
        -: 4909:
        -: 4910:    template<typename LhsT, typename RhsT>
        8: 4911:    class BinaryExpr  : public ITransientExpression {
        -: 4912:        LhsT m_lhs;
        -: 4913:        StringRef m_op;
        -: 4914:        RhsT m_rhs;
        -: 4915:
    #####: 4916:        void streamReconstructedExpression( std::ostream &os ) const override {
    #####: 4917:            formatReconstructedExpression
    #####: 4918:                    ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );
    #####: 4919:        }
        -: 4920:
        -: 4921:    public:
        -: 4922:        BinaryExpr( bool comparisonResult, LhsT lhs, StringRef op, RhsT rhs )
        -: 4923:        :   ITransientExpression{ true, comparisonResult },
        -: 4924:            m_lhs( lhs ),
        -: 4925:            m_op( op ),
        4: 4926:            m_rhs( rhs )
        -: 4927:        {}
        -: 4928:
        -: 4929:        template<typename T>
        -: 4930:        auto operator && ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
        -: 4931:            static_assert(always_false<T>::value,
        -: 4932:            "chained comparisons are not supported inside assertions, "
        -: 4933:            "wrap the expression inside parentheses, or decompose it");
        -: 4934:        }
        -: 4935:
        -: 4936:        template<typename T>
        -: 4937:        auto operator || ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
        -: 4938:            static_assert(always_false<T>::value,
        -: 4939:            "chained comparisons are not supported inside assertions, "
        -: 4940:            "wrap the expression inside parentheses, or decompose it");
        -: 4941:        }
        -: 4942:
        -: 4943:        template<typename T>
        -: 4944:        auto operator == ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
        -: 4945:            static_assert(always_false<T>::value,
        -: 4946:            "chained comparisons are not supported inside assertions, "
        -: 4947:            "wrap the expression inside parentheses, or decompose it");
        -: 4948:        }
        -: 4949:
        -: 4950:        template<typename T>
        -: 4951:        auto operator != ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
        -: 4952:            static_assert(always_false<T>::value,
        -: 4953:            "chained comparisons are not supported inside assertions, "
        -: 4954:            "wrap the expression inside parentheses, or decompose it");
        -: 4955:        }
        -: 4956:
        -: 4957:        template<typename T>
        -: 4958:        auto operator > ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
        -: 4959:            static_assert(always_false<T>::value,
        -: 4960:            "chained comparisons are not supported inside assertions, "
        -: 4961:            "wrap the expression inside parentheses, or decompose it");
        -: 4962:        }
        -: 4963:
        -: 4964:        template<typename T>
        -: 4965:        auto operator < ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
        -: 4966:            static_assert(always_false<T>::value,
        -: 4967:            "chained comparisons are not supported inside assertions, "
        -: 4968:            "wrap the expression inside parentheses, or decompose it");
        -: 4969:        }
        -: 4970:
        -: 4971:        template<typename T>
        -: 4972:        auto operator >= ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
        -: 4973:            static_assert(always_false<T>::value,
        -: 4974:            "chained comparisons are not supported inside assertions, "
        -: 4975:            "wrap the expression inside parentheses, or decompose it");
        -: 4976:        }
        -: 4977:
        -: 4978:        template<typename T>
        -: 4979:        auto operator <= ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
        -: 4980:            static_assert(always_false<T>::value,
        -: 4981:            "chained comparisons are not supported inside assertions, "
        -: 4982:            "wrap the expression inside parentheses, or decompose it");
        -: 4983:        }
        -: 4984:    };
        -: 4985:
        -: 4986:    template<typename LhsT>
        -: 4987:    class UnaryExpr : public ITransientExpression {
        -: 4988:        LhsT m_lhs;
        -: 4989:
        -: 4990:        void streamReconstructedExpression( std::ostream &os ) const override {
        -: 4991:            os << Catch::Detail::stringify( m_lhs );
        -: 4992:        }
        -: 4993:
        -: 4994:    public:
        -: 4995:        explicit UnaryExpr( LhsT lhs )
        -: 4996:        :   ITransientExpression{ false, static_cast<bool>(lhs) },
        -: 4997:            m_lhs( lhs )
        -: 4998:        {}
        -: 4999:    };
        -: 5000:
        -: 5001:
        -: 5002:    // Specialised comparison functions to handle equality comparisons between ints and pointers (NULL deduces as an int)
        -: 5003:    template<typename LhsT, typename RhsT>
        3: 5004:    auto compareEqual( LhsT const& lhs, RhsT const& rhs ) -> bool { return static_cast<bool>(lhs == rhs); }
        -: 5005:    template<typename T>
        -: 5006:    auto compareEqual( T* const& lhs, int rhs ) -> bool { return lhs == reinterpret_cast<void const*>( rhs ); }
        -: 5007:    template<typename T>
        -: 5008:    auto compareEqual( T* const& lhs, long rhs ) -> bool { return lhs == reinterpret_cast<void const*>( rhs ); }
        -: 5009:    template<typename T>
        -: 5010:    auto compareEqual( int lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) == rhs; }
        -: 5011:    template<typename T>
        -: 5012:    auto compareEqual( long lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) == rhs; }
        -: 5013:
        -: 5014:    template<typename LhsT, typename RhsT>
        -: 5015:    auto compareNotEqual( LhsT const& lhs, RhsT&& rhs ) -> bool { return static_cast<bool>(lhs != rhs); }
        -: 5016:    template<typename T>
        -: 5017:    auto compareNotEqual( T* const& lhs, int rhs ) -> bool { return lhs != reinterpret_cast<void const*>( rhs ); }
        -: 5018:    template<typename T>
        -: 5019:    auto compareNotEqual( T* const& lhs, long rhs ) -> bool { return lhs != reinterpret_cast<void const*>( rhs ); }
        -: 5020:    template<typename T>
        -: 5021:    auto compareNotEqual( int lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) != rhs; }
        -: 5022:    template<typename T>
        -: 5023:    auto compareNotEqual( long lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) != rhs; }
        -: 5024:
        -: 5025:
        -: 5026:    template<typename LhsT>
        -: 5027:    class ExprLhs {
        -: 5028:        LhsT m_lhs;
        -: 5029:    public:
        -: 5030:        explicit ExprLhs( LhsT lhs ) : m_lhs( lhs ) {}
        -: 5031:
        -: 5032:        template<typename RhsT>
        -: 5033:        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5034:            return { compareEqual( m_lhs, rhs ), m_lhs, "=="_sr, rhs };
        -: 5035:        }
        -: 5036:        auto operator == ( bool rhs ) -> BinaryExpr<LhsT, bool> const {
        -: 5037:            return { m_lhs == rhs, m_lhs, "=="_sr, rhs };
        -: 5038:        }
        -: 5039:
        -: 5040:        template<typename RhsT>
        -: 5041:        auto operator != ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5042:            return { compareNotEqual( m_lhs, rhs ), m_lhs, "!="_sr, rhs };
        -: 5043:        }
        -: 5044:        auto operator != ( bool rhs ) -> BinaryExpr<LhsT, bool> const {
        -: 5045:            return { m_lhs != rhs, m_lhs, "!="_sr, rhs };
        -: 5046:        }
        -: 5047:
        -: 5048:        template<typename RhsT>
        -: 5049:        auto operator > ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5050:            return { static_cast<bool>(m_lhs > rhs), m_lhs, ">"_sr, rhs };
        -: 5051:        }
        -: 5052:        template<typename RhsT>
        -: 5053:        auto operator < ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5054:            return { static_cast<bool>(m_lhs < rhs), m_lhs, "<"_sr, rhs };
        -: 5055:        }
        -: 5056:        template<typename RhsT>
        -: 5057:        auto operator >= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5058:            return { static_cast<bool>(m_lhs >= rhs), m_lhs, ">="_sr, rhs };
        -: 5059:        }
        -: 5060:        template<typename RhsT>
        -: 5061:        auto operator <= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5062:            return { static_cast<bool>(m_lhs <= rhs), m_lhs, "<="_sr, rhs };
        -: 5063:        }
        -: 5064:        template <typename RhsT>
        -: 5065:        auto operator | (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5066:            return { static_cast<bool>(m_lhs | rhs), m_lhs, "|"_sr, rhs };
        -: 5067:        }
        -: 5068:        template <typename RhsT>
        -: 5069:        auto operator & (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5070:            return { static_cast<bool>(m_lhs & rhs), m_lhs, "&"_sr, rhs };
        -: 5071:        }
        -: 5072:        template <typename RhsT>
        -: 5073:        auto operator ^ (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5074:            return { static_cast<bool>(m_lhs ^ rhs), m_lhs, "^"_sr, rhs };
        -: 5075:        }
        -: 5076:
        -: 5077:        template<typename RhsT>
        -: 5078:        auto operator && ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5079:            static_assert(always_false<RhsT>::value,
        -: 5080:            "operator&& is not supported inside assertions, "
        -: 5081:            "wrap the expression inside parentheses, or decompose it");
        -: 5082:        }
        -: 5083:
        -: 5084:        template<typename RhsT>
        -: 5085:        auto operator || ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5086:            static_assert(always_false<RhsT>::value,
        -: 5087:            "operator|| is not supported inside assertions, "
        -: 5088:            "wrap the expression inside parentheses, or decompose it");
        -: 5089:        }
        -: 5090:
        -: 5091:        auto makeUnaryExpr() const -> UnaryExpr<LhsT> {
        -: 5092:            return UnaryExpr<LhsT>{ m_lhs };
        -: 5093:        }
        -: 5094:    };
        -: 5095:
        -: 5096:    void handleExpression( ITransientExpression const& expr );
        -: 5097:
        -: 5098:    template<typename T>
        -: 5099:    void handleExpression( ExprLhs<T> const& expr ) {
        -: 5100:        handleExpression( expr.makeUnaryExpr() );
        -: 5101:    }
        -: 5102:
        -: 5103:    struct Decomposer {
        -: 5104:        template<typename T>
        -: 5105:        auto operator <= ( T const& lhs ) -> ExprLhs<T const&> {
        -: 5106:            return ExprLhs<T const&>{ lhs };
        -: 5107:        }
        -: 5108:
        -: 5109:        auto operator <=( bool value ) -> ExprLhs<bool> {
        -: 5110:            return ExprLhs<bool>{ value };
        -: 5111:        }
        -: 5112:    };
        -: 5113:
        -: 5114:} // end namespace Catch
        -: 5115:
        -: 5116:#ifdef _MSC_VER
        -: 5117:#pragma warning(pop)
        -: 5118:#endif
        -: 5119:#ifdef __clang__
        -: 5120:#  pragma clang diagnostic pop
        -: 5121:#elif defined __GNUC__
        -: 5122:#  pragma GCC diagnostic pop
        -: 5123:#endif
        -: 5124:
        -: 5125:#endif // CATCH_DECOMPOSER_HPP_INCLUDED
        -: 5126:
        -: 5127:namespace Catch {
        -: 5128:
        -: 5129:    struct TestFailureException{};
        -: 5130:    struct AssertionResultData;
        -: 5131:    struct IResultCapture;
        -: 5132:    class RunContext;
        -: 5133:
        4: 5134:    struct AssertionReaction {
        -: 5135:        bool shouldDebugBreak = false;
        -: 5136:        bool shouldThrow = false;
        -: 5137:    };
        -: 5138:
        -: 5139:    class AssertionHandler {
        -: 5140:        AssertionInfo m_assertionInfo;
        -: 5141:        AssertionReaction m_reaction;
        -: 5142:        bool m_completed = false;
        -: 5143:        IResultCapture& m_resultCapture;
        -: 5144:
        -: 5145:    public:
        -: 5146:        AssertionHandler
        -: 5147:            (   StringRef const& macroName,
        -: 5148:                SourceLineInfo const& lineInfo,
        -: 5149:                StringRef capturedExpression,
        -: 5150:                ResultDisposition::Flags resultDisposition );
        4: 5151:        ~AssertionHandler() {
        4: 5152:            if ( !m_completed ) {
    #####: 5153:                m_resultCapture.handleIncomplete( m_assertionInfo );
        -: 5154:            }
        -: 5155:        }
        -: 5156:
        -: 5157:
        -: 5158:        template<typename T>
        -: 5159:        void handleExpr( ExprLhs<T> const& expr ) {
        -: 5160:            handleExpr( expr.makeUnaryExpr() );
        -: 5161:        }
        -: 5162:        void handleExpr( ITransientExpression const& expr );
        -: 5163:
        -: 5164:        void handleMessage(ResultWas::OfType resultType, StringRef const& message);
        -: 5165:
        -: 5166:        void handleExceptionThrownAsExpected();
        -: 5167:        void handleUnexpectedExceptionNotThrown();
        -: 5168:        void handleExceptionNotThrownAsExpected();
        -: 5169:        void handleThrowingCallSkipped();
        -: 5170:        void handleUnexpectedInflightException();
        -: 5171:
        -: 5172:        void complete();
        -: 5173:        void setCompleted();
        -: 5174:
        -: 5175:        // query
        -: 5176:        auto allowThrows() const -> bool;
        -: 5177:    };
        -: 5178:
        -: 5179:    void handleExceptionMatchExpr( AssertionHandler& handler, std::string const& str, StringRef const& matcherString );
        -: 5180:
        -: 5181:} // namespace Catch
        -: 5182:
        -: 5183:#endif // CATCH_ASSERTION_HANDLER_HPP_INCLUDED
        -: 5184:
        -: 5185:// We need this suppression to leak, because it took until GCC 9
        -: 5186:// for the front end to handle local suppression via _Pragma properly
        -: 5187:#if defined(__GNUC__) && !defined(__clang__) && !defined(__ICC) && __GNUC__ < 9
        -: 5188:  #pragma GCC diagnostic ignored "-Wparentheses"
        -: 5189:#endif
        -: 5190:
        -: 5191:#if !defined(CATCH_CONFIG_DISABLE)
        -: 5192:
        -: 5193:#if !defined(CATCH_CONFIG_DISABLE_STRINGIFICATION)
        -: 5194:  #define CATCH_INTERNAL_STRINGIFY(...) #__VA_ARGS__
        -: 5195:#else
        -: 5196:  #define CATCH_INTERNAL_STRINGIFY(...) "Disabled by CATCH_CONFIG_DISABLE_STRINGIFICATION"
        -: 5197:#endif
        -: 5198:
        -: 5199:#if defined(CATCH_CONFIG_FAST_COMPILE) || defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
        -: 5200:
        -: 5201:///////////////////////////////////////////////////////////////////////////////
        -: 5202:// Another way to speed-up compilation is to omit local try-catch for REQUIRE*
        -: 5203:// macros.
        -: 5204:#define INTERNAL_CATCH_TRY
        -: 5205:#define INTERNAL_CATCH_CATCH( capturer )
        -: 5206:
        -: 5207:#else // CATCH_CONFIG_FAST_COMPILE
        -: 5208:
        -: 5209:#define INTERNAL_CATCH_TRY try
        -: 5210:#define INTERNAL_CATCH_CATCH( handler ) catch(...) { handler.handleUnexpectedInflightException(); }
        -: 5211:
        -: 5212:#endif
        -: 5213:
        -: 5214:#define INTERNAL_CATCH_REACT( handler ) handler.complete();
        -: 5215:
        -: 5216:///////////////////////////////////////////////////////////////////////////////
        -: 5217:#define INTERNAL_CATCH_TEST( macroName, resultDisposition, ... ) \
        -: 5218:    do { \
        -: 5219:        /* The expression should not be evaluated, but warnings should hopefully be checked */ \
        -: 5220:        CATCH_INTERNAL_IGNORE_BUT_WARN(__VA_ARGS__); \
        -: 5221:        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \
        -: 5222:        INTERNAL_CATCH_TRY { \
        -: 5223:            CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 5224:            CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
        -: 5225:            catchAssertionHandler.handleExpr( Catch::Decomposer() <= __VA_ARGS__ ); \
        -: 5226:            CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 5227:        } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \
        -: 5228:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 5229:    } while( (void)0, (false) && static_cast<bool>( !!(__VA_ARGS__) ) )
        -: 5230:
        -: 5231:///////////////////////////////////////////////////////////////////////////////
        -: 5232:#define INTERNAL_CATCH_IF( macroName, resultDisposition, ... ) \
        -: 5233:    INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \
        -: 5234:    if( Catch::getResultCapture().lastAssertionPassed() )
        -: 5235:
        -: 5236:///////////////////////////////////////////////////////////////////////////////
        -: 5237:#define INTERNAL_CATCH_ELSE( macroName, resultDisposition, ... ) \
        -: 5238:    INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \
        -: 5239:    if( !Catch::getResultCapture().lastAssertionPassed() )
        -: 5240:
        -: 5241:///////////////////////////////////////////////////////////////////////////////
        -: 5242:#define INTERNAL_CATCH_NO_THROW( macroName, resultDisposition, ... ) \
        -: 5243:    do { \
        -: 5244:        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \
        -: 5245:        try { \
        -: 5246:            static_cast<void>(__VA_ARGS__); \
        -: 5247:            catchAssertionHandler.handleExceptionNotThrownAsExpected(); \
        -: 5248:        } \
        -: 5249:        catch( ... ) { \
        -: 5250:            catchAssertionHandler.handleUnexpectedInflightException(); \
        -: 5251:        } \
        -: 5252:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 5253:    } while( false )
        -: 5254:
        -: 5255:///////////////////////////////////////////////////////////////////////////////
        -: 5256:#define INTERNAL_CATCH_THROWS( macroName, resultDisposition, ... ) \
        -: 5257:    do { \
        -: 5258:        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition); \
        -: 5259:        if( catchAssertionHandler.allowThrows() ) \
        -: 5260:            try { \
        -: 5261:                static_cast<void>(__VA_ARGS__); \
        -: 5262:                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
        -: 5263:            } \
        -: 5264:            catch( ... ) { \
        -: 5265:                catchAssertionHandler.handleExceptionThrownAsExpected(); \
        -: 5266:            } \
        -: 5267:        else \
        -: 5268:            catchAssertionHandler.handleThrowingCallSkipped(); \
        -: 5269:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 5270:    } while( false )
        -: 5271:
        -: 5272:///////////////////////////////////////////////////////////////////////////////
        -: 5273:#define INTERNAL_CATCH_THROWS_AS( macroName, exceptionType, resultDisposition, expr ) \
        -: 5274:    do { \
        -: 5275:        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) ", " CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \
        -: 5276:        if( catchAssertionHandler.allowThrows() ) \
        -: 5277:            try { \
        -: 5278:                static_cast<void>(expr); \
        -: 5279:                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
        -: 5280:            } \
        -: 5281:            catch( exceptionType const& ) { \
        -: 5282:                catchAssertionHandler.handleExceptionThrownAsExpected(); \
        -: 5283:            } \
        -: 5284:            catch( ... ) { \
        -: 5285:                catchAssertionHandler.handleUnexpectedInflightException(); \
        -: 5286:            } \
        -: 5287:        else \
        -: 5288:            catchAssertionHandler.handleThrowingCallSkipped(); \
        -: 5289:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 5290:    } while( false )
        -: 5291:
        -: 5292:
        -: 5293:
        -: 5294:///////////////////////////////////////////////////////////////////////////////
        -: 5295:// Although this is matcher-based, it can be used with just a string
        -: 5296:#define INTERNAL_CATCH_THROWS_STR_MATCHES( macroName, resultDisposition, matcher, ... ) \
        -: 5297:    do { \
        -: 5298:        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
        -: 5299:        if( catchAssertionHandler.allowThrows() ) \
        -: 5300:            try { \
        -: 5301:                static_cast<void>(__VA_ARGS__); \
        -: 5302:                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
        -: 5303:            } \
        -: 5304:            catch( ... ) { \
        -: 5305:                Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher, #matcher##_catch_sr ); \
        -: 5306:            } \
        -: 5307:        else \
        -: 5308:            catchAssertionHandler.handleThrowingCallSkipped(); \
        -: 5309:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 5310:    } while( false )
        -: 5311:
        -: 5312:#endif // CATCH_CONFIG_DISABLE
        -: 5313:
        -: 5314:#endif // CATCH_TEST_MACRO_IMPL_HPP_INCLUDED
        -: 5315:
        -: 5316:
        -: 5317:#ifndef CATCH_PREPROCESSOR_HPP_INCLUDED
        -: 5318:#define CATCH_PREPROCESSOR_HPP_INCLUDED
        -: 5319:
        -: 5320:
        -: 5321:#if defined(__GNUC__)
        -: 5322:// We need to silence "empty __VA_ARGS__ warning", and using just _Pragma does not work
        -: 5323:#pragma GCC system_header
        -: 5324:#endif
        -: 5325:
        -: 5326:
        -: 5327:#define CATCH_RECURSION_LEVEL0(...) __VA_ARGS__
        -: 5328:#define CATCH_RECURSION_LEVEL1(...) CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(__VA_ARGS__)))
        -: 5329:#define CATCH_RECURSION_LEVEL2(...) CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(__VA_ARGS__)))
        -: 5330:#define CATCH_RECURSION_LEVEL3(...) CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(__VA_ARGS__)))
        -: 5331:#define CATCH_RECURSION_LEVEL4(...) CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(__VA_ARGS__)))
        -: 5332:#define CATCH_RECURSION_LEVEL5(...) CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(__VA_ARGS__)))
        -: 5333:
        -: 5334:#ifdef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 5335:#define INTERNAL_CATCH_EXPAND_VARGS(...) __VA_ARGS__
        -: 5336:// MSVC needs more evaluations
        -: 5337:#define CATCH_RECURSION_LEVEL6(...) CATCH_RECURSION_LEVEL5(CATCH_RECURSION_LEVEL5(CATCH_RECURSION_LEVEL5(__VA_ARGS__)))
        -: 5338:#define CATCH_RECURSE(...)  CATCH_RECURSION_LEVEL6(CATCH_RECURSION_LEVEL6(__VA_ARGS__))
        -: 5339:#else
        -: 5340:#define CATCH_RECURSE(...)  CATCH_RECURSION_LEVEL5(__VA_ARGS__)
        -: 5341:#endif
        -: 5342:
        -: 5343:#define CATCH_REC_END(...)
        -: 5344:#define CATCH_REC_OUT
        -: 5345:
        -: 5346:#define CATCH_EMPTY()
        -: 5347:#define CATCH_DEFER(id) id CATCH_EMPTY()
        -: 5348:
        -: 5349:#define CATCH_REC_GET_END2() 0, CATCH_REC_END
        -: 5350:#define CATCH_REC_GET_END1(...) CATCH_REC_GET_END2
        -: 5351:#define CATCH_REC_GET_END(...) CATCH_REC_GET_END1
        -: 5352:#define CATCH_REC_NEXT0(test, next, ...) next CATCH_REC_OUT
        -: 5353:#define CATCH_REC_NEXT1(test, next) CATCH_DEFER ( CATCH_REC_NEXT0 ) ( test, next, 0)
        -: 5354:#define CATCH_REC_NEXT(test, next)  CATCH_REC_NEXT1(CATCH_REC_GET_END test, next)
        -: 5355:
        -: 5356:#define CATCH_REC_LIST0(f, x, peek, ...) , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )
        -: 5357:#define CATCH_REC_LIST1(f, x, peek, ...) , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0) ) ( f, peek, __VA_ARGS__ )
        -: 5358:#define CATCH_REC_LIST2(f, x, peek, ...)   f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )
        -: 5359:
        -: 5360:#define CATCH_REC_LIST0_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )
        -: 5361:#define CATCH_REC_LIST1_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0_UD) ) ( f, userdata, peek, __VA_ARGS__ )
        -: 5362:#define CATCH_REC_LIST2_UD(f, userdata, x, peek, ...)   f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )
        -: 5363:
        -: 5364:// Applies the function macro `f` to each of the remaining parameters, inserts commas between the results,
        -: 5365:// and passes userdata as the first parameter to each invocation,
        -: 5366:// e.g. CATCH_REC_LIST_UD(f, x, a, b, c) evaluates to f(x, a), f(x, b), f(x, c)
        -: 5367:#define CATCH_REC_LIST_UD(f, userdata, ...) CATCH_RECURSE(CATCH_REC_LIST2_UD(f, userdata, __VA_ARGS__, ()()(), ()()(), ()()(), 0))
        -: 5368:
        -: 5369:#define CATCH_REC_LIST(f, ...) CATCH_RECURSE(CATCH_REC_LIST2(f, __VA_ARGS__, ()()(), ()()(), ()()(), 0))
        -: 5370:
        -: 5371:#define INTERNAL_CATCH_EXPAND1(param) INTERNAL_CATCH_EXPAND2(param)
        -: 5372:#define INTERNAL_CATCH_EXPAND2(...) INTERNAL_CATCH_NO## __VA_ARGS__
        -: 5373:#define INTERNAL_CATCH_DEF(...) INTERNAL_CATCH_DEF __VA_ARGS__
        -: 5374:#define INTERNAL_CATCH_NOINTERNAL_CATCH_DEF
        -: 5375:#define INTERNAL_CATCH_STRINGIZE(...) INTERNAL_CATCH_STRINGIZE2(__VA_ARGS__)
        -: 5376:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 5377:#define INTERNAL_CATCH_STRINGIZE2(...) #__VA_ARGS__
        -: 5378:#define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param))
        -: 5379:#else
        -: 5380:// MSVC is adding extra space and needs another indirection to expand INTERNAL_CATCH_NOINTERNAL_CATCH_DEF
        -: 5381:#define INTERNAL_CATCH_STRINGIZE2(...) INTERNAL_CATCH_STRINGIZE3(__VA_ARGS__)
        -: 5382:#define INTERNAL_CATCH_STRINGIZE3(...) #__VA_ARGS__
        -: 5383:#define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) (INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param)) + 1)
        -: 5384:#endif
        -: 5385:
        -: 5386:#define INTERNAL_CATCH_MAKE_NAMESPACE2(...) ns_##__VA_ARGS__
        -: 5387:#define INTERNAL_CATCH_MAKE_NAMESPACE(name) INTERNAL_CATCH_MAKE_NAMESPACE2(name)
        -: 5388:
        -: 5389:#define INTERNAL_CATCH_REMOVE_PARENS(...) INTERNAL_CATCH_EXPAND1(INTERNAL_CATCH_DEF __VA_ARGS__)
        -: 5390:
        -: 5391:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 5392:#define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>())
        -: 5393:#define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__))
        -: 5394:#else
        -: 5395:#define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) INTERNAL_CATCH_EXPAND_VARGS(decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>()))
        -: 5396:#define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))
        -: 5397:#endif
        -: 5398:
        -: 5399:#define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(...)\
        -: 5400:    CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,__VA_ARGS__)
        -: 5401:
        -: 5402:#define INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_0) INTERNAL_CATCH_REMOVE_PARENS(_0)
        -: 5403:#define INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_0, _1) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_1)
        -: 5404:#define INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_0, _1, _2) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_1, _2)
        -: 5405:#define INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_0, _1, _2, _3) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_1, _2, _3)
        -: 5406:#define INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_0, _1, _2, _3, _4) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_1, _2, _3, _4)
        -: 5407:#define INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_0, _1, _2, _3, _4, _5) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_1, _2, _3, _4, _5)
        -: 5408:#define INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_0, _1, _2, _3, _4, _5, _6) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_1, _2, _3, _4, _5, _6)
        -: 5409:#define INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_0, _1, _2, _3, _4, _5, _6, _7) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_1, _2, _3, _4, _5, _6, _7)
        -: 5410:#define INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_1, _2, _3, _4, _5, _6, _7, _8)
        -: 5411:#define INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9)
        -: 5412:#define INTERNAL_CATCH_REMOVE_PARENS_11_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10)
        -: 5413:
        -: 5414:#define INTERNAL_CATCH_VA_NARGS_IMPL(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N
        -: 5415:
        -: 5416:#define INTERNAL_CATCH_TYPE_GEN\
        -: 5417:    template<typename...> struct TypeList {};\
        -: 5418:    template<typename...Ts>\
        -: 5419:    constexpr auto get_wrapper() noexcept -> TypeList<Ts...> { return {}; }\
        -: 5420:    template<template<typename...> class...> struct TemplateTypeList{};\
        -: 5421:    template<template<typename...> class...Cs>\
        -: 5422:    constexpr auto get_wrapper() noexcept -> TemplateTypeList<Cs...> { return {}; }\
        -: 5423:    template<typename...>\
        -: 5424:    struct append;\
        -: 5425:    template<typename...>\
        -: 5426:    struct rewrap;\
        -: 5427:    template<template<typename...> class, typename...>\
        -: 5428:    struct create;\
        -: 5429:    template<template<typename...> class, typename>\
        -: 5430:    struct convert;\
        -: 5431:    \
        -: 5432:    template<typename T> \
        -: 5433:    struct append<T> { using type = T; };\
        -: 5434:    template< template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2, typename...Rest>\
        -: 5435:    struct append<L1<E1...>, L2<E2...>, Rest...> { using type = typename append<L1<E1...,E2...>, Rest...>::type; };\
        -: 5436:    template< template<typename...> class L1, typename...E1, typename...Rest>\
        -: 5437:    struct append<L1<E1...>, TypeList<mpl_::na>, Rest...> { using type = L1<E1...>; };\
        -: 5438:    \
        -: 5439:    template< template<typename...> class Container, template<typename...> class List, typename...elems>\
        -: 5440:    struct rewrap<TemplateTypeList<Container>, List<elems...>> { using type = TypeList<Container<elems...>>; };\
        -: 5441:    template< template<typename...> class Container, template<typename...> class List, class...Elems, typename...Elements>\
        -: 5442:    struct rewrap<TemplateTypeList<Container>, List<Elems...>, Elements...> { using type = typename append<TypeList<Container<Elems...>>, typename rewrap<TemplateTypeList<Container>, Elements...>::type>::type; };\
        -: 5443:    \
        -: 5444:    template<template <typename...> class Final, template< typename...> class...Containers, typename...Types>\
        -: 5445:    struct create<Final, TemplateTypeList<Containers...>, TypeList<Types...>> { using type = typename append<Final<>, typename rewrap<TemplateTypeList<Containers>, Types...>::type...>::type; };\
        -: 5446:    template<template <typename...> class Final, template <typename...> class List, typename...Ts>\
        -: 5447:    struct convert<Final, List<Ts...>> { using type = typename append<Final<>,TypeList<Ts>...>::type; };
        -: 5448:
        -: 5449:#define INTERNAL_CATCH_NTTP_1(signature, ...)\
        -: 5450:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> struct Nttp{};\
        -: 5451:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
        -: 5452:    constexpr auto get_wrapper() noexcept -> Nttp<__VA_ARGS__> { return {}; } \
        -: 5453:    template<template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...> struct NttpTemplateTypeList{};\
        -: 5454:    template<template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...Cs>\
        -: 5455:    constexpr auto get_wrapper() noexcept -> NttpTemplateTypeList<Cs...> { return {}; } \
        -: 5456:    \
        -: 5457:    template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature)>\
        -: 5458:    struct rewrap<NttpTemplateTypeList<Container>, List<__VA_ARGS__>> { using type = TypeList<Container<__VA_ARGS__>>; };\
        -: 5459:    template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature), typename...Elements>\
        -: 5460:    struct rewrap<NttpTemplateTypeList<Container>, List<__VA_ARGS__>, Elements...> { using type = typename append<TypeList<Container<__VA_ARGS__>>, typename rewrap<NttpTemplateTypeList<Container>, Elements...>::type>::type; };\
        -: 5461:    template<template <typename...> class Final, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...Containers, typename...Types>\
        -: 5462:    struct create<Final, NttpTemplateTypeList<Containers...>, TypeList<Types...>> { using type = typename append<Final<>, typename rewrap<NttpTemplateTypeList<Containers>, Types...>::type...>::type; };
        -: 5463:
        -: 5464:#define INTERNAL_CATCH_DECLARE_SIG_TEST0(TestName)
        -: 5465:#define INTERNAL_CATCH_DECLARE_SIG_TEST1(TestName, signature)\
        -: 5466:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
        -: 5467:    static void TestName()
        -: 5468:#define INTERNAL_CATCH_DECLARE_SIG_TEST_X(TestName, signature, ...)\
        -: 5469:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
        -: 5470:    static void TestName()
        -: 5471:
        -: 5472:#define INTERNAL_CATCH_DEFINE_SIG_TEST0(TestName)
        -: 5473:#define INTERNAL_CATCH_DEFINE_SIG_TEST1(TestName, signature)\
        -: 5474:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
        -: 5475:    static void TestName()
        -: 5476:#define INTERNAL_CATCH_DEFINE_SIG_TEST_X(TestName, signature,...)\
        -: 5477:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
        -: 5478:    static void TestName()
        -: 5479:
        -: 5480:#define INTERNAL_CATCH_NTTP_REGISTER0(TestFunc, signature)\
        -: 5481:    template<typename Type>\
        -: 5482:    void reg_test(TypeList<Type>, Catch::NameAndTags nameAndTags)\
        -: 5483:    {\
        -: 5484:        Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<Type>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\
        -: 5485:    }
        -: 5486:
        -: 5487:#define INTERNAL_CATCH_NTTP_REGISTER(TestFunc, signature, ...)\
        -: 5488:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
        -: 5489:    void reg_test(Nttp<__VA_ARGS__>, Catch::NameAndTags nameAndTags)\
        -: 5490:    {\
        -: 5491:        Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<__VA_ARGS__>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\
        -: 5492:    }
        -: 5493:
        -: 5494:#define INTERNAL_CATCH_NTTP_REGISTER_METHOD0(TestName, signature, ...)\
        -: 5495:    template<typename Type>\
        -: 5496:    void reg_test(TypeList<Type>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\
        -: 5497:    {\
        -: 5498:        Catch::AutoReg( Catch::makeTestInvoker(&TestName<Type>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\
        -: 5499:    }
        -: 5500:
        -: 5501:#define INTERNAL_CATCH_NTTP_REGISTER_METHOD(TestName, signature, ...)\
        -: 5502:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
        -: 5503:    void reg_test(Nttp<__VA_ARGS__>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\
        -: 5504:    {\
        -: 5505:        Catch::AutoReg( Catch::makeTestInvoker(&TestName<__VA_ARGS__>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\
        -: 5506:    }
        -: 5507:
        -: 5508:#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0(TestName, ClassName)
        -: 5509:#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1(TestName, ClassName, signature)\
        -: 5510:    template<typename TestType> \
        -: 5511:    struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<TestType> { \
        -: 5512:        void test();\
        -: 5513:    }
        -: 5514:
        -: 5515:#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X(TestName, ClassName, signature, ...)\
        -: 5516:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \
        -: 5517:    struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<__VA_ARGS__> { \
        -: 5518:        void test();\
        -: 5519:    }
        -: 5520:
        -: 5521:#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0(TestName)
        -: 5522:#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1(TestName, signature)\
        -: 5523:    template<typename TestType> \
        -: 5524:    void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<TestType>::test()
        -: 5525:#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X(TestName, signature, ...)\
        -: 5526:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \
        -: 5527:    void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<__VA_ARGS__>::test()
        -: 5528:
        -: 5529:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 5530:#define INTERNAL_CATCH_NTTP_0
        -: 5531:#define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__),INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_0)
        -: 5532:#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__)
        -: 5533:#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__)
        -: 5534:#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__)
        -: 5535:#define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__)
        -: 5536:#define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__)
        -: 5537:#define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__)
        -: 5538:#define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__)
        -: 5539:#else
        -: 5540:#define INTERNAL_CATCH_NTTP_0(signature)
        -: 5541:#define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1,INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_0)( __VA_ARGS__))
        -: 5542:#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__))
        -: 5543:#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__))
        -: 5544:#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__))
        -: 5545:#define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__))
        -: 5546:#define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__))
        -: 5547:#define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__))
        -: 5548:#define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__))
        -: 5549:#endif
        -: 5550:
        -: 5551:#endif // CATCH_PREPROCESSOR_HPP_INCLUDED
        -: 5552:
        -: 5553:
        -: 5554:#ifndef CATCH_SECTION_HPP_INCLUDED
        -: 5555:#define CATCH_SECTION_HPP_INCLUDED
        -: 5556:
        -: 5557:
        -: 5558:
        -: 5559:#ifndef CATCH_TIMER_HPP_INCLUDED
        -: 5560:#define CATCH_TIMER_HPP_INCLUDED
        -: 5561:
        -: 5562:#include <cstdint>
        -: 5563:
        -: 5564:namespace Catch {
        -: 5565:
        -: 5566:    auto getCurrentNanosecondsSinceEpoch() -> uint64_t;
        -: 5567:    auto getEstimatedClockResolution() -> uint64_t;
        -: 5568:
    #####: 5569:    class Timer {
        -: 5570:        uint64_t m_nanoseconds = 0;
        -: 5571:    public:
        -: 5572:        void start();
        -: 5573:        auto getElapsedNanoseconds() const -> uint64_t;
        -: 5574:        auto getElapsedMicroseconds() const -> uint64_t;
        -: 5575:        auto getElapsedMilliseconds() const -> unsigned int;
        -: 5576:        auto getElapsedSeconds() const -> double;
        -: 5577:    };
        -: 5578:
        -: 5579:} // namespace Catch
        -: 5580:
        -: 5581:#endif // CATCH_TIMER_HPP_INCLUDED
        -: 5582:
        -: 5583:#include <string>
        -: 5584:
        -: 5585:namespace Catch {
        -: 5586:
        -: 5587:    class Section : Detail::NonCopyable {
        -: 5588:    public:
        -: 5589:        Section( SectionInfo&& info );
        -: 5590:        ~Section();
        -: 5591:
        -: 5592:        // This indicates whether the section should be executed or not
        -: 5593:        explicit operator bool() const;
        -: 5594:
        -: 5595:    private:
        -: 5596:        SectionInfo m_info;
        -: 5597:
        -: 5598:        Counts m_assertions;
        -: 5599:        bool m_sectionIncluded;
        -: 5600:        Timer m_timer;
        -: 5601:    };
        -: 5602:
        -: 5603:} // end namespace Catch
        -: 5604:
        -: 5605:#define INTERNAL_CATCH_SECTION( ... ) \
        -: 5606:    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 5607:    CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -: 5608:    if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) ) \
        -: 5609:    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -: 5610:
        -: 5611:#define INTERNAL_CATCH_DYNAMIC_SECTION( ... ) \
        -: 5612:    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 5613:    CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -: 5614:    if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, (Catch::ReusableStringStream() << __VA_ARGS__).str() ) ) \
        -: 5615:    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -: 5616:
        -: 5617:#endif // CATCH_SECTION_HPP_INCLUDED
        -: 5618:
        -: 5619:
        -: 5620:#ifndef CATCH_TEST_REGISTRY_HPP_INCLUDED
        -: 5621:#define CATCH_TEST_REGISTRY_HPP_INCLUDED
        -: 5622:
        -: 5623:
        -: 5624:
        -: 5625:#ifndef CATCH_INTERFACES_TESTCASE_HPP_INCLUDED
        -: 5626:#define CATCH_INTERFACES_TESTCASE_HPP_INCLUDED
        -: 5627:
        -: 5628:#include <vector>
        -: 5629:
        -: 5630:namespace Catch {
        -: 5631:
        -: 5632:    class TestSpec;
        -: 5633:    struct TestCaseInfo;
        -: 5634:
        2: 5635:    struct ITestInvoker {
        -: 5636:        virtual void invoke () const = 0;
        -: 5637:        virtual ~ITestInvoker();
        -: 5638:    };
        -: 5639:
        -: 5640:    class TestCaseHandle;
        -: 5641:    struct IConfig;
        -: 5642:
        2: 5643:    struct ITestCaseRegistry {
        -: 5644:        virtual ~ITestCaseRegistry();
        -: 5645:        // TODO: this exists only for adding filenames to test cases -- let's expose this in a saner way later
        -: 5646:        virtual std::vector<TestCaseInfo* > const& getAllInfos() const = 0;
        -: 5647:        virtual std::vector<TestCaseHandle> const& getAllTests() const = 0;
        -: 5648:        virtual std::vector<TestCaseHandle> const& getAllTestsSorted( IConfig const& config ) const = 0;
        -: 5649:    };
        -: 5650:
        -: 5651:    bool isThrowSafe( TestCaseHandle const& testCase, IConfig const& config );
        -: 5652:    bool matchTest( TestCaseHandle const& testCase, TestSpec const& testSpec, IConfig const& config );
        -: 5653:    std::vector<TestCaseHandle> filterTests( std::vector<TestCaseHandle> const& testCases, TestSpec const& testSpec, IConfig const& config );
        -: 5654:    std::vector<TestCaseHandle> const& getAllTestCasesSorted( IConfig const& config );
        -: 5655:
        -: 5656:}
        -: 5657:
        -: 5658:#endif // CATCH_INTERFACES_TESTCASE_HPP_INCLUDED
        -: 5659:
        -: 5660:// GCC 5 and older do not properly handle disabling unused-variable warning
        -: 5661:// with a _Pragma. This means that we have to leak the suppression to the
        -: 5662:// user code as well :-(
        -: 5663:#if defined(__GNUC__) && !defined(__clang__) && __GNUC__ <= 5
        -: 5664:#pragma GCC diagnostic ignored "-Wunused-variable"
        -: 5665:#endif
        -: 5666:
        -: 5667:
        -: 5668:
        -: 5669:namespace Catch {
        -: 5670:
        -: 5671:template<typename C>
        -: 5672:class TestInvokerAsMethod : public ITestInvoker {
        -: 5673:    void (C::*m_testAsMethod)();
        -: 5674:public:
        -: 5675:    TestInvokerAsMethod( void (C::*testAsMethod)() ) noexcept : m_testAsMethod( testAsMethod ) {}
        -: 5676:
        -: 5677:    void invoke() const override {
        -: 5678:        C obj;
        -: 5679:        (obj.*m_testAsMethod)();
        -: 5680:    }
        -: 5681:};
        -: 5682:
        -: 5683:Detail::unique_ptr<ITestInvoker> makeTestInvoker( void(*testAsFunction)() );
        -: 5684:
        -: 5685:template<typename C>
        -: 5686:Detail::unique_ptr<ITestInvoker> makeTestInvoker( void (C::*testAsMethod)() ) {
        -: 5687:    return Detail::unique_ptr<ITestInvoker>( new TestInvokerAsMethod<C>(testAsMethod) );
        -: 5688:}
        -: 5689:
        -: 5690:struct NameAndTags {
        -: 5691:    NameAndTags(StringRef const& name_ = StringRef(),
        -: 5692:                StringRef const& tags_ = StringRef()) noexcept:
        1: 5693:        name(name_), tags(tags_) {}
        -: 5694:    StringRef name;
        -: 5695:    StringRef tags;
        -: 5696:};
        -: 5697:
        -: 5698:struct AutoReg : Detail::NonCopyable {
        -: 5699:    AutoReg( Detail::unique_ptr<ITestInvoker> invoker, SourceLineInfo const& lineInfo, StringRef const& classOrMethod, NameAndTags const& nameAndTags ) noexcept;
        -: 5700:};
        -: 5701:
        -: 5702:} // end namespace Catch
        -: 5703:
        -: 5704:#if defined(CATCH_CONFIG_DISABLE)
        -: 5705:    #define INTERNAL_CATCH_TESTCASE_NO_REGISTRATION( TestName, ... ) \
        -: 5706:        static inline void TestName()
        -: 5707:    #define INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... ) \
        -: 5708:        namespace{                        \
        -: 5709:            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) { \
        -: 5710:                void test();              \
        -: 5711:            };                            \
        -: 5712:        }                                 \
        -: 5713:        void TestName::test()
        -: 5714:#endif
        -: 5715:
        -: 5716:    ///////////////////////////////////////////////////////////////////////////////
        -: 5717:    #define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \
        -: 5718:        static void TestName(); \
        -: 5719:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 5720:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 5721:        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &TestName ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \
        -: 5722:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 5723:        static void TestName()
        -: 5724:    #define INTERNAL_CATCH_TESTCASE( ... ) \
        -: 5725:        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__ )
        -: 5726:
        -: 5727:    ///////////////////////////////////////////////////////////////////////////////
        -: 5728:    #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \
        -: 5729:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 5730:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 5731:        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &QualifiedMethod ), CATCH_INTERNAL_LINEINFO, "&" #QualifiedMethod, Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \
        -: 5732:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -: 5733:
        -: 5734:    ///////////////////////////////////////////////////////////////////////////////
        -: 5735:    #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\
        -: 5736:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 5737:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 5738:        namespace{ \
        -: 5739:            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) { \
        -: 5740:                void test(); \
        -: 5741:            }; \
        -: 5742:            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( Catch::makeTestInvoker( &TestName::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ __VA_ARGS__ } ); /* NOLINT */ \
        -: 5743:        } \
        -: 5744:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 5745:        void TestName::test()
        -: 5746:    #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \
        -: 5747:        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, __VA_ARGS__ )
        -: 5748:
        -: 5749:    ///////////////////////////////////////////////////////////////////////////////
        -: 5750:    #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \
        -: 5751:        do { \
        -: 5752:            CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 5753:            CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 5754:            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); /* NOLINT */ \
        -: 5755:            CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 5756:        } while(false)
        -: 5757:
        -: 5758:
        -: 5759:#endif // CATCH_TEST_REGISTRY_HPP_INCLUDED
        -: 5760:
        -: 5761:// All of our user-facing macros support configuration toggle, that
        -: 5762:// forces them to be defined prefixed with CATCH_. We also like to
        -: 5763:// support another toggle that can minimize (disable) their implementation.
        -: 5764:// Given this, we have 4 different configuration options below
        -: 5765:
        -: 5766:#if defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)
        -: 5767:
        -: 5768:  #define CATCH_REQUIRE( ... ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE", Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -: 5769:  #define CATCH_REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
        -: 5770:
        -: 5771:  #define CATCH_REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( "CATCH_REQUIRE_THROWS", Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -: 5772:  #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_REQUIRE_THROWS_AS", exceptionType, Catch::ResultDisposition::Normal, expr )
        -: 5773:  #define CATCH_REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CATCH_REQUIRE_NOTHROW", Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -: 5774:
        -: 5775:  #define CATCH_CHECK( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 5776:  #define CATCH_CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
        -: 5777:  #define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( "CATCH_CHECKED_IF", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 5778:  #define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( "CATCH_CHECKED_ELSE", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 5779:  #define CATCH_CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
        -: 5780:
        -: 5781:  #define CATCH_CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( "CATCH_CHECK_THROWS", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 5782:  #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_CHECK_THROWS_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
        -: 5783:  #define CATCH_CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CATCH_CHECK_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 5784:
        -: 5785:  #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
        -: 5786:  #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 5787:  #define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
        -: 5788:  #define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
        -: 5789:  #define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
        -: 5790:  #define CATCH_DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )
        -: 5791:  #define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -: 5792:  #define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 5793:  #define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( "CATCH_SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 5794:
        -: 5795:
        -: 5796:  #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)
        -: 5797:    #define CATCH_STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__ ,      #__VA_ARGS__ );     CATCH_SUCCEED( #__VA_ARGS__ )
        -: 5798:    #define CATCH_STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), "!(" #__VA_ARGS__ ")" ); CATCH_SUCCEED( #__VA_ARGS__ )
        -: 5799:  #else
        -: 5800:    #define CATCH_STATIC_REQUIRE( ... )       CATCH_REQUIRE( __VA_ARGS__ )
        -: 5801:    #define CATCH_STATIC_REQUIRE_FALSE( ... ) CATCH_REQUIRE_FALSE( __VA_ARGS__ )
        -: 5802:  #endif
        -: 5803:
        -: 5804:
        -: 5805:  // "BDD-style" convenience wrappers
        -: 5806:  #define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( "Scenario: " __VA_ARGS__ )
        -: 5807:  #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
        -: 5808:  #define CATCH_GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( "    Given: " << desc )
        -: 5809:  #define CATCH_AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( "And given: " << desc )
        -: 5810:  #define CATCH_WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     When: " << desc )
        -: 5811:  #define CATCH_AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( " And when: " << desc )
        -: 5812:  #define CATCH_THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     Then: " << desc )
        -: 5813:  #define CATCH_AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( "      And: " << desc )
        -: 5814:
        -: 5815:#elif defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE) // ^^ prefixed, implemented | vv prefixed, disabled
        -: 5816:
        -: 5817:  #define CATCH_REQUIRE( ... )        (void)(0)
        -: 5818:  #define CATCH_REQUIRE_FALSE( ... )  (void)(0)
        -: 5819:
        -: 5820:  #define CATCH_REQUIRE_THROWS( ... ) (void)(0)
        -: 5821:  #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
        -: 5822:  #define CATCH_REQUIRE_NOTHROW( ... ) (void)(0)
        -: 5823:
        -: 5824:  #define CATCH_CHECK( ... )         (void)(0)
        -: 5825:  #define CATCH_CHECK_FALSE( ... )   (void)(0)
        -: 5826:  #define CATCH_CHECKED_IF( ... )    if (__VA_ARGS__)
        -: 5827:  #define CATCH_CHECKED_ELSE( ... )  if (!(__VA_ARGS__))
        -: 5828:  #define CATCH_CHECK_NOFAIL( ... )  (void)(0)
        -: 5829:
        -: 5830:  #define CATCH_CHECK_THROWS( ... )  (void)(0)
        -: 5831:  #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
        -: 5832:  #define CATCH_CHECK_NOTHROW( ... ) (void)(0)
        -: 5833:
        -: 5834:  #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
        -: 5835:  #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
        -: 5836:  #define CATCH_METHOD_AS_TEST_CASE( method, ... )
        -: 5837:  #define CATCH_REGISTER_TEST_CASE( Function, ... ) (void)(0)
        -: 5838:  #define CATCH_SECTION( ... )
        -: 5839:  #define CATCH_DYNAMIC_SECTION( ... )
        -: 5840:  #define CATCH_FAIL( ... ) (void)(0)
        -: 5841:  #define CATCH_FAIL_CHECK( ... ) (void)(0)
        -: 5842:  #define CATCH_SUCCEED( ... ) (void)(0)
        -: 5843:
        -: 5844:  #define CATCH_STATIC_REQUIRE( ... )       (void)(0)
        -: 5845:  #define CATCH_STATIC_REQUIRE_FALSE( ... ) (void)(0)
        -: 5846:
        -: 5847:  // "BDD-style" convenience wrappers
        -: 5848:  #define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
        -: 5849:  #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
        -: 5850:  #define CATCH_GIVEN( desc )
        -: 5851:  #define CATCH_AND_GIVEN( desc )
        -: 5852:  #define CATCH_WHEN( desc )
        -: 5853:  #define CATCH_AND_WHEN( desc )
        -: 5854:  #define CATCH_THEN( desc )
        -: 5855:  #define CATCH_AND_THEN( desc )
        -: 5856:
        -: 5857:#elif !defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE) // ^^ prefixed, disabled | vv unprefixed, implemented
        -: 5858:
        -: 5859:  #define REQUIRE( ... ) INTERNAL_CATCH_TEST( "REQUIRE", Catch::ResultDisposition::Normal, __VA_ARGS__  )
        -: 5860:  #define REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( "REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
        -: 5861:
        -: 5862:  #define REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( "REQUIRE_THROWS", Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -: 5863:  #define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "REQUIRE_THROWS_AS", exceptionType, Catch::ResultDisposition::Normal, expr )
        -: 5864:  #define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "REQUIRE_NOTHROW", Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -: 5865:
        -: 5866:  #define CHECK( ... ) INTERNAL_CATCH_TEST( "CHECK", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 5867:  #define CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( "CHECK_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
        -: 5868:  #define CHECKED_IF( ... ) INTERNAL_CATCH_IF( "CHECKED_IF", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 5869:  #define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( "CHECKED_ELSE", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 5870:  #define CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( "CHECK_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
        -: 5871:
        -: 5872:  #define CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( "CHECK_THROWS", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 5873:  #define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CHECK_THROWS_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
        -: 5874:  #define CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CHECK_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 5875:
        -: 5876:  #define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
        -: 5877:  #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 5878:  #define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
        -: 5879:  #define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
        -: 5880:  #define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
        -: 5881:  #define DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )
        -: 5882:  #define FAIL( ... ) INTERNAL_CATCH_MSG( "FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -: 5883:  #define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 5884:  #define SUCCEED( ... ) INTERNAL_CATCH_MSG( "SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 5885:
        -: 5886:
        -: 5887:  #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)
        -: 5888:    #define STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__,  #__VA_ARGS__ ); SUCCEED( #__VA_ARGS__ )
        -: 5889:    #define STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), "!(" #__VA_ARGS__ ")" ); SUCCEED( "!(" #__VA_ARGS__ ")" )
        -: 5890:  #else
        -: 5891:    #define STATIC_REQUIRE( ... )       REQUIRE( __VA_ARGS__ )
        -: 5892:    #define STATIC_REQUIRE_FALSE( ... ) REQUIRE_FALSE( __VA_ARGS__ )
        -: 5893:  #endif
        -: 5894:
        -: 5895:  // "BDD-style" convenience wrappers
        -: 5896:  #define SCENARIO( ... ) TEST_CASE( "Scenario: " __VA_ARGS__ )
        -: 5897:  #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
        -: 5898:  #define GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( "    Given: " << desc )
        -: 5899:  #define AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( "And given: " << desc )
        -: 5900:  #define WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     When: " << desc )
        -: 5901:  #define AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( " And when: " << desc )
        -: 5902:  #define THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     Then: " << desc )
        -: 5903:  #define AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( "      And: " << desc )
        -: 5904:
        -: 5905:#elif !defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE) // ^^ unprefixed, implemented | vv unprefixed, disabled
        -: 5906:
        -: 5907:  #define REQUIRE( ... )       (void)(0)
        -: 5908:  #define REQUIRE_FALSE( ... ) (void)(0)
        -: 5909:
        -: 5910:  #define REQUIRE_THROWS( ... ) (void)(0)
        -: 5911:  #define REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
        -: 5912:  #define REQUIRE_NOTHROW( ... ) (void)(0)
        -: 5913:
        -: 5914:  #define CHECK( ... ) (void)(0)
        -: 5915:  #define CHECK_FALSE( ... ) (void)(0)
        -: 5916:  #define CHECKED_IF( ... ) if (__VA_ARGS__)
        -: 5917:  #define CHECKED_ELSE( ... ) if (!(__VA_ARGS__))
        -: 5918:  #define CHECK_NOFAIL( ... ) (void)(0)
        -: 5919:
        -: 5920:  #define CHECK_THROWS( ... )  (void)(0)
        -: 5921:  #define CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
        -: 5922:  #define CHECK_NOTHROW( ... ) (void)(0)
        -: 5923:
        -: 5924:  #define TEST_CASE( ... )  INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__)
        -: 5925:  #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
        -: 5926:  #define METHOD_AS_TEST_CASE( method, ... )
        -: 5927:  #define REGISTER_TEST_CASE( Function, ... ) (void)(0)
        -: 5928:  #define SECTION( ... )
        -: 5929:  #define DYNAMIC_SECTION( ... )
        -: 5930:  #define FAIL( ... ) (void)(0)
        -: 5931:  #define FAIL_CHECK( ... ) (void)(0)
        -: 5932:  #define SUCCEED( ... ) (void)(0)
        -: 5933:
        -: 5934:  #define STATIC_REQUIRE( ... )       (void)(0)
        -: 5935:  #define STATIC_REQUIRE_FALSE( ... ) (void)(0)
        -: 5936:
        -: 5937:  // "BDD-style" convenience wrappers
        -: 5938:  #define SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ) )
        -: 5939:  #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
        -: 5940:
        -: 5941:  #define GIVEN( desc )
        -: 5942:  #define AND_GIVEN( desc )
        -: 5943:  #define WHEN( desc )
        -: 5944:  #define AND_WHEN( desc )
        -: 5945:  #define THEN( desc )
        -: 5946:  #define AND_THEN( desc )
        -: 5947:
        -: 5948:#endif // ^^ unprefixed, disabled
        -: 5949:
        -: 5950:// end of user facing macros
        -: 5951:
        -: 5952:#endif // CATCH_TEST_MACROS_HPP_INCLUDED
        -: 5953:
        -: 5954:
        -: 5955:#ifndef CATCH_TEMPLATE_TEST_REGISTRY_HPP_INCLUDED
        -: 5956:#define CATCH_TEMPLATE_TEST_REGISTRY_HPP_INCLUDED
        -: 5957:
        -: 5958:
        -: 5959:// GCC 5 and older do not properly handle disabling unused-variable warning
        -: 5960:// with a _Pragma. This means that we have to leak the suppression to the
        -: 5961:// user code as well :-(
        -: 5962:#if defined(__GNUC__) && !defined(__clang__) && __GNUC__ <= 5
        -: 5963:#pragma GCC diagnostic ignored "-Wunused-variable"
        -: 5964:#endif
        -: 5965:
        -: 5966:#if defined(CATCH_CONFIG_DISABLE)
        -: 5967:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( TestName, TestFunc, Name, Tags, Signature, ... )  \
        -: 5968:        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature))
        -: 5969:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... )    \
        -: 5970:        namespace{                                                                                  \
        -: 5971:            namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                      \
        -: 5972:            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\
        -: 5973:        }                                                                                           \
        -: 5974:        }                                                                                           \
        -: 5975:        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))
        -: 5976:
        -: 5977:    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 5978:        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \
        -: 5979:            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )
        -: 5980:    #else
        -: 5981:        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \
        -: 5982:            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )
        -: 5983:    #endif
        -: 5984:
        -: 5985:    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 5986:        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \
        -: 5987:            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )
        -: 5988:    #else
        -: 5989:        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \
        -: 5990:            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )
        -: 5991:    #endif
        -: 5992:
        -: 5993:    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 5994:        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \
        -: 5995:            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )
        -: 5996:    #else
        -: 5997:        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \
        -: 5998:            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )
        -: 5999:    #endif
        -: 6000:
        -: 6001:    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6002:        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \
        -: 6003:            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )
        -: 6004:    #else
        -: 6005:        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \
        -: 6006:            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )
        -: 6007:    #endif
        -: 6008:#endif
        -: 6009:
        -: 6010:
        -: 6011:    ///////////////////////////////////////////////////////////////////////////////
        -: 6012:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, Signature, ... )\
        -: 6013:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 6014:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 6015:        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
        -: 6016:        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
        -: 6017:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -: 6018:        INTERNAL_CATCH_DECLARE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature));\
        -: 6019:        namespace {\
        -: 6020:        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\
        -: 6021:            INTERNAL_CATCH_TYPE_GEN\
        -: 6022:            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\
        -: 6023:            INTERNAL_CATCH_NTTP_REG_GEN(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\
        -: 6024:            template<typename...Types> \
        -: 6025:            struct TestName{\
        -: 6026:                TestName(){\
        -: 6027:                    int index = 0;                                    \
        -: 6028:                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\
        -: 6029:                    using expander = int[];\
        -: 6030:                    (void)expander{(reg_test(Types{}, Catch::NameAndTags{ Name " - " + std::string(tmpl_types[index]), Tags } ), index++)... };/* NOLINT */ \
        -: 6031:                }\
        -: 6032:            };\
        -: 6033:            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
        -: 6034:            TestName<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\
        -: 6035:            return 0;\
        -: 6036:        }();\
        -: 6037:        }\
        -: 6038:        }\
        -: 6039:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 6040:        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))
        -: 6041:
        -: 6042:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6043:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \
        -: 6044:        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )
        -: 6045:#else
        -: 6046:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \
        -: 6047:        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )
        -: 6048:#endif
        -: 6049:
        -: 6050:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6051:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \
        -: 6052:        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )
        -: 6053:#else
        -: 6054:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \
        -: 6055:        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )
        -: 6056:#endif
        -: 6057:
        -: 6058:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \
        -: 6059:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                      \
        -: 6060:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \
        -: 6061:        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS                \
        -: 6062:        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS       \
        -: 6063:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -: 6064:        template<typename TestType> static void TestFuncName();       \
        -: 6065:        namespace {\
        -: 6066:        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                     \
        -: 6067:            INTERNAL_CATCH_TYPE_GEN                                                  \
        -: 6068:            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))         \
        -: 6069:            template<typename... Types>                               \
        -: 6070:            struct TestName {                                         \
        -: 6071:                void reg_tests() {                                          \
        -: 6072:                    int index = 0;                                    \
        -: 6073:                    using expander = int[];                           \
        -: 6074:                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\
        -: 6075:                    constexpr char const* types_list[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))};\
        -: 6076:                    constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\
        -: 6077:                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFuncName<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name " - " + std::string(tmpl_types[index / num_types]) + "<" + std::string(types_list[index % num_types]) + ">", Tags } ), index++)... };/* NOLINT */\
        -: 6078:                }                                                     \
        -: 6079:            };                                                        \
        -: 6080:            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \
        -: 6081:                using TestInit = typename create<TestName, decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>()), TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>>::type; \
        -: 6082:                TestInit t;                                           \
        -: 6083:                t.reg_tests();                                        \
        -: 6084:                return 0;                                             \
        -: 6085:            }();                                                      \
        -: 6086:        }                                                             \
        -: 6087:        }                                                             \
        -: 6088:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \
        -: 6089:        template<typename TestType>                                   \
        -: 6090:        static void TestFuncName()
        -: 6091:
        -: 6092:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6093:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\
        -: 6094:        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T,__VA_ARGS__)
        -: 6095:#else
        -: 6096:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\
        -: 6097:        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T, __VA_ARGS__ ) )
        -: 6098:#endif
        -: 6099:
        -: 6100:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6101:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\
        -: 6102:        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__)
        -: 6103:#else
        -: 6104:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\
        -: 6105:        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )
        -: 6106:#endif
        -: 6107:
        -: 6108:    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2(TestName, TestFunc, Name, Tags, TmplList)\
        -: 6109:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 6110:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 6111:        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
        -: 6112:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -: 6113:        template<typename TestType> static void TestFunc();       \
        -: 6114:        namespace {\
        -: 6115:        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\
        -: 6116:        INTERNAL_CATCH_TYPE_GEN\
        -: 6117:        template<typename... Types>                               \
        -: 6118:        struct TestName {                                         \
        -: 6119:            void reg_tests() {                                          \
        -: 6120:                int index = 0;                                    \
        -: 6121:                using expander = int[];                           \
        -: 6122:                (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFunc<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name " - " + std::string(INTERNAL_CATCH_STRINGIZE(TmplList)) + " - " + std::to_string(index), Tags } ), index++)... };/* NOLINT */\
        -: 6123:            }                                                     \
        -: 6124:        };\
        -: 6125:        static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \
        -: 6126:                using TestInit = typename convert<TestName, TmplList>::type; \
        -: 6127:                TestInit t;                                           \
        -: 6128:                t.reg_tests();                                        \
        -: 6129:                return 0;                                             \
        -: 6130:            }();                                                      \
        -: 6131:        }}\
        -: 6132:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \
        -: 6133:        template<typename TestType>                                   \
        -: 6134:        static void TestFunc()
        -: 6135:
        -: 6136:    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(Name, Tags, TmplList) \
        -: 6137:        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, TmplList )
        -: 6138:
        -: 6139:
        -: 6140:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \
        -: 6141:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 6142:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 6143:        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
        -: 6144:        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
        -: 6145:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -: 6146:        namespace {\
        -: 6147:        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \
        -: 6148:            INTERNAL_CATCH_TYPE_GEN\
        -: 6149:            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\
        -: 6150:            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\
        -: 6151:            INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\
        -: 6152:            template<typename...Types> \
        -: 6153:            struct TestNameClass{\
        -: 6154:                TestNameClass(){\
        -: 6155:                    int index = 0;                                    \
        -: 6156:                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\
        -: 6157:                    using expander = int[];\
        -: 6158:                    (void)expander{(reg_test(Types{}, #ClassName, Catch::NameAndTags{ Name " - " + std::string(tmpl_types[index]), Tags } ), index++)... };/* NOLINT */ \
        -: 6159:                }\
        -: 6160:            };\
        -: 6161:            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
        -: 6162:                TestNameClass<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\
        -: 6163:                return 0;\
        -: 6164:        }();\
        -: 6165:        }\
        -: 6166:        }\
        -: 6167:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 6168:        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))
        -: 6169:
        -: 6170:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6171:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \
        -: 6172:        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )
        -: 6173:#else
        -: 6174:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \
        -: 6175:        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )
        -: 6176:#endif
        -: 6177:
        -: 6178:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6179:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \
        -: 6180:        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )
        -: 6181:#else
        -: 6182:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \
        -: 6183:        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )
        -: 6184:#endif
        -: 6185:
        -: 6186:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\
        -: 6187:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 6188:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 6189:        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
        -: 6190:        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
        -: 6191:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -: 6192:        template<typename TestType> \
        -: 6193:            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \
        -: 6194:                void test();\
        -: 6195:            };\
        -: 6196:        namespace {\
        -: 6197:        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestNameClass) {\
        -: 6198:            INTERNAL_CATCH_TYPE_GEN                  \
        -: 6199:            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\
        -: 6200:            template<typename...Types>\
        -: 6201:            struct TestNameClass{\
        -: 6202:                void reg_tests(){\
        -: 6203:                    int index = 0;\
        -: 6204:                    using expander = int[];\
        -: 6205:                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\
        -: 6206:                    constexpr char const* types_list[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))};\
        -: 6207:                    constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\
        -: 6208:                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name " - " + std::string(tmpl_types[index / num_types]) + "<" + std::string(types_list[index % num_types]) + ">", Tags } ), index++)... };/* NOLINT */ \
        -: 6209:                }\
        -: 6210:            };\
        -: 6211:            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
        -: 6212:                using TestInit = typename create<TestNameClass, decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>()), TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>>::type;\
        -: 6213:                TestInit t;\
        -: 6214:                t.reg_tests();\
        -: 6215:                return 0;\
        -: 6216:            }(); \
        -: 6217:        }\
        -: 6218:        }\
        -: 6219:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 6220:        template<typename TestType> \
        -: 6221:        void TestName<TestType>::test()
        -: 6222:
        -: 6223:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6224:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\
        -: 6225:        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T, __VA_ARGS__ )
        -: 6226:#else
        -: 6227:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\
        -: 6228:        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T,__VA_ARGS__ ) )
        -: 6229:#endif
        -: 6230:
        -: 6231:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6232:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\
        -: 6233:        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature, __VA_ARGS__ )
        -: 6234:#else
        -: 6235:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\
        -: 6236:        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )
        -: 6237:#endif
        -: 6238:
        -: 6239:    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, TmplList) \
        -: 6240:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 6241:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 6242:        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
        -: 6243:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -: 6244:        template<typename TestType> \
        -: 6245:        struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \
        -: 6246:            void test();\
        -: 6247:        };\
        -: 6248:        namespace {\
        -: 6249:        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \
        -: 6250:            INTERNAL_CATCH_TYPE_GEN\
        -: 6251:            template<typename...Types>\
        -: 6252:            struct TestNameClass{\
        -: 6253:                void reg_tests(){\
        -: 6254:                    int index = 0;\
        -: 6255:                    using expander = int[];\
        -: 6256:                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name " - " + std::string(INTERNAL_CATCH_STRINGIZE(TmplList)) + " - " + std::to_string(index), Tags } ), index++)... };/* NOLINT */ \
        -: 6257:                }\
        -: 6258:            };\
        -: 6259:            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
        -: 6260:                using TestInit = typename convert<TestNameClass, TmplList>::type;\
        -: 6261:                TestInit t;\
        -: 6262:                t.reg_tests();\
        -: 6263:                return 0;\
        -: 6264:            }(); \
        -: 6265:        }}\
        -: 6266:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 6267:        template<typename TestType> \
        -: 6268:        void TestName<TestType>::test()
        -: 6269:
        -: 6270:#define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD(ClassName, Name, Tags, TmplList) \
        -: 6271:        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, TmplList )
        -: 6272:
        -: 6273:
        -: 6274:#endif // CATCH_TEMPLATE_TEST_REGISTRY_HPP_INCLUDED
        -: 6275:
        -: 6276:
        -: 6277:#if defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)
        -: 6278:
        -: 6279:  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6280:    #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
        -: 6281:    #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )
        -: 6282:    #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6283:    #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
        -: 6284:    #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )
        -: 6285:    #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )
        -: 6286:    #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6287:    #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
        -: 6288:    #define CATCH_TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)
        -: 6289:    #define CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6290:  #else
        -: 6291:    #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )
        -: 6292:    #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )
        -: 6293:    #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
        -: 6294:    #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
        -: 6295:    #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )
        -: 6296:    #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )
        -: 6297:    #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
        -: 6298:    #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
        -: 6299:    #define CATCH_TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( __VA_ARGS__ ) )
        -: 6300:    #define CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
        -: 6301:  #endif
        -: 6302:
        -: 6303:#elif defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)
        -: 6304:
        -: 6305:  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6306:    #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)
        -: 6307:    #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)
        -: 6308:    #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)
        -: 6309:    #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )
        -: 6310:  #else
        -: 6311:    #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )
        -: 6312:    #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )
        -: 6313:    #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )
        -: 6314:    #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )
        -: 6315:  #endif
        -: 6316:
        -: 6317:  // When disabled, these can be shared between proper preprocessor and MSVC preprocessor
        -: 6318:  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
        -: 6319:  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
        -: 6320:  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6321:  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6322:  #define CATCH_TEMPLATE_LIST_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE(__VA_ARGS__)
        -: 6323:  #define CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6324:
        -: 6325:#elif !defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)
        -: 6326:
        -: 6327:  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6328:    #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
        -: 6329:    #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )
        -: 6330:    #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6331:    #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
        -: 6332:    #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )
        -: 6333:    #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )
        -: 6334:    #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6335:    #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
        -: 6336:    #define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)
        -: 6337:    #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6338:  #else
        -: 6339:    #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )
        -: 6340:    #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )
        -: 6341:    #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
        -: 6342:    #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
        -: 6343:    #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )
        -: 6344:    #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )
        -: 6345:    #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
        -: 6346:    #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
        -: 6347:    #define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( __VA_ARGS__ ) )
        -: 6348:    #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
        -: 6349:  #endif
        -: 6350:
        -: 6351:#elif !defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)
        -: 6352:
        -: 6353:  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6354:    #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)
        -: 6355:    #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)
        -: 6356:    #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)
        -: 6357:    #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )
        -: 6358:  #else
        -: 6359:    #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )
        -: 6360:    #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )
        -: 6361:    #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )
        -: 6362:    #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )
        -: 6363:  #endif
        -: 6364:
        -: 6365:  // When disabled, these can be shared between proper preprocessor and MSVC preprocessor
        -: 6366:  #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
        -: 6367:  #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
        -: 6368:  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6369:  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6370:  #define TEMPLATE_LIST_TEST_CASE( ... ) TEMPLATE_TEST_CASE(__VA_ARGS__)
        -: 6371:  #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6372:
        -: 6373:#endif // end of user facing macro declarations
        -: 6374:
        -: 6375:
        -: 6376:#endif // CATCH_TEMPLATE_TEST_MACROS_HPP_INCLUDED
        -: 6377:
        -: 6378:
        -: 6379:#ifndef CATCH_TEST_CASE_INFO_HPP_INCLUDED
        -: 6380:#define CATCH_TEST_CASE_INFO_HPP_INCLUDED
        -: 6381:
        -: 6382:
        -: 6383:
        -: 6384:#include <string>
        -: 6385:#include <vector>
        -: 6386:
        -: 6387:#ifdef __clang__
        -: 6388:#pragma clang diagnostic push
        -: 6389:#pragma clang diagnostic ignored "-Wpadded"
        -: 6390:#endif
        -: 6391:
        -: 6392:namespace Catch {
        -: 6393:
        -: 6394:    struct Tag {
        -: 6395:        Tag(StringRef original_, StringRef lowerCased_):
        1: 6396:            original(original_), lowerCased(lowerCased_)
        -: 6397:        {}
        -: 6398:        StringRef original, lowerCased;
        -: 6399:    };
        -: 6400:
        -: 6401:    struct ITestInvoker;
        -: 6402:
        -: 6403:    enum class TestCaseProperties : uint8_t {
        -: 6404:        None = 0,
        -: 6405:        IsHidden = 1 << 1,
        -: 6406:        ShouldFail = 1 << 2,
        -: 6407:        MayFail = 1 << 3,
        -: 6408:        Throws = 1 << 4,
        -: 6409:        NonPortable = 1 << 5,
        -: 6410:        Benchmark = 1 << 6
        -: 6411:    };
        -: 6412:
        -: 6413:
        2: 6414:    struct TestCaseInfo : Detail::NonCopyable {
        -: 6415:
        -: 6416:        TestCaseInfo(std::string const& _className,
        -: 6417:                     NameAndTags const& _tags,
        -: 6418:                     SourceLineInfo const& _lineInfo);
        -: 6419:
        -: 6420:        bool isHidden() const;
        -: 6421:        bool throws() const;
        -: 6422:        bool okToFail() const;
        -: 6423:        bool expectedToFail() const;
        -: 6424:
        -: 6425:        // Adds the tag(s) with test's filename (for the -# flag)
        -: 6426:        void addFilenameTag();
        -: 6427:
        -: 6428:
        -: 6429:        std::string tagsAsString() const;
        -: 6430:
        -: 6431:        std::string name;
        -: 6432:        std::string className;
        -: 6433:    private:
        -: 6434:        std::string backingTags, backingLCaseTags;
        -: 6435:        // Internally we copy tags to the backing storage and then add
        -: 6436:        // refs to this storage to the tags vector.
        -: 6437:        void internalAppendTag(StringRef tagString);
        -: 6438:    public:
        -: 6439:        std::vector<Tag> tags;
        -: 6440:        SourceLineInfo lineInfo;
        -: 6441:        TestCaseProperties properties = TestCaseProperties::None;
        -: 6442:    };
        -: 6443:
        -: 6444:    class TestCaseHandle {
        -: 6445:        TestCaseInfo* m_info;
        -: 6446:        ITestInvoker* m_invoker;
        -: 6447:    public:
        -: 6448:        TestCaseHandle(TestCaseInfo* info, ITestInvoker* invoker) :
        1: 6449:            m_info(info), m_invoker(invoker) {}
        -: 6450:
        -: 6451:        void invoke() const {
        1: 6452:            m_invoker->invoke();
        -: 6453:        }
        -: 6454:
        -: 6455:        TestCaseInfo const& getTestCaseInfo() const;
        -: 6456:
        -: 6457:        bool operator== ( TestCaseHandle const& rhs ) const;
        -: 6458:        bool operator < ( TestCaseHandle const& rhs ) const;
        -: 6459:    };
        -: 6460:
        -: 6461:    Detail::unique_ptr<TestCaseInfo> makeTestCaseInfo(  std::string const& className,
        -: 6462:                            NameAndTags const& nameAndTags,
        -: 6463:                            SourceLineInfo const& lineInfo );
        -: 6464:}
        -: 6465:
        -: 6466:#ifdef __clang__
        -: 6467:#pragma clang diagnostic pop
        -: 6468:#endif
        -: 6469:
        -: 6470:#endif // CATCH_TEST_CASE_INFO_HPP_INCLUDED
        -: 6471:
        -: 6472:
        -: 6473:#ifndef CATCH_TRANSLATE_EXCEPTION_HPP_INCLUDED
        -: 6474:#define CATCH_TRANSLATE_EXCEPTION_HPP_INCLUDED
        -: 6475:
        -: 6476:
        -: 6477:
        -: 6478:#ifndef CATCH_INTERFACES_EXCEPTION_HPP_INCLUDED
        -: 6479:#define CATCH_INTERFACES_EXCEPTION_HPP_INCLUDED
        -: 6480:
        -: 6481:
        -: 6482:#include <string>
        -: 6483:#include <vector>
        -: 6484:
        -: 6485:namespace Catch {
        -: 6486:    using exceptionTranslateFunction = std::string(*)();
        -: 6487:
        -: 6488:    struct IExceptionTranslator;
        -: 6489:    using ExceptionTranslators = std::vector<Detail::unique_ptr<IExceptionTranslator const>>;
        -: 6490:
    #####: 6491:    struct IExceptionTranslator {
        -: 6492:        virtual ~IExceptionTranslator();
        -: 6493:        virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const = 0;
        -: 6494:    };
        -: 6495:
        2: 6496:    struct IExceptionTranslatorRegistry {
        -: 6497:        virtual ~IExceptionTranslatorRegistry();
        -: 6498:
        -: 6499:        virtual std::string translateActiveException() const = 0;
        -: 6500:    };
        -: 6501:
        -: 6502:} // namespace Catch
        -: 6503:
        -: 6504:#endif // CATCH_INTERFACES_EXCEPTION_HPP_INCLUDED
        -: 6505:
        -: 6506:#include <exception>
        -: 6507:
        -: 6508:namespace Catch {
        -: 6509:
        -: 6510:    class ExceptionTranslatorRegistrar {
        -: 6511:        template<typename T>
        -: 6512:        class ExceptionTranslator : public IExceptionTranslator {
        -: 6513:        public:
        -: 6514:
        -: 6515:            ExceptionTranslator( std::string(*translateFunction)( T const& ) )
        -: 6516:            : m_translateFunction( translateFunction )
        -: 6517:            {}
        -: 6518:
        -: 6519:            std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const override {
        -: 6520:#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
        -: 6521:                try {
        -: 6522:                    if( it == itEnd )
        -: 6523:                        std::rethrow_exception(std::current_exception());
        -: 6524:                    else
        -: 6525:                        return (*it)->translate( it+1, itEnd );
        -: 6526:                }
        -: 6527:                catch( T const& ex ) {
        -: 6528:                    return m_translateFunction( ex );
        -: 6529:                }
        -: 6530:#else
        -: 6531:                return "You should never get here!";
        -: 6532:#endif
        -: 6533:            }
        -: 6534:
        -: 6535:        protected:
        -: 6536:            std::string(*m_translateFunction)( T const& );
        -: 6537:        };
        -: 6538:
        -: 6539:    public:
        -: 6540:        template<typename T>
        -: 6541:        ExceptionTranslatorRegistrar( std::string(*translateFunction)( T const& ) ) {
        -: 6542:            getMutableRegistryHub().registerTranslator
        -: 6543:                ( new ExceptionTranslator<T>( translateFunction ) );
        -: 6544:        }
        -: 6545:    };
        -: 6546:
        -: 6547:} // namespace Catch
        -: 6548:
        -: 6549:///////////////////////////////////////////////////////////////////////////////
        -: 6550:#define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \
        -: 6551:    static std::string translatorName( signature ); \
        -: 6552:    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 6553:    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 6554:    namespace{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &translatorName ); } \
        -: 6555:    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 6556:    static std::string translatorName( signature )
        -: 6557:
        -: 6558:#define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
        -: 6559:
        -: 6560:#if defined(CATCH_CONFIG_DISABLE)
        -: 6561:    #define INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( translatorName, signature) \
        -: 6562:            static std::string translatorName( signature )
        -: 6563:#endif
        -: 6564:
        -: 6565:
        -: 6566:// This macro is always prefixed
        -: 6567:#if !defined(CATCH_CONFIG_DISABLE)
        -: 6568:#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )
        -: 6569:#else
        -: 6570:#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
        -: 6571:#endif
        -: 6572:
        -: 6573:
        -: 6574:#endif // CATCH_TRANSLATE_EXCEPTION_HPP_INCLUDED
        -: 6575:
        -: 6576:#ifndef CATCH_VERSION_HPP_INCLUDED
        -: 6577:#define CATCH_VERSION_HPP_INCLUDED
        -: 6578:
        -: 6579:#include <iosfwd>
        -: 6580:
        -: 6581:namespace Catch {
        -: 6582:
        -: 6583:    // Versioning information
        -: 6584:    struct Version {
        -: 6585:        Version( Version const& ) = delete;
        -: 6586:        Version& operator=( Version const& ) = delete;
        -: 6587:        Version(    unsigned int _majorVersion,
        -: 6588:                    unsigned int _minorVersion,
        -: 6589:                    unsigned int _patchNumber,
        -: 6590:                    char const * const _branchName,
        -: 6591:                    unsigned int _buildNumber );
        -: 6592:
        -: 6593:        unsigned int const majorVersion;
        -: 6594:        unsigned int const minorVersion;
        -: 6595:        unsigned int const patchNumber;
        -: 6596:
        -: 6597:        // buildNumber is only used if branchName is not null
        -: 6598:        char const * const branchName;
        -: 6599:        unsigned int const buildNumber;
        -: 6600:
        -: 6601:        friend std::ostream& operator << ( std::ostream& os, Version const& version );
        -: 6602:    };
        -: 6603:
        -: 6604:    Version const& libraryVersion();
        -: 6605:}
        -: 6606:
        -: 6607:#endif // CATCH_VERSION_HPP_INCLUDED
        -: 6608:
        -: 6609:
        -: 6610:#ifndef CATCH_VERSION_MACROS_HPP_INCLUDED
        -: 6611:#define CATCH_VERSION_MACROS_HPP_INCLUDED
        -: 6612:
        -: 6613:#define CATCH_VERSION_MAJOR 3
        -: 6614:#define CATCH_VERSION_MINOR 0
        -: 6615:#define CATCH_VERSION_PATCH 0
        -: 6616:
        -: 6617:#endif // CATCH_VERSION_MACROS_HPP_INCLUDED
        -: 6618:
        -: 6619:
        -: 6620:/** \file
        -: 6621: * This is a convenience header for Catch2's Generator support. It includes
        -: 6622: * **all** of Catch2 headers related to generators.
        -: 6623: *
        -: 6624: * Generally the Catch2 users should use specific includes they need,
        -: 6625: * but this header can be used instead for ease-of-experimentation, or
        -: 6626: * just plain convenience, at the cost of (significantly) increased
        -: 6627: * compilation times.
        -: 6628: *
        -: 6629: * When a new header is added to either the `generators` folder,
        -: 6630: * or to the corresponding internal subfolder, it should be added here.
        -: 6631: */
        -: 6632:
        -: 6633:#ifndef CATCH_GENERATORS_ALL_HPP_INCLUDED
        -: 6634:#define CATCH_GENERATORS_ALL_HPP_INCLUDED
        -: 6635:
        -: 6636:
        -: 6637:
        -: 6638:#ifndef CATCH_GENERATOR_EXCEPTION_HPP_INCLUDED
        -: 6639:#define CATCH_GENERATOR_EXCEPTION_HPP_INCLUDED
        -: 6640:
        -: 6641:#include <exception>
        -: 6642:
        -: 6643:namespace Catch {
        -: 6644:
        -: 6645:    // Exception type to be thrown when a Generator runs into an error,
        -: 6646:    // e.g. it cannot initialize the first return value based on
        -: 6647:    // runtime information
    #####: 6648:    class GeneratorException : public std::exception {
        -: 6649:        const char* const m_msg = "";
        -: 6650:
        -: 6651:    public:
        -: 6652:        GeneratorException(const char* msg):
    #####: 6653:            m_msg(msg)
        -: 6654:        {}
        -: 6655:
        -: 6656:        const char* what() const noexcept override final;
        -: 6657:    };
        -: 6658:
        -: 6659:} // end namespace Catch
        -: 6660:
        -: 6661:#endif // CATCH_GENERATOR_EXCEPTION_HPP_INCLUDED
        -: 6662:
        -: 6663:
        -: 6664:#ifndef CATCH_GENERATORS_HPP_INCLUDED
        -: 6665:#define CATCH_GENERATORS_HPP_INCLUDED
        -: 6666:
        -: 6667:
        -: 6668:
        -: 6669:#ifndef CATCH_INTERFACES_GENERATORTRACKER_HPP_INCLUDED
        -: 6670:#define CATCH_INTERFACES_GENERATORTRACKER_HPP_INCLUDED
        -: 6671:
        -: 6672:
        -: 6673:namespace Catch {
        -: 6674:
        -: 6675:    namespace Generators {
    #####: 6676:        class GeneratorUntypedBase {
        -: 6677:        public:
        -: 6678:            GeneratorUntypedBase() = default;
        -: 6679:            // Generation of copy ops is deprecated (and Clang will complain)
        -: 6680:            // if there is a user destructor defined
        -: 6681:            GeneratorUntypedBase(GeneratorUntypedBase const&) = default;
        -: 6682:            GeneratorUntypedBase& operator=(GeneratorUntypedBase const&) = default;
        -: 6683:
        -: 6684:            virtual ~GeneratorUntypedBase(); // = default;
        -: 6685:
        -: 6686:            // Attempts to move the generator to the next element
        -: 6687:            //
        -: 6688:            // Returns true iff the move succeeded (and a valid element
        -: 6689:            // can be retrieved).
        -: 6690:            virtual bool next() = 0;
        -: 6691:        };
        -: 6692:        using GeneratorBasePtr = Catch::Detail::unique_ptr<GeneratorUntypedBase>;
        -: 6693:
        -: 6694:    } // namespace Generators
        -: 6695:
    #####: 6696:    struct IGeneratorTracker {
        -: 6697:        virtual ~IGeneratorTracker(); // = default;
        -: 6698:        virtual auto hasGenerator() const -> bool = 0;
        -: 6699:        virtual auto getGenerator() const -> Generators::GeneratorBasePtr const& = 0;
        -: 6700:        virtual void setGenerator( Generators::GeneratorBasePtr&& generator ) = 0;
        -: 6701:    };
        -: 6702:
        -: 6703:} // namespace Catch
        -: 6704:
        -: 6705:#endif // CATCH_INTERFACES_GENERATORTRACKER_HPP_INCLUDED
        -: 6706:
        -: 6707:#include <vector>
        -: 6708:#include <tuple>
        -: 6709:#include <utility>
        -: 6710:
        -: 6711:namespace Catch {
        -: 6712:
        -: 6713:namespace Generators {
        -: 6714:
        -: 6715:namespace Detail {
        -: 6716:
        -: 6717:    //! Throws GeneratorException with the provided message
        -: 6718:    [[noreturn]]
        -: 6719:    void throw_generator_exception(char const * msg);
        -: 6720:
        -: 6721:} // end namespace detail
        -: 6722:
        -: 6723:    template<typename T>
        -: 6724:    struct IGenerator : GeneratorUntypedBase {
        -: 6725:        ~IGenerator() override = default;
        -: 6726:        IGenerator() = default;
        -: 6727:        IGenerator(IGenerator const&) = default;
        -: 6728:        IGenerator& operator=(IGenerator const&) = default;
        -: 6729:
        -: 6730:
        -: 6731:        // Returns the current element of the generator
        -: 6732:        //
        -: 6733:        // \Precondition The generator is either freshly constructed,
        -: 6734:        // or the last call to `next()` returned true
        -: 6735:        virtual T const& get() const = 0;
        -: 6736:        using type = T;
        -: 6737:    };
        -: 6738:
        -: 6739:    template <typename T>
        -: 6740:    using GeneratorPtr = Catch::Detail::unique_ptr<IGenerator<T>>;
        -: 6741:
        -: 6742:    template <typename T>
        -: 6743:    class GeneratorWrapper final {
        -: 6744:        GeneratorPtr<T> m_generator;
        -: 6745:    public:
        -: 6746:        //! Takes ownership of the passed pointer.
        -: 6747:        GeneratorWrapper(IGenerator<T>* generator):
        -: 6748:            m_generator(generator) {}
        -: 6749:        GeneratorWrapper(GeneratorPtr<T> generator):
        -: 6750:            m_generator(std::move(generator)) {}
        -: 6751:
        -: 6752:        T const& get() const {
        -: 6753:            return m_generator->get();
        -: 6754:        }
        -: 6755:        bool next() {
        -: 6756:            return m_generator->next();
        -: 6757:        }
        -: 6758:    };
        -: 6759:
        -: 6760:
        -: 6761:    template<typename T>
        -: 6762:    class SingleValueGenerator final : public IGenerator<T> {
        -: 6763:        T m_value;
        -: 6764:    public:
        -: 6765:        SingleValueGenerator(T&& value):
        -: 6766:            m_value(std::forward<T>(value))
        -: 6767:        {}
        -: 6768:
        -: 6769:        T const& get() const override {
        -: 6770:            return m_value;
        -: 6771:        }
        -: 6772:        bool next() override {
        -: 6773:            return false;
        -: 6774:        }
        -: 6775:    };
        -: 6776:
        -: 6777:    template<typename T>
        -: 6778:    class FixedValuesGenerator final : public IGenerator<T> {
        -: 6779:        static_assert(!std::is_same<T, bool>::value,
        -: 6780:            "FixedValuesGenerator does not support bools because of std::vector<bool>"
        -: 6781:            "specialization, use SingleValue Generator instead.");
        -: 6782:        std::vector<T> m_values;
        -: 6783:        size_t m_idx = 0;
        -: 6784:    public:
        -: 6785:        FixedValuesGenerator( std::initializer_list<T> values ) : m_values( values ) {}
        -: 6786:
        -: 6787:        T const& get() const override {
        -: 6788:            return m_values[m_idx];
        -: 6789:        }
        -: 6790:        bool next() override {
        -: 6791:            ++m_idx;
        -: 6792:            return m_idx < m_values.size();
        -: 6793:        }
        -: 6794:    };
        -: 6795:
        -: 6796:    template <typename T>
        -: 6797:    GeneratorWrapper<T> value(T&& value) {
        -: 6798:        return GeneratorWrapper<T>(Catch::Detail::make_unique<SingleValueGenerator<T>>(std::forward<T>(value)));
        -: 6799:    }
        -: 6800:    template <typename T>
        -: 6801:    GeneratorWrapper<T> values(std::initializer_list<T> values) {
        -: 6802:        return GeneratorWrapper<T>(Catch::Detail::make_unique<FixedValuesGenerator<T>>(values));
        -: 6803:    }
        -: 6804:
        -: 6805:    template<typename T>
        -: 6806:    class Generators : public IGenerator<T> {
        -: 6807:        std::vector<GeneratorWrapper<T>> m_generators;
        -: 6808:        size_t m_current = 0;
        -: 6809:
        -: 6810:        void populate(GeneratorWrapper<T>&& generator) {
        -: 6811:            m_generators.emplace_back(std::move(generator));
        -: 6812:        }
        -: 6813:        void populate(T&& val) {
        -: 6814:            m_generators.emplace_back(value(std::forward<T>(val)));
        -: 6815:        }
        -: 6816:        template<typename U>
        -: 6817:        void populate(U&& val) {
        -: 6818:            populate(T(std::forward<U>(val)));
        -: 6819:        }
        -: 6820:        template<typename U, typename... Gs>
        -: 6821:        void populate(U&& valueOrGenerator, Gs &&... moreGenerators) {
        -: 6822:            populate(std::forward<U>(valueOrGenerator));
        -: 6823:            populate(std::forward<Gs>(moreGenerators)...);
        -: 6824:        }
        -: 6825:
        -: 6826:    public:
        -: 6827:        template <typename... Gs>
        -: 6828:        Generators(Gs &&... moreGenerators) {
        -: 6829:            m_generators.reserve(sizeof...(Gs));
        -: 6830:            populate(std::forward<Gs>(moreGenerators)...);
        -: 6831:        }
        -: 6832:
        -: 6833:        T const& get() const override {
        -: 6834:            return m_generators[m_current].get();
        -: 6835:        }
        -: 6836:
        -: 6837:        bool next() override {
        -: 6838:            if (m_current >= m_generators.size()) {
        -: 6839:                return false;
        -: 6840:            }
        -: 6841:            const bool current_status = m_generators[m_current].next();
        -: 6842:            if (!current_status) {
        -: 6843:                ++m_current;
        -: 6844:            }
        -: 6845:            return m_current < m_generators.size();
        -: 6846:        }
        -: 6847:    };
        -: 6848:
        -: 6849:
        -: 6850:    template<typename... Ts>
        -: 6851:    GeneratorWrapper<std::tuple<Ts...>> table( std::initializer_list<std::tuple<std::decay_t<Ts>...>> tuples ) {
        -: 6852:        return values<std::tuple<Ts...>>( tuples );
        -: 6853:    }
        -: 6854:
        -: 6855:    // Tag type to signal that a generator sequence should convert arguments to a specific type
        -: 6856:    template <typename T>
        -: 6857:    struct as {};
        -: 6858:
        -: 6859:    template<typename T, typename... Gs>
        -: 6860:    auto makeGenerators( GeneratorWrapper<T>&& generator, Gs &&... moreGenerators ) -> Generators<T> {
        -: 6861:        return Generators<T>(std::move(generator), std::forward<Gs>(moreGenerators)...);
        -: 6862:    }
        -: 6863:    template<typename T>
        -: 6864:    auto makeGenerators( GeneratorWrapper<T>&& generator ) -> Generators<T> {
        -: 6865:        return Generators<T>(std::move(generator));
        -: 6866:    }
        -: 6867:    template<typename T, typename... Gs>
        -: 6868:    auto makeGenerators( T&& val, Gs &&... moreGenerators ) -> Generators<T> {
        -: 6869:        return makeGenerators( value( std::forward<T>( val ) ), std::forward<Gs>( moreGenerators )... );
        -: 6870:    }
        -: 6871:    template<typename T, typename U, typename... Gs>
        -: 6872:    auto makeGenerators( as<T>, U&& val, Gs &&... moreGenerators ) -> Generators<T> {
        -: 6873:        return makeGenerators( value( T( std::forward<U>( val ) ) ), std::forward<Gs>( moreGenerators )... );
        -: 6874:    }
        -: 6875:
        -: 6876:    auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const& lineInfo ) -> IGeneratorTracker&;
        -: 6877:
        -: 6878:    template<typename L>
        -: 6879:    // Note: The type after -> is weird, because VS2015 cannot parse
        -: 6880:    //       the expression used in the typedef inside, when it is in
        -: 6881:    //       return type. Yeah.
        -: 6882:    auto generate( StringRef generatorName, SourceLineInfo const& lineInfo, L const& generatorExpression ) -> decltype(std::declval<decltype(generatorExpression())>().get()) {
        -: 6883:        using UnderlyingType = typename decltype(generatorExpression())::type;
        -: 6884:
        -: 6885:        IGeneratorTracker& tracker = acquireGeneratorTracker( generatorName, lineInfo );
        -: 6886:        if (!tracker.hasGenerator()) {
        -: 6887:            tracker.setGenerator(Catch::Detail::make_unique<Generators<UnderlyingType>>(generatorExpression()));
        -: 6888:        }
        -: 6889:
        -: 6890:        auto const& generator = static_cast<IGenerator<UnderlyingType> const&>( *tracker.getGenerator() );
        -: 6891:        return generator.get();
        -: 6892:    }
        -: 6893:
        -: 6894:} // namespace Generators
        -: 6895:} // namespace Catch
        -: 6896:
        -: 6897:#define GENERATE( ... ) \
        -: 6898:    Catch::Generators::generate( INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \
        -: 6899:                                 CATCH_INTERNAL_LINEINFO, \
        -: 6900:                                 [ ]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) //NOLINT(google-build-using-namespace)
        -: 6901:#define GENERATE_COPY( ... ) \
        -: 6902:    Catch::Generators::generate( INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \
        -: 6903:                                 CATCH_INTERNAL_LINEINFO, \
        -: 6904:                                 [=]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) //NOLINT(google-build-using-namespace)
        -: 6905:#define GENERATE_REF( ... ) \
        -: 6906:    Catch::Generators::generate( INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \
        -: 6907:                                 CATCH_INTERNAL_LINEINFO, \
        -: 6908:                                 [&]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) //NOLINT(google-build-using-namespace)
        -: 6909:
        -: 6910:#endif // CATCH_GENERATORS_HPP_INCLUDED
        -: 6911:
        -: 6912:
        -: 6913:#ifndef CATCH_GENERATORS_ADAPTERS_HPP_INCLUDED
        -: 6914:#define CATCH_GENERATORS_ADAPTERS_HPP_INCLUDED
        -: 6915:
        -: 6916:
        -: 6917:namespace Catch {
        -: 6918:namespace Generators {
        -: 6919:
        -: 6920:    template <typename T>
        -: 6921:    class TakeGenerator final : public IGenerator<T> {
        -: 6922:        GeneratorWrapper<T> m_generator;
        -: 6923:        size_t m_returned = 0;
        -: 6924:        size_t m_target;
        -: 6925:    public:
        -: 6926:        TakeGenerator(size_t target, GeneratorWrapper<T>&& generator):
        -: 6927:            m_generator(std::move(generator)),
        -: 6928:            m_target(target)
        -: 6929:        {
        -: 6930:            assert(target != 0 && "Empty generators are not allowed");
        -: 6931:        }
        -: 6932:        T const& get() const override {
        -: 6933:            return m_generator.get();
        -: 6934:        }
        -: 6935:        bool next() override {
        -: 6936:            ++m_returned;
        -: 6937:            if (m_returned >= m_target) {
        -: 6938:                return false;
        -: 6939:            }
        -: 6940:
        -: 6941:            const auto success = m_generator.next();
        -: 6942:            // If the underlying generator does not contain enough values
        -: 6943:            // then we cut short as well
        -: 6944:            if (!success) {
        -: 6945:                m_returned = m_target;
        -: 6946:            }
        -: 6947:            return success;
        -: 6948:        }
        -: 6949:    };
        -: 6950:
        -: 6951:    template <typename T>
        -: 6952:    GeneratorWrapper<T> take(size_t target, GeneratorWrapper<T>&& generator) {
        -: 6953:        return GeneratorWrapper<T>(Catch::Detail::make_unique<TakeGenerator<T>>(target, std::move(generator)));
        -: 6954:    }
        -: 6955:
        -: 6956:
        -: 6957:    template <typename T, typename Predicate>
        -: 6958:    class FilterGenerator final : public IGenerator<T> {
        -: 6959:        GeneratorWrapper<T> m_generator;
        -: 6960:        Predicate m_predicate;
        -: 6961:    public:
        -: 6962:        template <typename P = Predicate>
        -: 6963:        FilterGenerator(P&& pred, GeneratorWrapper<T>&& generator):
        -: 6964:            m_generator(std::move(generator)),
        -: 6965:            m_predicate(std::forward<P>(pred))
        -: 6966:        {
        -: 6967:            if (!m_predicate(m_generator.get())) {
        -: 6968:                // It might happen that there are no values that pass the
        -: 6969:                // filter. In that case we throw an exception.
        -: 6970:                auto has_initial_value = next();
        -: 6971:                if (!has_initial_value) {
        -: 6972:                    Detail::throw_generator_exception("No valid value found in filtered generator");
        -: 6973:                }
        -: 6974:            }
        -: 6975:        }
        -: 6976:
        -: 6977:        T const& get() const override {
        -: 6978:            return m_generator.get();
        -: 6979:        }
        -: 6980:
        -: 6981:        bool next() override {
        -: 6982:            bool success = m_generator.next();
        -: 6983:            if (!success) {
        -: 6984:                return false;
        -: 6985:            }
        -: 6986:            while (!m_predicate(m_generator.get()) && (success = m_generator.next()) == true);
        -: 6987:            return success;
        -: 6988:        }
        -: 6989:    };
        -: 6990:
        -: 6991:
        -: 6992:    template <typename T, typename Predicate>
        -: 6993:    GeneratorWrapper<T> filter(Predicate&& pred, GeneratorWrapper<T>&& generator) {
        -: 6994:        return GeneratorWrapper<T>(Catch::Detail::make_unique<FilterGenerator<T, Predicate>>(std::forward<Predicate>(pred), std::move(generator)));
        -: 6995:    }
        -: 6996:
        -: 6997:    template <typename T>
        -: 6998:    class RepeatGenerator final : public IGenerator<T> {
        -: 6999:        static_assert(!std::is_same<T, bool>::value,
        -: 7000:            "RepeatGenerator currently does not support bools"
        -: 7001:            "because of std::vector<bool> specialization");
        -: 7002:        GeneratorWrapper<T> m_generator;
        -: 7003:        mutable std::vector<T> m_returned;
        -: 7004:        size_t m_target_repeats;
        -: 7005:        size_t m_current_repeat = 0;
        -: 7006:        size_t m_repeat_index = 0;
        -: 7007:    public:
        -: 7008:        RepeatGenerator(size_t repeats, GeneratorWrapper<T>&& generator):
        -: 7009:            m_generator(std::move(generator)),
        -: 7010:            m_target_repeats(repeats)
        -: 7011:        {
        -: 7012:            assert(m_target_repeats > 0 && "Repeat generator must repeat at least once");
        -: 7013:        }
        -: 7014:
        -: 7015:        T const& get() const override {
        -: 7016:            if (m_current_repeat == 0) {
        -: 7017:                m_returned.push_back(m_generator.get());
        -: 7018:                return m_returned.back();
        -: 7019:            }
        -: 7020:            return m_returned[m_repeat_index];
        -: 7021:        }
        -: 7022:
        -: 7023:        bool next() override {
        -: 7024:            // There are 2 basic cases:
        -: 7025:            // 1) We are still reading the generator
        -: 7026:            // 2) We are reading our own cache
        -: 7027:
        -: 7028:            // In the first case, we need to poke the underlying generator.
        -: 7029:            // If it happily moves, we are left in that state, otherwise it is time to start reading from our cache
        -: 7030:            if (m_current_repeat == 0) {
        -: 7031:                const auto success = m_generator.next();
        -: 7032:                if (!success) {
        -: 7033:                    ++m_current_repeat;
        -: 7034:                }
        -: 7035:                return m_current_repeat < m_target_repeats;
        -: 7036:            }
        -: 7037:
        -: 7038:            // In the second case, we need to move indices forward and check that we haven't run up against the end
        -: 7039:            ++m_repeat_index;
        -: 7040:            if (m_repeat_index == m_returned.size()) {
        -: 7041:                m_repeat_index = 0;
        -: 7042:                ++m_current_repeat;
        -: 7043:            }
        -: 7044:            return m_current_repeat < m_target_repeats;
        -: 7045:        }
        -: 7046:    };
        -: 7047:
        -: 7048:    template <typename T>
        -: 7049:    GeneratorWrapper<T> repeat(size_t repeats, GeneratorWrapper<T>&& generator) {
        -: 7050:        return GeneratorWrapper<T>(Catch::Detail::make_unique<RepeatGenerator<T>>(repeats, std::move(generator)));
        -: 7051:    }
        -: 7052:
        -: 7053:    template <typename T, typename U, typename Func>
        -: 7054:    class MapGenerator final : public IGenerator<T> {
        -: 7055:        // TBD: provide static assert for mapping function, for friendly error message
        -: 7056:        GeneratorWrapper<U> m_generator;
        -: 7057:        Func m_function;
        -: 7058:        // To avoid returning dangling reference, we have to save the values
        -: 7059:        T m_cache;
        -: 7060:    public:
        -: 7061:        template <typename F2 = Func>
        -: 7062:        MapGenerator(F2&& function, GeneratorWrapper<U>&& generator) :
        -: 7063:            m_generator(std::move(generator)),
        -: 7064:            m_function(std::forward<F2>(function)),
        -: 7065:            m_cache(m_function(m_generator.get()))
        -: 7066:        {}
        -: 7067:
        -: 7068:        T const& get() const override {
        -: 7069:            return m_cache;
        -: 7070:        }
        -: 7071:        bool next() override {
        -: 7072:            const auto success = m_generator.next();
        -: 7073:            if (success) {
        -: 7074:                m_cache = m_function(m_generator.get());
        -: 7075:            }
        -: 7076:            return success;
        -: 7077:        }
        -: 7078:    };
        -: 7079:
        -: 7080:    template <typename Func, typename U, typename T = FunctionReturnType<Func, U>>
        -: 7081:    GeneratorWrapper<T> map(Func&& function, GeneratorWrapper<U>&& generator) {
        -: 7082:        return GeneratorWrapper<T>(
        -: 7083:            Catch::Detail::make_unique<MapGenerator<T, U, Func>>(std::forward<Func>(function), std::move(generator))
        -: 7084:        );
        -: 7085:    }
        -: 7086:
        -: 7087:    template <typename T, typename U, typename Func>
        -: 7088:    GeneratorWrapper<T> map(Func&& function, GeneratorWrapper<U>&& generator) {
        -: 7089:        return GeneratorWrapper<T>(
        -: 7090:            Catch::Detail::make_unique<MapGenerator<T, U, Func>>(std::forward<Func>(function), std::move(generator))
        -: 7091:        );
        -: 7092:    }
        -: 7093:
        -: 7094:    template <typename T>
        -: 7095:    class ChunkGenerator final : public IGenerator<std::vector<T>> {
        -: 7096:        std::vector<T> m_chunk;
        -: 7097:        size_t m_chunk_size;
        -: 7098:        GeneratorWrapper<T> m_generator;
        -: 7099:        bool m_used_up = false;
        -: 7100:    public:
        -: 7101:        ChunkGenerator(size_t size, GeneratorWrapper<T> generator) :
        -: 7102:            m_chunk_size(size), m_generator(std::move(generator))
        -: 7103:        {
        -: 7104:            m_chunk.reserve(m_chunk_size);
        -: 7105:            if (m_chunk_size != 0) {
        -: 7106:                m_chunk.push_back(m_generator.get());
        -: 7107:                for (size_t i = 1; i < m_chunk_size; ++i) {
        -: 7108:                    if (!m_generator.next()) {
        -: 7109:                        Detail::throw_generator_exception("Not enough values to initialize the first chunk");
        -: 7110:                    }
        -: 7111:                    m_chunk.push_back(m_generator.get());
        -: 7112:                }
        -: 7113:            }
        -: 7114:        }
        -: 7115:        std::vector<T> const& get() const override {
        -: 7116:            return m_chunk;
        -: 7117:        }
        -: 7118:        bool next() override {
        -: 7119:            m_chunk.clear();
        -: 7120:            for (size_t idx = 0; idx < m_chunk_size; ++idx) {
        -: 7121:                if (!m_generator.next()) {
        -: 7122:                    return false;
        -: 7123:                }
        -: 7124:                m_chunk.push_back(m_generator.get());
        -: 7125:            }
        -: 7126:            return true;
        -: 7127:        }
        -: 7128:    };
        -: 7129:
        -: 7130:    template <typename T>
        -: 7131:    GeneratorWrapper<std::vector<T>> chunk(size_t size, GeneratorWrapper<T>&& generator) {
        -: 7132:        return GeneratorWrapper<std::vector<T>>(
        -: 7133:            Catch::Detail::make_unique<ChunkGenerator<T>>(size, std::move(generator))
        -: 7134:        );
        -: 7135:    }
        -: 7136:
        -: 7137:} // namespace Generators
        -: 7138:} // namespace Catch
        -: 7139:
        -: 7140:
        -: 7141:#endif // CATCH_GENERATORS_ADAPTERS_HPP_INCLUDED
        -: 7142:
        -: 7143:
        -: 7144:#ifndef CATCH_GENERATORS_RANDOM_HPP_INCLUDED
        -: 7145:#define CATCH_GENERATORS_RANDOM_HPP_INCLUDED
        -: 7146:
        -: 7147:
        -: 7148:
        -: 7149:#ifndef CATCH_RANDOM_NUMBER_GENERATOR_HPP_INCLUDED
        -: 7150:#define CATCH_RANDOM_NUMBER_GENERATOR_HPP_INCLUDED
        -: 7151:
        -: 7152:#include <cstdint>
        -: 7153:
        -: 7154:namespace Catch {
        -: 7155:
        -: 7156:    // This is a simple implementation of C++11 Uniform Random Number
        -: 7157:    // Generator. It does not provide all operators, because Catch2
        -: 7158:    // does not use it, but it should behave as expected inside stdlib's
        -: 7159:    // distributions.
        -: 7160:    // The implementation is based on the PCG family (http://pcg-random.org)
        -: 7161:    class SimplePcg32 {
        -: 7162:        using state_type = std::uint64_t;
        -: 7163:    public:
        -: 7164:        using result_type = std::uint32_t;
        -: 7165:        static constexpr result_type (min)() {
        -: 7166:            return 0;
        -: 7167:        }
        -: 7168:        static constexpr result_type (max)() {
        -: 7169:            return static_cast<result_type>(-1);
        -: 7170:        }
        -: 7171:
        -: 7172:        // Provide some default initial state for the default constructor
        -: 7173:        SimplePcg32():SimplePcg32(0xed743cc4U) {}
        -: 7174:
        -: 7175:        explicit SimplePcg32(result_type seed_);
        -: 7176:
        -: 7177:        void seed(result_type seed_);
        -: 7178:        void discard(uint64_t skip);
        -: 7179:
        -: 7180:        result_type operator()();
        -: 7181:
        -: 7182:    private:
        -: 7183:        friend bool operator==(SimplePcg32 const& lhs, SimplePcg32 const& rhs);
        -: 7184:        friend bool operator!=(SimplePcg32 const& lhs, SimplePcg32 const& rhs);
        -: 7185:
        -: 7186:        // In theory we also need operator<< and operator>>
        -: 7187:        // In practice we do not use them, so we will skip them for now
        -: 7188:
        -: 7189:
        -: 7190:        std::uint64_t m_state;
        -: 7191:        // This part of the state determines which "stream" of the numbers
        -: 7192:        // is chosen -- we take it as a constant for Catch2, so we only
        -: 7193:        // need to deal with seeding the main state.
        -: 7194:        // Picked by reading 8 bytes from `/dev/random` :-)
        -: 7195:        static const std::uint64_t s_inc = (0x13ed0cc53f939476ULL << 1ULL) | 1ULL;
        -: 7196:    };
        -: 7197:
        -: 7198:} // end namespace Catch
        -: 7199:
        -: 7200:#endif // CATCH_RANDOM_NUMBER_GENERATOR_HPP_INCLUDED
        -: 7201:
        -: 7202:#include <random>
        -: 7203:
        -: 7204:namespace Catch {
        -: 7205:namespace Generators {
        -: 7206:
        -: 7207:template <typename Float>
        -: 7208:class RandomFloatingGenerator final : public IGenerator<Float> {
        -: 7209:    Catch::SimplePcg32& m_rng;
        -: 7210:    std::uniform_real_distribution<Float> m_dist;
        -: 7211:    Float m_current_number;
        -: 7212:public:
        -: 7213:
        -: 7214:    RandomFloatingGenerator(Float a, Float b):
        -: 7215:        m_rng(rng()),
        -: 7216:        m_dist(a, b) {
        -: 7217:        static_cast<void>(next());
        -: 7218:    }
        -: 7219:
        -: 7220:    Float const& get() const override {
        -: 7221:        return m_current_number;
        -: 7222:    }
        -: 7223:    bool next() override {
        -: 7224:        m_current_number = m_dist(m_rng);
        -: 7225:        return true;
        -: 7226:    }
        -: 7227:};
        -: 7228:
        -: 7229:template <typename Integer>
        -: 7230:class RandomIntegerGenerator final : public IGenerator<Integer> {
        -: 7231:    Catch::SimplePcg32& m_rng;
        -: 7232:    std::uniform_int_distribution<Integer> m_dist;
        -: 7233:    Integer m_current_number;
        -: 7234:public:
        -: 7235:
        -: 7236:    RandomIntegerGenerator(Integer a, Integer b):
        -: 7237:        m_rng(rng()),
        -: 7238:        m_dist(a, b) {
        -: 7239:        static_cast<void>(next());
        -: 7240:    }
        -: 7241:
        -: 7242:    Integer const& get() const override {
        -: 7243:        return m_current_number;
        -: 7244:    }
        -: 7245:    bool next() override {
        -: 7246:        m_current_number = m_dist(m_rng);
        -: 7247:        return true;
        -: 7248:    }
        -: 7249:};
        -: 7250:
        -: 7251:// TODO: Ideally this would be also constrained against the various char types,
        -: 7252://       but I don't expect users to run into that in practice.
        -: 7253:template <typename T>
        -: 7254:std::enable_if_t<std::is_integral<T>::value && !std::is_same<T, bool>::value,
        -: 7255:GeneratorWrapper<T>>
        -: 7256:random(T a, T b) {
        -: 7257:    return GeneratorWrapper<T>(
        -: 7258:        Catch::Detail::make_unique<RandomIntegerGenerator<T>>(a, b)
        -: 7259:    );
        -: 7260:}
        -: 7261:
        -: 7262:template <typename T>
        -: 7263:std::enable_if_t<std::is_floating_point<T>::value,
        -: 7264:GeneratorWrapper<T>>
        -: 7265:random(T a, T b) {
        -: 7266:    return GeneratorWrapper<T>(
        -: 7267:        Catch::Detail::make_unique<RandomFloatingGenerator<T>>(a, b)
        -: 7268:    );
        -: 7269:}
        -: 7270:
        -: 7271:
        -: 7272:} // namespace Generators
        -: 7273:} // namespace Catch
        -: 7274:
        -: 7275:
        -: 7276:#endif // CATCH_GENERATORS_RANDOM_HPP_INCLUDED
        -: 7277:
        -: 7278:
        -: 7279:#ifndef CATCH_GENERATORS_RANGE_HPP_INCLUDED
        -: 7280:#define CATCH_GENERATORS_RANGE_HPP_INCLUDED
        -: 7281:
        -: 7282:
        -: 7283:#include <iterator>
        -: 7284:#include <type_traits>
        -: 7285:
        -: 7286:namespace Catch {
        -: 7287:namespace Generators {
        -: 7288:
        -: 7289:
        -: 7290:template <typename T>
        -: 7291:class RangeGenerator final : public IGenerator<T> {
        -: 7292:    T m_current;
        -: 7293:    T m_end;
        -: 7294:    T m_step;
        -: 7295:    bool m_positive;
        -: 7296:
        -: 7297:public:
        -: 7298:    RangeGenerator(T const& start, T const& end, T const& step):
        -: 7299:        m_current(start),
        -: 7300:        m_end(end),
        -: 7301:        m_step(step),
        -: 7302:        m_positive(m_step > T(0))
        -: 7303:    {
        -: 7304:        assert(m_current != m_end && "Range start and end cannot be equal");
        -: 7305:        assert(m_step != T(0) && "Step size cannot be zero");
        -: 7306:        assert(((m_positive && m_current <= m_end) || (!m_positive && m_current >= m_end)) && "Step moves away from end");
        -: 7307:    }
        -: 7308:
        -: 7309:    RangeGenerator(T const& start, T const& end):
        -: 7310:        RangeGenerator(start, end, (start < end) ? T(1) : T(-1))
        -: 7311:    {}
        -: 7312:
        -: 7313:    T const& get() const override {
        -: 7314:        return m_current;
        -: 7315:    }
        -: 7316:
        -: 7317:    bool next() override {
        -: 7318:        m_current += m_step;
        -: 7319:        return (m_positive) ? (m_current < m_end) : (m_current > m_end);
        -: 7320:    }
        -: 7321:};
        -: 7322:
        -: 7323:template <typename T>
        -: 7324:GeneratorWrapper<T> range(T const& start, T const& end, T const& step) {
        -: 7325:    static_assert(std::is_arithmetic<T>::value && !std::is_same<T, bool>::value, "Type must be numeric");
        -: 7326:    return GeneratorWrapper<T>(Catch::Detail::make_unique<RangeGenerator<T>>(start, end, step));
        -: 7327:}
        -: 7328:
        -: 7329:template <typename T>
        -: 7330:GeneratorWrapper<T> range(T const& start, T const& end) {
        -: 7331:    static_assert(std::is_integral<T>::value && !std::is_same<T, bool>::value, "Type must be an integer");
        -: 7332:    return GeneratorWrapper<T>(Catch::Detail::make_unique<RangeGenerator<T>>(start, end));
        -: 7333:}
        -: 7334:
        -: 7335:
        -: 7336:template <typename T>
        -: 7337:class IteratorGenerator final : public IGenerator<T> {
        -: 7338:    static_assert(!std::is_same<T, bool>::value,
        -: 7339:        "IteratorGenerator currently does not support bools"
        -: 7340:        "because of std::vector<bool> specialization");
        -: 7341:
        -: 7342:    std::vector<T> m_elems;
        -: 7343:    size_t m_current = 0;
        -: 7344:public:
        -: 7345:    template <typename InputIterator, typename InputSentinel>
        -: 7346:    IteratorGenerator(InputIterator first, InputSentinel last):m_elems(first, last) {
        -: 7347:        if (m_elems.empty()) {
        -: 7348:            Detail::throw_generator_exception("IteratorGenerator received no valid values");
        -: 7349:        }
        -: 7350:    }
        -: 7351:
        -: 7352:    T const& get() const override {
        -: 7353:        return m_elems[m_current];
        -: 7354:    }
        -: 7355:
        -: 7356:    bool next() override {
        -: 7357:        ++m_current;
        -: 7358:        return m_current != m_elems.size();
        -: 7359:    }
        -: 7360:};
        -: 7361:
        -: 7362:template <typename InputIterator,
        -: 7363:          typename InputSentinel,
        -: 7364:          typename ResultType = typename std::iterator_traits<InputIterator>::value_type>
        -: 7365:GeneratorWrapper<ResultType> from_range(InputIterator from, InputSentinel to) {
        -: 7366:    return GeneratorWrapper<ResultType>(Catch::Detail::make_unique<IteratorGenerator<ResultType>>(from, to));
        -: 7367:}
        -: 7368:
        -: 7369:template <typename Container,
        -: 7370:          typename ResultType = typename Container::value_type>
        -: 7371:GeneratorWrapper<ResultType> from_range(Container const& cnt) {
        -: 7372:    return GeneratorWrapper<ResultType>(Catch::Detail::make_unique<IteratorGenerator<ResultType>>(cnt.begin(), cnt.end()));
        -: 7373:}
        -: 7374:
        -: 7375:
        -: 7376:} // namespace Generators
        -: 7377:} // namespace Catch
        -: 7378:
        -: 7379:
        -: 7380:#endif // CATCH_GENERATORS_RANGE_HPP_INCLUDED
        -: 7381:
        -: 7382:#endif // CATCH_GENERATORS_ALL_HPP_INCLUDED
        -: 7383:
        -: 7384:
        -: 7385:/** \file
        -: 7386: * This is a convenience header for Catch2's interfaces. It includes
        -: 7387: * **all** of Catch2 headers related to interfaces.
        -: 7388: *
        -: 7389: * Generally the Catch2 users should use specific includes they need,
        -: 7390: * but this header can be used instead for ease-of-experimentation, or
        -: 7391: * just plain convenience, at the cost of somewhat increased compilation
        -: 7392: * times.
        -: 7393: *
        -: 7394: * When a new header is added to either the `interfaces` folder, or to
        -: 7395: * the corresponding internal subfolder, it should be added here.
        -: 7396: */
        -: 7397:
        -: 7398:
        -: 7399:#ifndef CATCH_INTERFACES_ALL_HPP_INCLUDED
        -: 7400:#define CATCH_INTERFACES_ALL_HPP_INCLUDED
        -: 7401:
        -: 7402:
        -: 7403:
        -: 7404:#ifndef CATCH_INTERFACES_REPORTER_REGISTRY_HPP_INCLUDED
        -: 7405:#define CATCH_INTERFACES_REPORTER_REGISTRY_HPP_INCLUDED
        -: 7406:
        -: 7407:
        -: 7408:#include <string>
        -: 7409:#include <vector>
        -: 7410:#include <map>
        -: 7411:
        -: 7412:namespace Catch {
        -: 7413:
        -: 7414:    struct IConfig;
        -: 7415:
        -: 7416:    struct IStreamingReporter;
        -: 7417:    using IStreamingReporterPtr = Detail::unique_ptr<IStreamingReporter>;
        -: 7418:    struct IReporterFactory;
        -: 7419:    using IReporterFactoryPtr = Detail::unique_ptr<IReporterFactory>;
        -: 7420:
        2: 7421:    struct IReporterRegistry {
        -: 7422:        using FactoryMap = std::map<std::string, IReporterFactoryPtr>;
        -: 7423:        using Listeners = std::vector<IReporterFactoryPtr>;
        -: 7424:
        -: 7425:        virtual ~IReporterRegistry();
        -: 7426:        virtual IStreamingReporterPtr create( std::string const& name, IConfig const* config ) const = 0;
        -: 7427:        virtual FactoryMap const& getFactories() const = 0;
        -: 7428:        virtual Listeners const& getListeners() const = 0;
        -: 7429:    };
        -: 7430:
        -: 7431:} // end namespace Catch
        -: 7432:
        -: 7433:#endif // CATCH_INTERFACES_REPORTER_REGISTRY_HPP_INCLUDED
        -: 7434:
        -: 7435:
        -: 7436:#ifndef CATCH_INTERFACES_RUNNER_HPP_INCLUDED
        -: 7437:#define CATCH_INTERFACES_RUNNER_HPP_INCLUDED
        -: 7438:
        -: 7439:namespace Catch {
        -: 7440:
        2: 7441:    struct IRunner {
        -: 7442:        virtual ~IRunner();
        -: 7443:        virtual bool aborting() const = 0;
        -: 7444:    };
        -: 7445:}
        -: 7446:
        -: 7447:#endif // CATCH_INTERFACES_RUNNER_HPP_INCLUDED
        -: 7448:
        -: 7449:
        -: 7450:#ifndef CATCH_INTERFACES_TAG_ALIAS_REGISTRY_HPP_INCLUDED
        -: 7451:#define CATCH_INTERFACES_TAG_ALIAS_REGISTRY_HPP_INCLUDED
        -: 7452:
        -: 7453:#include <string>
        -: 7454:
        -: 7455:namespace Catch {
        -: 7456:
        -: 7457:    struct TagAlias;
        -: 7458:
        1: 7459:    struct ITagAliasRegistry {
        -: 7460:        virtual ~ITagAliasRegistry();
        -: 7461:        // Nullptr if not present
        -: 7462:        virtual TagAlias const* find( std::string const& alias ) const = 0;
        -: 7463:        virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const = 0;
        -: 7464:
        -: 7465:        static ITagAliasRegistry const& get();
        -: 7466:    };
        -: 7467:
        -: 7468:} // end namespace Catch
        -: 7469:
        -: 7470:#endif // CATCH_INTERFACES_TAG_ALIAS_REGISTRY_HPP_INCLUDED
        -: 7471:
        -: 7472:#endif // CATCH_INTERFACES_ALL_HPP_INCLUDED
        -: 7473:
        -: 7474:
        -: 7475:
        -: 7476:/** \file
        -: 7477: * Wrapper for UNCAUGHT_EXCEPTIONS configuration option
        -: 7478: *
        -: 7479: * For some functionality, Catch2 requires to know whether there is
        -: 7480: * an active exception. Because `std::uncaught_exception` is deprecated
        -: 7481: * in C++17, we want to use `std::uncaught_exceptions` if possible.
        -: 7482: */
        -: 7483:
        -: 7484:#ifndef CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP
        -: 7485:#define CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP
        -: 7486:
        -: 7487:#if defined(_MSC_VER)
        -: 7488:#  if _MSC_VER >= 1900 // Visual Studio 2015 or newer
        -: 7489:#    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
        -: 7490:#  endif
        -: 7491:#endif
        -: 7492:
        -: 7493:
        -: 7494:#include <exception>
        -: 7495:
        -: 7496:#if defined(__cpp_lib_uncaught_exceptions) \
        -: 7497:    && !defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
        -: 7498:
        -: 7499:#  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
        -: 7500:#endif // __cpp_lib_uncaught_exceptions
        -: 7501:
        -: 7502:
        -: 7503:#if defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS) \
        -: 7504:    && !defined(CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS) \
        -: 7505:    && !defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
        -: 7506:
        -: 7507:#  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
        -: 7508:#endif
        -: 7509:
        -: 7510:
        -: 7511:#endif // CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP
        -: 7512:
        -: 7513:
        -: 7514:#ifndef CATCH_CONSOLE_COLOUR_HPP_INCLUDED
        -: 7515:#define CATCH_CONSOLE_COLOUR_HPP_INCLUDED
        -: 7516:
        -: 7517:
        -: 7518:namespace Catch {
        -: 7519:
        -: 7520:    struct Colour {
        -: 7521:        enum Code {
        -: 7522:            None = 0,
        -: 7523:
        -: 7524:            White,
        -: 7525:            Red,
        -: 7526:            Green,
        -: 7527:            Blue,
        -: 7528:            Cyan,
        -: 7529:            Yellow,
        -: 7530:            Grey,
        -: 7531:
        -: 7532:            Bright = 0x10,
        -: 7533:
        -: 7534:            BrightRed = Bright | Red,
        -: 7535:            BrightGreen = Bright | Green,
        -: 7536:            LightGrey = Bright | Grey,
        -: 7537:            BrightWhite = Bright | White,
        -: 7538:            BrightYellow = Bright | Yellow,
        -: 7539:
        -: 7540:            // By intention
        -: 7541:            FileName = LightGrey,
        -: 7542:            Warning = BrightYellow,
        -: 7543:            ResultError = BrightRed,
        -: 7544:            ResultSuccess = BrightGreen,
        -: 7545:            ResultExpectedFailure = Warning,
        -: 7546:
        -: 7547:            Error = BrightRed,
        -: 7548:            Success = Green,
        -: 7549:
        -: 7550:            OriginalExpression = Cyan,
        -: 7551:            ReconstructedExpression = BrightYellow,
        -: 7552:
        -: 7553:            SecondaryText = LightGrey,
        -: 7554:            Headers = White
        -: 7555:        };
        -: 7556:
        -: 7557:        // Use constructed object for RAII guard
        -: 7558:        Colour( Code _colourCode );
        -: 7559:        Colour( Colour&& other ) noexcept;
        -: 7560:        Colour& operator=( Colour&& other ) noexcept;
        -: 7561:        ~Colour();
        -: 7562:
        -: 7563:        // Use static method for one-shot changes
        -: 7564:        static void use( Code _colourCode );
        -: 7565:
        -: 7566:    private:
        -: 7567:        bool m_moved = false;
        -: 7568:
        -: 7569:        friend std::ostream& operator << (std::ostream& os, Colour const&);
        -: 7570:    };
        -: 7571:
        -: 7572:
        -: 7573:} // end namespace Catch
        -: 7574:
        -: 7575:#endif // CATCH_CONSOLE_COLOUR_HPP_INCLUDED
        -: 7576:
        -: 7577:
        -: 7578:#ifndef CATCH_CONSOLE_WIDTH_HPP_INCLUDED
        -: 7579:#define CATCH_CONSOLE_WIDTH_HPP_INCLUDED
        -: 7580:
        -: 7581:#ifndef CATCH_CONFIG_CONSOLE_WIDTH
        -: 7582:#define CATCH_CONFIG_CONSOLE_WIDTH 80
        -: 7583:#endif
        -: 7584:
        -: 7585:#endif // CATCH_CONSOLE_WIDTH_HPP_INCLUDED
        -: 7586:
        -: 7587:#ifndef CATCH_CONTAINER_NONMEMBERS_HPP_INCLUDED
        -: 7588:#define CATCH_CONTAINER_NONMEMBERS_HPP_INCLUDED
        -: 7589:
        -: 7590:
        -: 7591:
        -: 7592:// We want a simple polyfill over `std::empty`, `std::size` and so on
        -: 7593:// for C++14 or C++ libraries with incomplete support.
        -: 7594:// We also have to handle that MSVC std lib will happily provide these
        -: 7595:// under older standards.
        -: 7596:#if defined(CATCH_CPP17_OR_GREATER) || defined(_MSC_VER)
        -: 7597:
        -: 7598:// We are already using this header either way, so there shouldn't
        -: 7599:// be much additional overhead in including it to get the feature
        -: 7600:// test macros
        -: 7601:#include <string>
        -: 7602:
        -: 7603:#  if !defined(__cpp_lib_nonmember_container_access)
        -: 7604:#      define CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS
        -: 7605:#  endif
        -: 7606:
        -: 7607:#else
        -: 7608:#define CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS
        -: 7609:#endif
        -: 7610:
        -: 7611:
        -: 7612:
        -: 7613:namespace Catch {
        -: 7614:namespace Detail {
        -: 7615:
        -: 7616:#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)
        -: 7617:    template <typename Container>
        -: 7618:    constexpr auto empty(Container const& cont) -> decltype(cont.empty()) {
        -: 7619:        return cont.empty();
        -: 7620:    }
        -: 7621:    template <typename T, std::size_t N>
        -: 7622:    constexpr bool empty(const T (&)[N]) noexcept {
        -: 7623:        // GCC < 7 does not support the const T(&)[] parameter syntax
        -: 7624:        // so we have to ignore the length explicitly
        -: 7625:        (void)N;
        -: 7626:        return false;
        -: 7627:    }
        -: 7628:    template <typename T>
        -: 7629:    constexpr bool empty(std::initializer_list<T> list) noexcept {
        -: 7630:        return list.size() > 0;
        -: 7631:    }
        -: 7632:
        -: 7633:
        -: 7634:    template <typename Container>
        -: 7635:    constexpr auto size(Container const& cont) -> decltype(cont.size()) {
        -: 7636:        return cont.size();
        -: 7637:    }
        -: 7638:    template <typename T, std::size_t N>
        -: 7639:    constexpr std::size_t size(const T(&)[N]) noexcept {
        -: 7640:        return N;
        -: 7641:    }
        -: 7642:#endif // CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS
        -: 7643:
        -: 7644:} // end namespace Detail
        -: 7645:} // end namespace Catch
        -: 7646:
        -: 7647:
        -: 7648:
        -: 7649:#endif // CATCH_CONTAINER_NONMEMBERS_HPP_INCLUDED
        -: 7650:
        -: 7651:
        -: 7652:#ifndef CATCH_DEBUG_CONSOLE_HPP_INCLUDED
        -: 7653:#define CATCH_DEBUG_CONSOLE_HPP_INCLUDED
        -: 7654:
        -: 7655:#include <string>
        -: 7656:
        -: 7657:namespace Catch {
        -: 7658:    void writeToDebugConsole( std::string const& text );
        -: 7659:}
        -: 7660:
        -: 7661:#endif // CATCH_DEBUG_CONSOLE_HPP_INCLUDED
        -: 7662:
        -: 7663:
        -: 7664:#ifndef CATCH_DEBUGGER_HPP_INCLUDED
        -: 7665:#define CATCH_DEBUGGER_HPP_INCLUDED
        -: 7666:
        -: 7667:
        -: 7668:namespace Catch {
        -: 7669:    bool isDebuggerActive();
        -: 7670:}
        -: 7671:
        -: 7672:#ifdef CATCH_PLATFORM_MAC
        -: 7673:
        -: 7674:    #if defined(__i386__) || defined(__x86_64__)
        -: 7675:        #define CATCH_TRAP() __asm__("int $3\n" : : ) /* NOLINT */
        -: 7676:    #elif defined(__aarch64__)
        -: 7677:        #define CATCH_TRAP()  __asm__(".inst 0xd4200000")
        -: 7678:    #endif
        -: 7679:
        -: 7680:#elif defined(CATCH_PLATFORM_IPHONE)
        -: 7681:
        -: 7682:    // use inline assembler
        -: 7683:    #if defined(__i386__) || defined(__x86_64__)
        -: 7684:        #define CATCH_TRAP()  __asm__("int $3")
        -: 7685:    #elif defined(__aarch64__)
        -: 7686:        #define CATCH_TRAP()  __asm__(".inst 0xd4200000")
        -: 7687:    #elif defined(__arm__) && !defined(__thumb__)
        -: 7688:        #define CATCH_TRAP()  __asm__(".inst 0xe7f001f0")
        -: 7689:    #elif defined(__arm__) &&  defined(__thumb__)
        -: 7690:        #define CATCH_TRAP()  __asm__(".inst 0xde01")
        -: 7691:    #endif
        -: 7692:
        -: 7693:#elif defined(CATCH_PLATFORM_LINUX)
        -: 7694:    // If we can use inline assembler, do it because this allows us to break
        -: 7695:    // directly at the location of the failing check instead of breaking inside
        -: 7696:    // raise() called from it, i.e. one stack frame below.
        -: 7697:    #if defined(__GNUC__) && (defined(__i386) || defined(__x86_64))
        -: 7698:        #define CATCH_TRAP() asm volatile ("int $3") /* NOLINT */
        -: 7699:    #else // Fall back to the generic way.
        -: 7700:        #include <signal.h>
        -: 7701:
        -: 7702:        #define CATCH_TRAP() raise(SIGTRAP)
        -: 7703:    #endif
        -: 7704:#elif defined(_MSC_VER)
        -: 7705:    #define CATCH_TRAP() __debugbreak()
        -: 7706:#elif defined(__MINGW32__)
        -: 7707:    extern "C" __declspec(dllimport) void __stdcall DebugBreak();
        -: 7708:    #define CATCH_TRAP() DebugBreak()
        -: 7709:#endif
        -: 7710:
        -: 7711:#ifndef CATCH_BREAK_INTO_DEBUGGER
        -: 7712:    #ifdef CATCH_TRAP
        -: 7713:        #define CATCH_BREAK_INTO_DEBUGGER() []{ if( Catch::isDebuggerActive() ) { CATCH_TRAP(); } }()
        -: 7714:    #else
        -: 7715:        #define CATCH_BREAK_INTO_DEBUGGER() []{}()
        -: 7716:    #endif
        -: 7717:#endif
        -: 7718:
        -: 7719:#endif // CATCH_DEBUGGER_HPP_INCLUDED
        -: 7720:
        -: 7721:
        -: 7722:#ifndef CATCH_ENUM_VALUES_REGISTRY_HPP_INCLUDED
        -: 7723:#define CATCH_ENUM_VALUES_REGISTRY_HPP_INCLUDED
        -: 7724:
        -: 7725:
        -: 7726:#include <vector>
        -: 7727:
        -: 7728:namespace Catch {
        -: 7729:
        -: 7730:    namespace Detail {
        -: 7731:
        -: 7732:        Catch::Detail::unique_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> const& values );
        -: 7733:
        3: 7734:        class EnumValuesRegistry : public IMutableEnumValuesRegistry {
        -: 7735:
        -: 7736:            std::vector<Catch::Detail::unique_ptr<EnumInfo>> m_enumInfos;
        -: 7737:
        -: 7738:            EnumInfo const& registerEnum( StringRef enumName, StringRef allEnums, std::vector<int> const& values) override;
        -: 7739:        };
        -: 7740:
        -: 7741:        std::vector<StringRef> parseEnums( StringRef enums );
        -: 7742:
        -: 7743:    } // Detail
        -: 7744:
        -: 7745:} // Catch
        -: 7746:
        -: 7747:#endif // CATCH_ENUM_VALUES_REGISTRY_HPP_INCLUDED
        -: 7748:
        -: 7749:
        -: 7750:#ifndef CATCH_ERRNO_GUARD_HPP_INCLUDED
        -: 7751:#define CATCH_ERRNO_GUARD_HPP_INCLUDED
        -: 7752:
        -: 7753:namespace Catch {
        -: 7754:
        -: 7755:    //! Simple RAII class that stores the value of `errno`
        -: 7756:    //! at construction and restores it at destruction.
        -: 7757:    class ErrnoGuard {
        -: 7758:    public:
        -: 7759:        // Keep these outlined to avoid dragging in macros from <cerrno>
        -: 7760:
        -: 7761:        ErrnoGuard();
        -: 7762:        ~ErrnoGuard();
        -: 7763:    private:
        -: 7764:        int m_oldErrno;
        -: 7765:    };
        -: 7766:
        -: 7767:}
        -: 7768:
        -: 7769:#endif // CATCH_ERRNO_GUARD_HPP_INCLUDED
        -: 7770:
        -: 7771:
        -: 7772:#ifndef CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED
        -: 7773:#define CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED
        -: 7774:
        -: 7775:#include <vector>
        -: 7776:#include <string>
        -: 7777:
        -: 7778:namespace Catch {
        -: 7779:
        1: 7780:    class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {
        -: 7781:    public:
        -: 7782:        ~ExceptionTranslatorRegistry();
        -: 7783:        virtual void registerTranslator( const IExceptionTranslator* translator );
        -: 7784:        std::string translateActiveException() const override;
        -: 7785:        std::string tryTranslators() const;
        -: 7786:
        -: 7787:    private:
        -: 7788:        ExceptionTranslators m_translators;
        -: 7789:    };
        -: 7790:}
        -: 7791:
        -: 7792:#endif // CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED
        -: 7793:
        -: 7794:
        -: 7795:#ifndef CATCH_FATAL_CONDITION_HANDLER_HPP_INCLUDED
        -: 7796:#define CATCH_FATAL_CONDITION_HANDLER_HPP_INCLUDED
        -: 7797:
        -: 7798:
        -: 7799:
        -: 7800:#ifndef CATCH_WINDOWS_H_PROXY_HPP_INCLUDED
        -: 7801:#define CATCH_WINDOWS_H_PROXY_HPP_INCLUDED
        -: 7802:
        -: 7803:
        -: 7804:#if defined(CATCH_PLATFORM_WINDOWS)
        -: 7805:
        -: 7806:#if !defined(NOMINMAX) && !defined(CATCH_CONFIG_NO_NOMINMAX)
        -: 7807:#  define CATCH_DEFINED_NOMINMAX
        -: 7808:#  define NOMINMAX
        -: 7809:#endif
        -: 7810:#if !defined(WIN32_LEAN_AND_MEAN) && !defined(CATCH_CONFIG_NO_WIN32_LEAN_AND_MEAN)
        -: 7811:#  define CATCH_DEFINED_WIN32_LEAN_AND_MEAN
        -: 7812:#  define WIN32_LEAN_AND_MEAN
        -: 7813:#endif
        -: 7814:
        -: 7815:#ifdef __AFXDLL
        -: 7816:#include <AfxWin.h>
        -: 7817:#else
        -: 7818:#include <windows.h>
        -: 7819:#endif
        -: 7820:
        -: 7821:#ifdef CATCH_DEFINED_NOMINMAX
        -: 7822:#  undef NOMINMAX
        -: 7823:#endif
        -: 7824:#ifdef CATCH_DEFINED_WIN32_LEAN_AND_MEAN
        -: 7825:#  undef WIN32_LEAN_AND_MEAN
        -: 7826:#endif
        -: 7827:
        -: 7828:#endif // defined(CATCH_PLATFORM_WINDOWS)
        -: 7829:
        -: 7830:#endif // CATCH_WINDOWS_H_PROXY_HPP_INCLUDED
        -: 7831:
        -: 7832:
        -: 7833:#if defined( CATCH_CONFIG_WINDOWS_SEH )
        -: 7834:
        -: 7835:namespace Catch {
        -: 7836:
        -: 7837:    struct FatalConditionHandler {
        -: 7838:
        -: 7839:        static LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo);
        -: 7840:        FatalConditionHandler();
        -: 7841:        static void reset();
        -: 7842:        ~FatalConditionHandler() { reset(); }
        -: 7843:
        -: 7844:    private:
        -: 7845:        static bool isSet;
        -: 7846:        static ULONG guaranteeSize;
        -: 7847:        static PVOID exceptionHandlerHandle;
        -: 7848:    };
        -: 7849:
        -: 7850:} // namespace Catch
        -: 7851:
        -: 7852:#elif defined ( CATCH_CONFIG_POSIX_SIGNALS )
        -: 7853:
        -: 7854:#include <signal.h>
        -: 7855:
        -: 7856:namespace Catch {
        -: 7857:
        -: 7858:    struct FatalConditionHandler {
        -: 7859:
        -: 7860:        static bool isSet;
        -: 7861:        static struct sigaction oldSigActions[];
        -: 7862:        static stack_t oldSigStack;
        -: 7863:        static char altStackMem[];
        -: 7864:
        -: 7865:        static void handleSignal( int sig );
        -: 7866:
        -: 7867:        FatalConditionHandler();
        1: 7868:        ~FatalConditionHandler() { reset(); }
        -: 7869:        static void reset();
        -: 7870:    };
        -: 7871:
        -: 7872:} // namespace Catch
        -: 7873:
        -: 7874:
        -: 7875:#else
        -: 7876:
        -: 7877:namespace Catch {
        -: 7878:    struct FatalConditionHandler {};
        -: 7879:}
        -: 7880:
        -: 7881:#endif
        -: 7882:
        -: 7883:#endif // CATCH_FATAL_CONDITION_HANDLER_HPP_INCLUDED
        -: 7884:
        -: 7885:
        -: 7886:#ifndef CATCH_LEAK_DETECTOR_HPP_INCLUDED
        -: 7887:#define CATCH_LEAK_DETECTOR_HPP_INCLUDED
        -: 7888:
        -: 7889:namespace Catch {
        -: 7890:
        -: 7891:    struct LeakDetector {
        -: 7892:        LeakDetector();
        -: 7893:        ~LeakDetector();
        -: 7894:    };
        -: 7895:
        -: 7896:}
        -: 7897:#endif // CATCH_LEAK_DETECTOR_HPP_INCLUDED
        -: 7898:
        -: 7899:
        -: 7900:#ifndef CATCH_LIST_HPP_INCLUDED
        -: 7901:#define CATCH_LIST_HPP_INCLUDED
        -: 7902:
        -: 7903:
        -: 7904:#include <set>
        -: 7905:#include <string>
        -: 7906:
        -: 7907:
        -: 7908:namespace Catch {
        -: 7909:
        -: 7910:    struct IStreamingReporter;
        -: 7911:    class Config;
        -: 7912:
        -: 7913:
    #####: 7914:    struct ReporterDescription {
        -: 7915:        std::string name, description;
        -: 7916:    };
        -: 7917:
    #####: 7918:    struct TagInfo {
        -: 7919:        void add(StringRef spelling);
        -: 7920:        std::string all() const;
        -: 7921:
        -: 7922:        std::set<StringRef> spellings;
        -: 7923:        std::size_t count = 0;
        -: 7924:    };
        -: 7925:
        -: 7926:    bool list( IStreamingReporter& reporter, Config const& config );
        -: 7927:
        -: 7928:} // end namespace Catch
        -: 7929:
        -: 7930:#endif // CATCH_LIST_HPP_INCLUDED
        -: 7931:
        -: 7932:
        -: 7933:#ifndef CATCH_OPTION_HPP_INCLUDED
        -: 7934:#define CATCH_OPTION_HPP_INCLUDED
        -: 7935:
        -: 7936:namespace Catch {
        -: 7937:
        -: 7938:    // An optional type
        -: 7939:    template<typename T>
        -: 7940:    class Option {
        -: 7941:    public:
        3: 7942:        Option() : nullableValue( nullptr ) {}
        -: 7943:        Option( T const& _value )
        -: 7944:        : nullableValue( new( storage ) T( _value ) )
        -: 7945:        {}
        -: 7946:        Option( Option const& _other )
        -: 7947:        : nullableValue( _other ? new( storage ) T( *_other ) : nullptr )
        -: 7948:        {}
        -: 7949:
        -: 7950:        ~Option() {
        -: 7951:            reset();
        3: 7952:        }
        -: 7953:
        -: 7954:        Option& operator= ( Option const& _other ) {
        -: 7955:            if( &_other != this ) {
        -: 7956:                reset();
        -: 7957:                if( _other )
        -: 7958:                    nullableValue = new( storage ) T( *_other );
        -: 7959:            }
        -: 7960:            return *this;
        -: 7961:        }
        2: 7962:        Option& operator = ( T const& _value ) {
        -: 7963:            reset();
        4: 7964:            nullableValue = new( storage ) T( _value );
        2: 7965:            return *this;
        -: 7966:        }
        -: 7967:
        -: 7968:        void reset() {
        8: 7969:            if( nullableValue )
        -: 7970:                nullableValue->~T();
        8: 7971:            nullableValue = nullptr;
        -: 7972:        }
        -: 7973:
        -: 7974:        T& operator*() { return *nullableValue; }
        -: 7975:        T const& operator*() const { return *nullableValue; }
        -: 7976:        T* operator->() { return nullableValue; }
        -: 7977:        const T* operator->() const { return nullableValue; }
        -: 7978:
        -: 7979:        T valueOr( T const& defaultValue ) const {
        -: 7980:            return nullableValue ? *nullableValue : defaultValue;
        -: 7981:        }
        -: 7982:
        -: 7983:        bool some() const { return nullableValue != nullptr; }
        -: 7984:        bool none() const { return nullableValue == nullptr; }
        -: 7985:
        -: 7986:        bool operator !() const { return nullableValue == nullptr; }
        -: 7987:        explicit operator bool() const {
        -: 7988:            return some();
        -: 7989:        }
        -: 7990:
        -: 7991:    private:
        -: 7992:        T *nullableValue;
        -: 7993:        alignas(alignof(T)) char storage[sizeof(T)];
        -: 7994:    };
        -: 7995:
        -: 7996:} // end namespace Catch
        -: 7997:
        -: 7998:#endif // CATCH_OPTION_HPP_INCLUDED
        -: 7999:
        -: 8000:
        -: 8001:#ifndef CATCH_OUTPUT_REDIRECT_HPP_INCLUDED
        -: 8002:#define CATCH_OUTPUT_REDIRECT_HPP_INCLUDED
        -: 8003:
        -: 8004:
        -: 8005:#include <cstdio>
        -: 8006:#include <iosfwd>
        -: 8007:#include <string>
        -: 8008:
        -: 8009:namespace Catch {
        -: 8010:
        -: 8011:    class RedirectedStream {
        -: 8012:        std::ostream& m_originalStream;
        -: 8013:        std::ostream& m_redirectionStream;
        -: 8014:        std::streambuf* m_prevBuf;
        -: 8015:
        -: 8016:    public:
        -: 8017:        RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream );
        -: 8018:        ~RedirectedStream();
        -: 8019:    };
        -: 8020:
    #####: 8021:    class RedirectedStdOut {
        -: 8022:        ReusableStringStream m_rss;
        -: 8023:        RedirectedStream m_cout;
        -: 8024:    public:
        -: 8025:        RedirectedStdOut();
        -: 8026:        auto str() const -> std::string;
        -: 8027:    };
        -: 8028:
        -: 8029:    // StdErr has two constituent streams in C++, std::cerr and std::clog
        -: 8030:    // This means that we need to redirect 2 streams into 1 to keep proper
        -: 8031:    // order of writes
    #####: 8032:    class RedirectedStdErr {
        -: 8033:        ReusableStringStream m_rss;
        -: 8034:        RedirectedStream m_cerr;
        -: 8035:        RedirectedStream m_clog;
        -: 8036:    public:
        -: 8037:        RedirectedStdErr();
        -: 8038:        auto str() const -> std::string;
        -: 8039:    };
        -: 8040:
        -: 8041:    class RedirectedStreams {
        -: 8042:    public:
        -: 8043:        RedirectedStreams(RedirectedStreams const&) = delete;
        -: 8044:        RedirectedStreams& operator=(RedirectedStreams const&) = delete;
        -: 8045:        RedirectedStreams(RedirectedStreams&&) = delete;
        -: 8046:        RedirectedStreams& operator=(RedirectedStreams&&) = delete;
        -: 8047:
        -: 8048:        RedirectedStreams(std::string& redirectedCout, std::string& redirectedCerr);
        -: 8049:        ~RedirectedStreams();
        -: 8050:    private:
        -: 8051:        std::string& m_redirectedCout;
        -: 8052:        std::string& m_redirectedCerr;
        -: 8053:        RedirectedStdOut m_redirectedStdOut;
        -: 8054:        RedirectedStdErr m_redirectedStdErr;
        -: 8055:    };
        -: 8056:
        -: 8057:#if defined(CATCH_CONFIG_NEW_CAPTURE)
        -: 8058:
        -: 8059:    // Windows's implementation of std::tmpfile is terrible (it tries
        -: 8060:    // to create a file inside system folder, thus requiring elevated
        -: 8061:    // privileges for the binary), so we have to use tmpnam(_s) and
        -: 8062:    // create the file ourselves there.
        -: 8063:    class TempFile {
        -: 8064:    public:
        -: 8065:        TempFile(TempFile const&) = delete;
        -: 8066:        TempFile& operator=(TempFile const&) = delete;
        -: 8067:        TempFile(TempFile&&) = delete;
        -: 8068:        TempFile& operator=(TempFile&&) = delete;
        -: 8069:
        -: 8070:        TempFile();
        -: 8071:        ~TempFile();
        -: 8072:
        -: 8073:        std::FILE* getFile();
        -: 8074:        std::string getContents();
        -: 8075:
        -: 8076:    private:
        -: 8077:        std::FILE* m_file = nullptr;
        -: 8078:    #if defined(_MSC_VER)
        -: 8079:        char m_buffer[L_tmpnam] = { 0 };
        -: 8080:    #endif
        -: 8081:    };
        -: 8082:
        -: 8083:
        -: 8084:    class OutputRedirect {
        -: 8085:    public:
        -: 8086:        OutputRedirect(OutputRedirect const&) = delete;
        -: 8087:        OutputRedirect& operator=(OutputRedirect const&) = delete;
        -: 8088:        OutputRedirect(OutputRedirect&&) = delete;
        -: 8089:        OutputRedirect& operator=(OutputRedirect&&) = delete;
        -: 8090:
        -: 8091:
        -: 8092:        OutputRedirect(std::string& stdout_dest, std::string& stderr_dest);
        -: 8093:        ~OutputRedirect();
        -: 8094:
        -: 8095:    private:
        -: 8096:        int m_originalStdout = -1;
        -: 8097:        int m_originalStderr = -1;
        -: 8098:        TempFile m_stdoutFile;
        -: 8099:        TempFile m_stderrFile;
        -: 8100:        std::string& m_stdoutDest;
        -: 8101:        std::string& m_stderrDest;
        -: 8102:    };
        -: 8103:
        -: 8104:#endif
        -: 8105:
        -: 8106:} // end namespace Catch
        -: 8107:
        -: 8108:#endif // CATCH_OUTPUT_REDIRECT_HPP_INCLUDED
        -: 8109:
        -: 8110:
        -: 8111:#ifndef CATCH_POLYFILLS_HPP_INCLUDED
        -: 8112:#define CATCH_POLYFILLS_HPP_INCLUDED
        -: 8113:
        -: 8114:namespace Catch {
        -: 8115:    bool isnan(float f);
        -: 8116:    bool isnan(double d);
        -: 8117:}
        -: 8118:
        -: 8119:#endif // CATCH_POLYFILLS_HPP_INCLUDED
        -: 8120:
        -: 8121:
        -: 8122:#ifndef CATCH_REPORTER_REGISTRY_HPP_INCLUDED
        -: 8123:#define CATCH_REPORTER_REGISTRY_HPP_INCLUDED
        -: 8124:
        -: 8125:
        -: 8126:#include <map>
        -: 8127:
        -: 8128:namespace Catch {
        -: 8129:
        2: 8130:    class ReporterRegistry : public IReporterRegistry {
        -: 8131:    public:
        -: 8132:
        -: 8133:        ReporterRegistry();
        -: 8134:        ~ReporterRegistry() override; // = default, out of line to allow fwd decl
        -: 8135:
        -: 8136:        IStreamingReporterPtr create( std::string const& name, IConfig const* config ) const override;
        -: 8137:
        -: 8138:        void registerReporter( std::string const& name, IReporterFactoryPtr factory );
        -: 8139:        void registerListener( IReporterFactoryPtr factory );
        -: 8140:
        -: 8141:        FactoryMap const& getFactories() const override;
        -: 8142:        Listeners const& getListeners() const override;
        -: 8143:
        -: 8144:    private:
        -: 8145:        FactoryMap m_factories;
        -: 8146:        Listeners m_listeners;
        -: 8147:    };
        -: 8148:}
        -: 8149:
        -: 8150:#endif // CATCH_REPORTER_REGISTRY_HPP_INCLUDED
        -: 8151:
        -: 8152:
        -: 8153:#ifndef CATCH_RUN_CONTEXT_HPP_INCLUDED
        -: 8154:#define CATCH_RUN_CONTEXT_HPP_INCLUDED
        -: 8155:
        -: 8156:
        -: 8157:
        -: 8158:#ifndef CATCH_TEST_CASE_TRACKER_HPP_INCLUDED
        -: 8159:#define CATCH_TEST_CASE_TRACKER_HPP_INCLUDED
        -: 8160:
        -: 8161:
        -: 8162:#include <string>
        -: 8163:#include <vector>
        -: 8164:#include <memory>
        -: 8165:
        -: 8166:namespace Catch {
        -: 8167:namespace TestCaseTracking {
        -: 8168:
        8: 8169:    struct NameAndLocation {
        -: 8170:        std::string name;
        -: 8171:        SourceLineInfo location;
        -: 8172:
        -: 8173:        NameAndLocation( std::string const& _name, SourceLineInfo const& _location );
    #####: 8174:        friend bool operator==(NameAndLocation const& lhs, NameAndLocation const& rhs) {
    #####: 8175:            return lhs.name == rhs.name
    #####: 8176:                && lhs.location == rhs.location;
        -: 8177:        }
        -: 8178:    };
        -: 8179:
        -: 8180:    class ITracker;
        -: 8181:
        -: 8182:    using ITrackerPtr = std::shared_ptr<ITracker>;
        -: 8183:
        4: 8184:    class  ITracker {
        -: 8185:        NameAndLocation m_nameAndLocation;
        -: 8186:
        -: 8187:        using Children = std::vector<ITrackerPtr>;
        -: 8188:
        -: 8189:    protected:
        -: 8190:        Children m_children;
        -: 8191:
        -: 8192:    public:
        2: 8193:        ITracker(NameAndLocation const& nameAndLoc) :
        2: 8194:            m_nameAndLocation(nameAndLoc)
        2: 8195:        {}
        -: 8196:
        -: 8197:
        -: 8198:        // static queries
        -: 8199:        NameAndLocation const& nameAndLocation() const {
    #####: 8200:            return m_nameAndLocation;
        -: 8201:        }
        -: 8202:
        -: 8203:        virtual ~ITracker();
        -: 8204:
        -: 8205:
        -: 8206:        // dynamic queries
        -: 8207:        virtual bool isComplete() const = 0; // Successfully completed or failed
        -: 8208:        virtual bool isSuccessfullyCompleted() const = 0;
        -: 8209:        virtual bool isOpen() const = 0; // Started but not complete
        -: 8210:        virtual bool hasStarted() const = 0;
        -: 8211:
        -: 8212:        virtual ITracker& parent() = 0;
        -: 8213:
        -: 8214:        // actions
        -: 8215:        virtual void close() = 0; // Successfully complete
        -: 8216:        virtual void fail() = 0;
        -: 8217:        virtual void markAsNeedingAnotherRun() = 0;
        -: 8218:
        -: 8219:        //! Register a nested ITracker
        -: 8220:        void addChild( ITrackerPtr const& child );
        -: 8221:        /**
        -: 8222:         * Returns ptr to specific child if register with this tracker.
        -: 8223:         *
        -: 8224:         * Returns nullptr if not found.
        -: 8225:         */
        -: 8226:        ITrackerPtr findChild( NameAndLocation const& nameAndLocation );
        -: 8227:        //! Have any children been added?
        -: 8228:        bool hasChildren() const {
        -: 8229:            return !m_children.empty();
        -: 8230:        }
        -: 8231:
        -: 8232:
        -: 8233:        virtual void openChild() = 0;
        -: 8234:
        -: 8235:        // Debug/ checking
        -: 8236:        virtual bool isSectionTracker() const = 0;
        -: 8237:        virtual bool isGeneratorTracker() const = 0;
        -: 8238:    };
        -: 8239:
        2: 8240:    class TrackerContext {
        -: 8241:
        -: 8242:        enum RunState {
        -: 8243:            NotStarted,
        -: 8244:            Executing,
        -: 8245:            CompletedCycle
        -: 8246:        };
        -: 8247:
        -: 8248:        ITrackerPtr m_rootTracker;
        -: 8249:        ITracker* m_currentTracker = nullptr;
        -: 8250:        RunState m_runState = NotStarted;
        -: 8251:
        -: 8252:    public:
        -: 8253:
        -: 8254:        ITracker& startRun();
        -: 8255:        void endRun();
        -: 8256:
        -: 8257:        void startCycle();
        -: 8258:        void completeCycle();
        -: 8259:
        -: 8260:        bool completedCycle() const;
        -: 8261:        ITracker& currentTracker();
        -: 8262:        void setCurrentTracker( ITracker* tracker );
        -: 8263:    };
        -: 8264:
        2: 8265:    class TrackerBase : public ITracker {
        -: 8266:    protected:
        -: 8267:        enum CycleState {
        -: 8268:            NotStarted,
        -: 8269:            Executing,
        -: 8270:            ExecutingChildren,
        -: 8271:            NeedsAnotherRun,
        -: 8272:            CompletedSuccessfully,
        -: 8273:            Failed
        -: 8274:        };
        -: 8275:
        -: 8276:        TrackerContext& m_ctx;
        -: 8277:        ITracker* m_parent;
        -: 8278:        CycleState m_runState = NotStarted;
        -: 8279:
        -: 8280:    public:
        -: 8281:        TrackerBase( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent );
        -: 8282:
        -: 8283:        bool isComplete() const override;
        -: 8284:        bool isSuccessfullyCompleted() const override;
        -: 8285:        bool isOpen() const override;
    #####: 8286:        bool hasStarted() const override {
    #####: 8287:            return m_runState != NotStarted;
        -: 8288:        }
        -: 8289:
        -: 8290:        ITracker& parent() override;
        -: 8291:
        -: 8292:        void openChild() override;
        -: 8293:
        -: 8294:        bool isSectionTracker() const override;
        -: 8295:        bool isGeneratorTracker() const override;
        -: 8296:
        -: 8297:        void open();
        -: 8298:
        -: 8299:        void close() override;
        -: 8300:        void fail() override;
        -: 8301:        void markAsNeedingAnotherRun() override;
        -: 8302:
        -: 8303:    private:
        -: 8304:        void moveToParent();
        -: 8305:        void moveToThis();
        -: 8306:    };
        -: 8307:
        6: 8308:    class SectionTracker : public TrackerBase {
        -: 8309:        std::vector<std::string> m_filters;
        -: 8310:        std::string m_trimmed_name;
        -: 8311:    public:
        -: 8312:        SectionTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent );
        -: 8313:
        -: 8314:        bool isSectionTracker() const override;
        -: 8315:
        -: 8316:        bool isComplete() const override;
        -: 8317:
        -: 8318:        static SectionTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation );
        -: 8319:
        -: 8320:        void tryOpen();
        -: 8321:
        -: 8322:        void addInitialFilters( std::vector<std::string> const& filters );
        -: 8323:        void addNextFilters( std::vector<std::string> const& filters );
        -: 8324:    };
        -: 8325:
        -: 8326:} // namespace TestCaseTracking
        -: 8327:
        -: 8328:using TestCaseTracking::ITracker;
        -: 8329:using TestCaseTracking::TrackerContext;
        -: 8330:using TestCaseTracking::SectionTracker;
        -: 8331:
        -: 8332:} // namespace Catch
        -: 8333:
        -: 8334:#endif // CATCH_TEST_CASE_TRACKER_HPP_INCLUDED
        -: 8335:
        -: 8336:#include <string>
        -: 8337:
        -: 8338:namespace Catch {
        -: 8339:
        -: 8340:    struct IMutableContext;
        -: 8341:    struct IGeneratorTracker;
        -: 8342:    struct IConfig;
        -: 8343:
        -: 8344:    ///////////////////////////////////////////////////////////////////////////
        -: 8345:
        -: 8346:    class RunContext : public IResultCapture, public IRunner {
        -: 8347:
        -: 8348:    public:
        -: 8349:        RunContext( RunContext const& ) = delete;
        -: 8350:        RunContext& operator =( RunContext const& ) = delete;
        -: 8351:
        -: 8352:        explicit RunContext( IConfig const* _config, IStreamingReporterPtr&& reporter );
        -: 8353:
        -: 8354:        ~RunContext() override;
        -: 8355:
        -: 8356:        void testGroupStarting( std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount );
        -: 8357:        void testGroupEnded( std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount );
        -: 8358:
        -: 8359:        Totals runTest(TestCaseHandle const& testCase);
        -: 8360:
        -: 8361:    public: // IResultCapture
        -: 8362:
        -: 8363:        // Assertion handlers
        -: 8364:        void handleExpr
        -: 8365:                (   AssertionInfo const& info,
        -: 8366:                    ITransientExpression const& expr,
        -: 8367:                    AssertionReaction& reaction ) override;
        -: 8368:        void handleMessage
        -: 8369:                (   AssertionInfo const& info,
        -: 8370:                    ResultWas::OfType resultType,
        -: 8371:                    StringRef const& message,
        -: 8372:                    AssertionReaction& reaction ) override;
        -: 8373:        void handleUnexpectedExceptionNotThrown
        -: 8374:                (   AssertionInfo const& info,
        -: 8375:                    AssertionReaction& reaction ) override;
        -: 8376:        void handleUnexpectedInflightException
        -: 8377:                (   AssertionInfo const& info,
        -: 8378:                    std::string const& message,
        -: 8379:                    AssertionReaction& reaction ) override;
        -: 8380:        void handleIncomplete
        -: 8381:                (   AssertionInfo const& info ) override;
        -: 8382:        void handleNonExpr
        -: 8383:                (   AssertionInfo const &info,
        -: 8384:                    ResultWas::OfType resultType,
        -: 8385:                    AssertionReaction &reaction ) override;
        -: 8386:
        -: 8387:        bool sectionStarted( SectionInfo const& sectionInfo, Counts& assertions ) override;
        -: 8388:
        -: 8389:        void sectionEnded( SectionEndInfo const& endInfo ) override;
        -: 8390:        void sectionEndedEarly( SectionEndInfo const& endInfo ) override;
        -: 8391:
        -: 8392:        auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const& lineInfo ) -> IGeneratorTracker& override;
        -: 8393:
        -: 8394:        void benchmarkPreparing( std::string const& name ) override;
        -: 8395:        void benchmarkStarting( BenchmarkInfo const& info ) override;
        -: 8396:        void benchmarkEnded( BenchmarkStats<> const& stats ) override;
        -: 8397:        void benchmarkFailed( std::string const& error ) override;
        -: 8398:
        -: 8399:        void pushScopedMessage( MessageInfo const& message ) override;
        -: 8400:        void popScopedMessage( MessageInfo const& message ) override;
        -: 8401:
        -: 8402:        void emplaceUnscopedMessage( MessageBuilder const& builder ) override;
        -: 8403:
        -: 8404:        std::string getCurrentTestName() const override;
        -: 8405:
        -: 8406:        const AssertionResult* getLastResult() const override;
        -: 8407:
        -: 8408:        void exceptionEarlyReported() override;
        -: 8409:
        -: 8410:        void handleFatalErrorCondition( StringRef message ) override;
        -: 8411:
        -: 8412:        bool lastAssertionPassed() override;
        -: 8413:
        -: 8414:        void assertionPassed() override;
        -: 8415:
        -: 8416:    public:
        -: 8417:        // !TBD We need to do this another way!
        -: 8418:        bool aborting() const override;
        -: 8419:
        -: 8420:    private:
        -: 8421:
        -: 8422:        void runCurrentTest( std::string& redirectedCout, std::string& redirectedCerr );
        -: 8423:        void invokeActiveTestCase();
        -: 8424:
        -: 8425:        void resetAssertionInfo();
        -: 8426:        bool testForMissingAssertions( Counts& assertions );
        -: 8427:
        -: 8428:        void assertionEnded( AssertionResult const& result );
        -: 8429:        void reportExpr
        -: 8430:                (   AssertionInfo const &info,
        -: 8431:                    ResultWas::OfType resultType,
        -: 8432:                    ITransientExpression const *expr,
        -: 8433:                    bool negated );
        -: 8434:
        -: 8435:        void populateReaction( AssertionReaction& reaction );
        -: 8436:
        -: 8437:    private:
        -: 8438:
        -: 8439:        void handleUnfinishedSections();
        -: 8440:
        -: 8441:        TestRunInfo m_runInfo;
        -: 8442:        IMutableContext& m_context;
        -: 8443:        TestCaseHandle const* m_activeTestCase = nullptr;
        -: 8444:        ITracker* m_testCaseTracker = nullptr;
        -: 8445:        Option<AssertionResult> m_lastResult;
        -: 8446:
        -: 8447:        IConfig const* m_config;
        -: 8448:        Totals m_totals;
        -: 8449:        IStreamingReporterPtr m_reporter;
        -: 8450:        std::vector<MessageInfo> m_messages;
        -: 8451:        std::vector<ScopedMessage> m_messageScopes; /* Keeps owners of so-called unscoped messages. */
        -: 8452:        AssertionInfo m_lastAssertionInfo;
        -: 8453:        std::vector<SectionEndInfo> m_unfinishedSections;
        -: 8454:        std::vector<ITracker*> m_activeSections;
        -: 8455:        TrackerContext m_trackerContext;
        -: 8456:        bool m_lastAssertionPassed = false;
        -: 8457:        bool m_shouldReportUnexpected = true;
        -: 8458:        bool m_includeSuccessfulResults;
        -: 8459:    };
        -: 8460:
        -: 8461:    void seedRng(IConfig const& config);
        -: 8462:    unsigned int rngSeed();
        -: 8463:} // end namespace Catch
        -: 8464:
        -: 8465:#endif // CATCH_RUN_CONTEXT_HPP_INCLUDED
        -: 8466:
        -: 8467:
        -: 8468:#ifndef CATCH_SINGLETONS_HPP_INCLUDED
        -: 8469:#define CATCH_SINGLETONS_HPP_INCLUDED
        -: 8470:
        -: 8471:namespace Catch {
        -: 8472:
        2: 8473:    struct ISingleton {
        -: 8474:        virtual ~ISingleton();
        -: 8475:    };
        -: 8476:
        -: 8477:
        -: 8478:    void addSingleton( ISingleton* singleton );
        -: 8479:    void cleanupSingletons();
        -: 8480:
        -: 8481:
        -: 8482:    template<typename SingletonImplT, typename InterfaceT = SingletonImplT, typename MutableInterfaceT = InterfaceT>
        8: 8483:    class Singleton : SingletonImplT, public ISingleton {
        -: 8484:
        9: 8485:        static auto getInternal() -> Singleton* {
        -: 8486:            static Singleton* s_instance = nullptr;
        9: 8487:            if( !s_instance ) {
        4: 8488:                s_instance = new Singleton;
        1: 8489:                addSingleton( s_instance );
        -: 8490:            }
        9: 8491:            return s_instance;
        -: 8492:        }
        -: 8493:
        -: 8494:    public:
        -: 8495:        static auto get() -> InterfaceT const& {
        5: 8496:            return *getInternal();
        -: 8497:        }
        -: 8498:        static auto getMutable() -> MutableInterfaceT& {
        4: 8499:            return *getInternal();
        -: 8500:        }
        -: 8501:    };
        -: 8502:
        -: 8503:} // namespace Catch
        -: 8504:
        -: 8505:#endif // CATCH_SINGLETONS_HPP_INCLUDED
        -: 8506:
        -: 8507:
        -: 8508:#ifndef CATCH_STARTUP_EXCEPTION_REGISTRY_HPP_INCLUDED
        -: 8509:#define CATCH_STARTUP_EXCEPTION_REGISTRY_HPP_INCLUDED
        -: 8510:
        -: 8511:
        -: 8512:#include <vector>
        -: 8513:#include <exception>
        -: 8514:
        -: 8515:namespace Catch {
        -: 8516:
        1: 8517:    class StartupExceptionRegistry {
        -: 8518:#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
        -: 8519:    public:
        -: 8520:        void add(std::exception_ptr const& exception) noexcept;
        -: 8521:        std::vector<std::exception_ptr> const& getExceptions() const noexcept;
        -: 8522:    private:
        -: 8523:        std::vector<std::exception_ptr> m_exceptions;
        -: 8524:#endif
        -: 8525:    };
        -: 8526:
        -: 8527:} // end namespace Catch
        -: 8528:
        -: 8529:#endif // CATCH_STARTUP_EXCEPTION_REGISTRY_HPP_INCLUDED
        -: 8530:
        -: 8531:
        -: 8532:#ifndef CATCH_STRING_MANIP_HPP_INCLUDED
        -: 8533:#define CATCH_STRING_MANIP_HPP_INCLUDED
        -: 8534:
        -: 8535:
        -: 8536:#include <string>
        -: 8537:#include <iosfwd>
        -: 8538:#include <vector>
        -: 8539:
        -: 8540:namespace Catch {
        -: 8541:
        -: 8542:    bool startsWith( std::string const& s, std::string const& prefix );
        -: 8543:    bool startsWith( std::string const& s, char prefix );
        -: 8544:    bool endsWith( std::string const& s, std::string const& suffix );
        -: 8545:    bool endsWith( std::string const& s, char suffix );
        -: 8546:    bool contains( std::string const& s, std::string const& infix );
        -: 8547:    void toLowerInPlace( std::string& s );
        -: 8548:    std::string toLower( std::string const& s );
        -: 8549:    //! Returns a new string without whitespace at the start/end
        -: 8550:    std::string trim( std::string const& str );
        -: 8551:    //! Returns a substring of the original ref without whitespace. Beware lifetimes!
        -: 8552:    StringRef trim(StringRef ref);
        -: 8553:
        -: 8554:    // !!! Be aware, returns refs into original string - make sure original string outlives them
        -: 8555:    std::vector<StringRef> splitStringRef( StringRef str, char delimiter );
        -: 8556:    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );
        -: 8557:
        2: 8558:    struct pluralise {
        -: 8559:        pluralise( std::size_t count, std::string const& label );
        -: 8560:
        -: 8561:        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );
        -: 8562:
        -: 8563:        std::size_t m_count;
        -: 8564:        std::string m_label;
        -: 8565:    };
        -: 8566:}
        -: 8567:
        -: 8568:#endif // CATCH_STRING_MANIP_HPP_INCLUDED
        -: 8569:
        -: 8570:
        -: 8571:#ifndef CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED
        -: 8572:#define CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED
        -: 8573:
        -: 8574:
        -: 8575:#include <map>
        -: 8576:#include <string>
        -: 8577:
        -: 8578:namespace Catch {
        -: 8579:
        1: 8580:    class TagAliasRegistry : public ITagAliasRegistry {
        -: 8581:    public:
        -: 8582:        ~TagAliasRegistry() override;
        -: 8583:        TagAlias const* find( std::string const& alias ) const override;
        -: 8584:        std::string expandAliases( std::string const& unexpandedTestSpec ) const override;
        -: 8585:        void add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo );
        -: 8586:
        -: 8587:    private:
        -: 8588:        std::map<std::string, TagAlias> m_registry;
        -: 8589:    };
        -: 8590:
        -: 8591:} // end namespace Catch
        -: 8592:
        -: 8593:#endif // CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED
        -: 8594:
        -: 8595:
        -: 8596:#ifndef CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED
        -: 8597:#define CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED
        -: 8598:
        -: 8599:
        -: 8600:#include <vector>
        -: 8601:
        -: 8602:namespace Catch {
        -: 8603:
        -: 8604:    class TestCaseHandle;
        -: 8605:    struct IConfig;
        -: 8606:    class TestSpec;
        -: 8607:
        -: 8608:    std::vector<TestCaseHandle> sortTests( IConfig const& config, std::vector<TestCaseHandle> const& unsortedTestCases );
        -: 8609:
        -: 8610:    bool isThrowSafe( TestCaseHandle const& testCase, IConfig const& config );
        -: 8611:    bool matchTest( TestCaseHandle const& testCase, TestSpec const& testSpec, IConfig const& config );
        -: 8612:
        -: 8613:    void enforceNoDuplicateTestCases( std::vector<TestCaseHandle> const& functions );
        -: 8614:
        -: 8615:    std::vector<TestCaseHandle> filterTests( std::vector<TestCaseHandle> const& testCases, TestSpec const& testSpec, IConfig const& config );
        -: 8616:    std::vector<TestCaseHandle> const& getAllTestCasesSorted( IConfig const& config );
        -: 8617:
        2: 8618:    class TestRegistry : public ITestCaseRegistry {
        -: 8619:    public:
        4: 8620:        ~TestRegistry() override = default;
        -: 8621:
        -: 8622:        void registerTest( Detail::unique_ptr<TestCaseInfo> testInfo, Detail::unique_ptr<ITestInvoker> testInvoker );
        -: 8623:
        -: 8624:        std::vector<TestCaseInfo*> const& getAllInfos() const override;
        -: 8625:        std::vector<TestCaseHandle> const& getAllTests() const override;
        -: 8626:        std::vector<TestCaseHandle> const& getAllTestsSorted( IConfig const& config ) const override;
        -: 8627:
        -: 8628:    private:
        -: 8629:        std::vector<Detail::unique_ptr<TestCaseInfo>> m_owned_test_infos;
        -: 8630:        // Keeps a materialized vector for `getAllInfos`.
        -: 8631:        // We should get rid of that eventually (see interface note)
        -: 8632:        std::vector<TestCaseInfo*> m_viewed_test_infos;
        -: 8633:
        -: 8634:        std::vector<Detail::unique_ptr<ITestInvoker>> m_invokers;
        -: 8635:        std::vector<TestCaseHandle> m_handles;
        -: 8636:        mutable TestRunOrder m_currentSortOrder = TestRunOrder::Declared;
        -: 8637:        mutable std::vector<TestCaseHandle> m_sortedFunctions;
        -: 8638:    };
        -: 8639:
        -: 8640:    ///////////////////////////////////////////////////////////////////////////
        -: 8641:
        2: 8642:    class TestInvokerAsFunction final : public ITestInvoker {
        -: 8643:        using TestType = void(*)();
        -: 8644:        TestType m_testAsFunction;
        -: 8645:    public:
        -: 8646:        TestInvokerAsFunction(TestType testAsFunction) noexcept:
        1: 8647:            m_testAsFunction(testAsFunction) {}
        -: 8648:
        -: 8649:        void invoke() const override;
        -: 8650:    };
        -: 8651:
        -: 8652:
        -: 8653:    std::string extractClassName( StringRef const& classOrQualifiedMethodName );
        -: 8654:
        -: 8655:    ///////////////////////////////////////////////////////////////////////////
        -: 8656:
        -: 8657:
        -: 8658:} // end namespace Catch
        -: 8659:
        -: 8660:
        -: 8661:#endif // CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED
        -: 8662:
        -: 8663:
        -: 8664:#ifndef CATCH_TEST_SPEC_PARSER_HPP_INCLUDED
        -: 8665:#define CATCH_TEST_SPEC_PARSER_HPP_INCLUDED
        -: 8666:
        -: 8667:#ifdef __clang__
        -: 8668:#pragma clang diagnostic push
        -: 8669:#pragma clang diagnostic ignored "-Wpadded"
        -: 8670:#endif
        -: 8671:
        -: 8672:
        -: 8673:#include <vector>
        -: 8674:#include <string>
        -: 8675:
        -: 8676:namespace Catch {
        -: 8677:
        -: 8678:    struct ITagAliasRegistry;
        -: 8679:
        2: 8680:    class TestSpecParser {
        -: 8681:        enum Mode{ None, Name, QuotedName, Tag, EscapedName };
        -: 8682:        Mode m_mode = None;
        -: 8683:        Mode lastMode = None;
        -: 8684:        bool m_exclusion = false;
        -: 8685:        std::size_t m_pos = 0;
        -: 8686:        std::size_t m_realPatternPos = 0;
        -: 8687:        std::string m_arg;
        -: 8688:        std::string m_substring;
        -: 8689:        std::string m_patternName;
        -: 8690:        std::vector<std::size_t> m_escapeChars;
        -: 8691:        TestSpec::Filter m_currentFilter;
        -: 8692:        TestSpec m_testSpec;
        -: 8693:        ITagAliasRegistry const* m_tagAliases = nullptr;
        -: 8694:
        -: 8695:    public:
        -: 8696:        TestSpecParser( ITagAliasRegistry const& tagAliases );
        -: 8697:
        -: 8698:        TestSpecParser& parse( std::string const& arg );
        -: 8699:        TestSpec testSpec();
        -: 8700:
        -: 8701:    private:
        -: 8702:        bool visitChar( char c );
        -: 8703:        void startNewMode( Mode mode );
        -: 8704:        bool processNoneChar( char c );
        -: 8705:        void processNameChar( char c );
        -: 8706:        bool processOtherChar( char c );
        -: 8707:        void endMode();
        -: 8708:        void escape();
        -: 8709:        bool isControlChar( char c ) const;
        -: 8710:        void saveLastMode();
        -: 8711:        void revertBackToLastMode();
        -: 8712:        void addFilter();
        -: 8713:        bool separate();
        -: 8714:
        -: 8715:        // Handles common preprocessing of the pattern for name/tag patterns
        -: 8716:        std::string preprocessPattern();
        -: 8717:        // Adds the current pattern as a test name
        -: 8718:        void addNamePattern();
        -: 8719:        // Adds the current pattern as a tag
        -: 8720:        void addTagPattern();
        -: 8721:
    #####: 8722:        inline void addCharToPattern(char c) {
    #####: 8723:            m_substring += c;
    #####: 8724:            m_patternName += c;
    #####: 8725:            m_realPatternPos++;
    #####: 8726:        }
        -: 8727:
        -: 8728:    };
        -: 8729:    TestSpec parseTestSpec( std::string const& arg );
        -: 8730:
        -: 8731:} // namespace Catch
        -: 8732:
        -: 8733:#ifdef __clang__
        -: 8734:#pragma clang diagnostic pop
        -: 8735:#endif
        -: 8736:
        -: 8737:#endif // CATCH_TEST_SPEC_PARSER_HPP_INCLUDED
        -: 8738:
        -: 8739:
        -: 8740:#ifndef CATCH_TEXTFLOW_HPP_INCLUDED
        -: 8741:#define CATCH_TEXTFLOW_HPP_INCLUDED
        -: 8742:
        -: 8743:#include <cassert>
        -: 8744:#include <string>
        -: 8745:#include <vector>
        -: 8746:
        -: 8747:namespace Catch {
        -: 8748:    namespace TextFlow {
        -: 8749:
        -: 8750:        class Columns;
        -: 8751:
    #####: 8752:        class Column {
        -: 8753:            std::string m_string;
        -: 8754:            size_t m_width = CATCH_CONFIG_CONSOLE_WIDTH - 1;
        -: 8755:            size_t m_indent = 0;
        -: 8756:            size_t m_initialIndent = std::string::npos;
        -: 8757:
        -: 8758:        public:
        -: 8759:            class iterator {
        -: 8760:                friend Column;
        -: 8761:                struct EndTag {};
        -: 8762:
        -: 8763:                Column const& m_column;
        -: 8764:                size_t m_pos = 0;
        -: 8765:
        -: 8766:                size_t m_len = 0;
        -: 8767:                size_t m_end = 0;
        -: 8768:                bool m_suffix = false;
        -: 8769:
        -: 8770:                iterator( Column const& column, EndTag ):
    #####: 8771:                    m_column( column ), m_pos( m_column.m_string.size() ) {}
        -: 8772:
        -: 8773:                void calcLength();
        -: 8774:
        -: 8775:                // Returns current indention width
        -: 8776:                size_t indent() const;
        -: 8777:
        -: 8778:                // Creates an indented and (optionally) suffixed string from
        -: 8779:                // current iterator position, indentation and length.
        -: 8780:                std::string addIndentAndSuffix( size_t position,
        -: 8781:                                                size_t length ) const;
        -: 8782:
        -: 8783:            public:
        -: 8784:                using difference_type = std::ptrdiff_t;
        -: 8785:                using value_type = std::string;
        -: 8786:                using pointer = value_type*;
        -: 8787:                using reference = value_type&;
        -: 8788:                using iterator_category = std::forward_iterator_tag;
        -: 8789:
        -: 8790:                explicit iterator( Column const& column );
        -: 8791:
        -: 8792:                std::string operator*() const;
        -: 8793:
        -: 8794:                iterator& operator++();
        -: 8795:                iterator operator++( int );
        -: 8796:
        -: 8797:                bool operator==( iterator const& other ) const {
    #####: 8798:                    return m_pos == other.m_pos && &m_column == &other.m_column;
        -: 8799:                }
        -: 8800:                bool operator!=( iterator const& other ) const {
    #####: 8801:                    return !operator==( other );
        -: 8802:                }
        -: 8803:            };
        -: 8804:            using const_iterator = iterator;
        -: 8805:
    #####: 8806:            explicit Column( std::string const& text ): m_string( text ) {}
        -: 8807:
        -: 8808:            Column& width( size_t newWidth ) {
    #####: 8809:                assert( newWidth > 0 );
    #####: 8810:                m_width = newWidth;
        -: 8811:                return *this;
        -: 8812:            }
        -: 8813:            Column& indent( size_t newIndent ) {
    #####: 8814:                m_indent = newIndent;
        -: 8815:                return *this;
        -: 8816:            }
        -: 8817:            Column& initialIndent( size_t newIndent ) {
    #####: 8818:                m_initialIndent = newIndent;
        -: 8819:                return *this;
        -: 8820:            }
        -: 8821:
        -: 8822:            size_t width() const { return m_width; }
    #####: 8823:            iterator begin() const { return iterator( *this ); }
        -: 8824:            iterator end() const { return { *this, iterator::EndTag{} }; }
        -: 8825:
        -: 8826:            friend std::ostream& operator<<( std::ostream& os,
        -: 8827:                                             Column const& col );
        -: 8828:
        -: 8829:            Columns operator+( Column const& other );
        -: 8830:        };
        -: 8831:
        -: 8832:        //! Creates a column that serves as an empty space of specific width
        -: 8833:        Column Spacer( size_t spaceWidth );
        -: 8834:
    #####: 8835:        class Columns {
        -: 8836:            std::vector<Column> m_columns;
        -: 8837:
        -: 8838:        public:
    #####: 8839:            class iterator {
        -: 8840:                friend Columns;
        -: 8841:                struct EndTag {};
        -: 8842:
        -: 8843:                std::vector<Column> const& m_columns;
        -: 8844:                std::vector<Column::iterator> m_iterators;
        -: 8845:                size_t m_activeIterators;
        -: 8846:
        -: 8847:                iterator( Columns const& columns, EndTag );
        -: 8848:
        -: 8849:            public:
        -: 8850:                using difference_type = std::ptrdiff_t;
        -: 8851:                using value_type = std::string;
        -: 8852:                using pointer = value_type*;
        -: 8853:                using reference = value_type&;
        -: 8854:                using iterator_category = std::forward_iterator_tag;
        -: 8855:
        -: 8856:                explicit iterator( Columns const& columns );
        -: 8857:
        -: 8858:                auto operator==( iterator const& other ) const -> bool {
        -: 8859:                    return m_iterators == other.m_iterators;
        -: 8860:                }
        -: 8861:                auto operator!=( iterator const& other ) const -> bool {
        -: 8862:                    return m_iterators != other.m_iterators;
        -: 8863:                }
        -: 8864:                std::string operator*() const;
        -: 8865:                iterator& operator++();
        -: 8866:                iterator operator++( int );
        -: 8867:            };
        -: 8868:            using const_iterator = iterator;
        -: 8869:
    #####: 8870:            iterator begin() const { return iterator( *this ); }
    #####: 8871:            iterator end() const { return { *this, iterator::EndTag() }; }
        -: 8872:
        -: 8873:            Columns& operator+=( Column const& col );
        -: 8874:            Columns operator+( Column const& col );
        -: 8875:
        -: 8876:            friend std::ostream& operator<<( std::ostream& os,
        -: 8877:                                             Columns const& cols );
        -: 8878:        };
        -: 8879:
        -: 8880:    } // namespace TextFlow
        -: 8881:} // namespace Catch
        -: 8882:#endif // CATCH_TEXTFLOW_HPP_INCLUDED
        -: 8883:
        -: 8884:
        -: 8885:#ifndef CATCH_TO_STRING_HPP_INCLUDED
        -: 8886:#define CATCH_TO_STRING_HPP_INCLUDED
        -: 8887:
        -: 8888:#include <string>
        -: 8889:
        -: 8890:
        -: 8891:namespace Catch {
        -: 8892:    template <typename T>
        -: 8893:    std::string to_string(T const& t) {
        -: 8894:#if defined(CATCH_CONFIG_CPP11_TO_STRING)
        -: 8895:        return std::to_string(t);
        -: 8896:#else
        -: 8897:        ReusableStringStream rss;
        -: 8898:        rss << t;
        -: 8899:        return rss.str();
        -: 8900:#endif
        -: 8901:    }
        -: 8902:} // end namespace Catch
        -: 8903:
        -: 8904:#endif // CATCH_TO_STRING_HPP_INCLUDED
        -: 8905:
        -: 8906:
        -: 8907:#ifndef CATCH_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED
        -: 8908:#define CATCH_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED
        -: 8909:
        -: 8910:namespace Catch {
        -: 8911:    bool uncaught_exceptions();
        -: 8912:} // end namespace Catch
        -: 8913:
        -: 8914:#endif // CATCH_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED
        -: 8915:
        -: 8916:
        -: 8917:#ifndef CATCH_XMLWRITER_HPP_INCLUDED
        -: 8918:#define CATCH_XMLWRITER_HPP_INCLUDED
        -: 8919:
        -: 8920:
        -: 8921:// FixMe: Without this include (and something inside it), MSVC goes crazy
        -: 8922://        and reports that calls to XmlEncode's op << are ambiguous between
        -: 8923://        the declaration and definition.
        -: 8924://        It also has to be in the header.
        -: 8925:
        -: 8926:
        -: 8927:#include <vector>
        -: 8928:
        -: 8929:namespace Catch {
        -: 8930:    enum class XmlFormatting {
        -: 8931:        None = 0x00,
        -: 8932:        Indent = 0x01,
        -: 8933:        Newline = 0x02,
        -: 8934:    };
        -: 8935:
        -: 8936:    XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs);
        -: 8937:    XmlFormatting operator & (XmlFormatting lhs, XmlFormatting rhs);
        -: 8938:
    #####: 8939:    class XmlEncode {
        -: 8940:    public:
        -: 8941:        enum ForWhat { ForTextNodes, ForAttributes };
        -: 8942:
        -: 8943:        XmlEncode( std::string const& str, ForWhat forWhat = ForTextNodes );
        -: 8944:
        -: 8945:        void encodeTo( std::ostream& os ) const;
        -: 8946:
        -: 8947:        friend std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode );
        -: 8948:
        -: 8949:    private:
        -: 8950:        std::string m_str;
        -: 8951:        ForWhat m_forWhat;
        -: 8952:    };
        -: 8953:
        -: 8954:    class XmlWriter {
        -: 8955:    public:
        -: 8956:
        -: 8957:        class ScopedElement {
        -: 8958:        public:
        -: 8959:            ScopedElement( XmlWriter* writer, XmlFormatting fmt );
        -: 8960:
        -: 8961:            ScopedElement( ScopedElement&& other ) noexcept;
        -: 8962:            ScopedElement& operator=( ScopedElement&& other ) noexcept;
        -: 8963:
        -: 8964:            ~ScopedElement();
        -: 8965:
        -: 8966:            ScopedElement& writeText( std::string const& text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent );
        -: 8967:
        -: 8968:            template<typename T>
        -: 8969:            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {
    #####: 8970:                m_writer->writeAttribute( name, attribute );
        -: 8971:                return *this;
        -: 8972:            }
        -: 8973:
        -: 8974:        private:
        -: 8975:            mutable XmlWriter* m_writer = nullptr;
        -: 8976:            XmlFormatting m_fmt;
        -: 8977:        };
        -: 8978:
        -: 8979:        XmlWriter( std::ostream& os = Catch::cout() );
        -: 8980:        ~XmlWriter();
        -: 8981:
        -: 8982:        XmlWriter( XmlWriter const& ) = delete;
        -: 8983:        XmlWriter& operator=( XmlWriter const& ) = delete;
        -: 8984:
        -: 8985:        XmlWriter& startElement( std::string const& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
        -: 8986:
        -: 8987:        ScopedElement scopedElement( std::string const& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
        -: 8988:
        -: 8989:        XmlWriter& endElement(XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
        -: 8990:
        -: 8991:        XmlWriter& writeAttribute( std::string const& name, std::string const& attribute );
        -: 8992:
        -: 8993:        XmlWriter& writeAttribute( std::string const& name, bool attribute );
        -: 8994:
        -: 8995:        template<typename T>
    #####: 8996:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####: 8997:            ReusableStringStream rss;
        -: 8998:            rss << attribute;
    #####: 8999:            return writeAttribute( name, rss.str() );
        -: 9000:        }
        -: 9001:
        -: 9002:        XmlWriter& writeText( std::string const& text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
        -: 9003:
        -: 9004:        XmlWriter& writeComment(std::string const& text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
        -: 9005:
        -: 9006:        void writeStylesheetRef( std::string const& url );
        -: 9007:
        -: 9008:        XmlWriter& writeBlankLine();
        -: 9009:
        -: 9010:        void ensureTagClosed();
        -: 9011:
        -: 9012:    private:
        -: 9013:
        -: 9014:        void applyFormatting(XmlFormatting fmt);
        -: 9015:
        -: 9016:        void writeDeclaration();
        -: 9017:
        -: 9018:        void newlineIfNecessary();
        -: 9019:
        -: 9020:        bool m_tagIsOpen = false;
        -: 9021:        bool m_needsNewline = false;
        -: 9022:        std::vector<std::string> m_tags;
        -: 9023:        std::string m_indent;
        -: 9024:        std::ostream& m_os;
        -: 9025:    };
        -: 9026:
        -: 9027:}
        -: 9028:
        -: 9029:#endif // CATCH_XMLWRITER_HPP_INCLUDED
        -: 9030:
        -: 9031:
        -: 9032:/** \file
        -: 9033: * This is a convenience header for Catch2's Matcher support. It includes
        -: 9034: * **all** of Catch2 headers related to matchers.
        -: 9035: *
        -: 9036: * Generally the Catch2 users should use specific includes they need,
        -: 9037: * but this header can be used instead for ease-of-experimentation, or
        -: 9038: * just plain convenience, at the cost of increased compilation times.
        -: 9039: *
        -: 9040: * When a new header is added to either the `matchers` folder, or to
        -: 9041: * the corresponding internal subfolder, it should be added here.
        -: 9042: */
        -: 9043:
        -: 9044:#ifndef CATCH_MATCHERS_ALL_HPP_INCLUDED
        -: 9045:#define CATCH_MATCHERS_ALL_HPP_INCLUDED
        -: 9046:
        -: 9047:
        -: 9048:
        -: 9049:#ifndef CATCH_MATCHERS_HPP_INCLUDED
        -: 9050:#define CATCH_MATCHERS_HPP_INCLUDED
        -: 9051:
        -: 9052:
        -: 9053:
        -: 9054:#ifndef CATCH_MATCHERS_IMPL_HPP_INCLUDED
        -: 9055:#define CATCH_MATCHERS_IMPL_HPP_INCLUDED
        -: 9056:
        -: 9057:
        -: 9058:namespace Catch {
        -: 9059:
        -: 9060:    template<typename ArgT, typename MatcherT>
    #####: 9061:    class MatchExpr : public ITransientExpression {
        -: 9062:        ArgT && m_arg;
        -: 9063:        MatcherT const& m_matcher;
        -: 9064:        StringRef m_matcherString;
        -: 9065:    public:
        -: 9066:        MatchExpr( ArgT && arg, MatcherT const& matcher, StringRef const& matcherString )
        -: 9067:        :   ITransientExpression{ true, matcher.match( arg ) }, // not forwarding arg here on purpose
        -: 9068:            m_arg( std::forward<ArgT>(arg) ),
        -: 9069:            m_matcher( matcher ),
    #####: 9070:            m_matcherString( matcherString )
        -: 9071:        {}
        -: 9072:
    #####: 9073:        void streamReconstructedExpression( std::ostream &os ) const override {
    #####: 9074:            auto matcherAsString = m_matcher.toString();
    #####: 9075:            os << Catch::Detail::stringify( m_arg ) << ' ';
    #####: 9076:            if( matcherAsString == Detail::unprintableString )
        -: 9077:                os << m_matcherString;
        -: 9078:            else
        -: 9079:                os << matcherAsString;
    #####: 9080:        }
        -: 9081:    };
        -: 9082:
        -: 9083:    namespace Matchers {
        -: 9084:        template <typename ArgT>
        -: 9085:        struct MatcherBase;
        -: 9086:    }
        -: 9087:
        -: 9088:    using StringMatcher = Matchers::MatcherBase<std::string>;
        -: 9089:
        -: 9090:    void handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher const& matcher, StringRef const& matcherString  );
        -: 9091:
        -: 9092:    template<typename ArgT, typename MatcherT>
        -: 9093:    auto makeMatchExpr( ArgT && arg, MatcherT const& matcher, StringRef const& matcherString  ) -> MatchExpr<ArgT, MatcherT> {
        -: 9094:        return MatchExpr<ArgT, MatcherT>( std::forward<ArgT>(arg), matcher, matcherString );
        -: 9095:    }
        -: 9096:
        -: 9097:} // namespace Catch
        -: 9098:
        -: 9099:
        -: 9100:///////////////////////////////////////////////////////////////////////////////
        -: 9101:#define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \
        -: 9102:    do { \
        -: 9103:        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
        -: 9104:        INTERNAL_CATCH_TRY { \
        -: 9105:            catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher, #matcher##_catch_sr ) ); \
        -: 9106:        } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \
        -: 9107:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 9108:    } while( false )
        -: 9109:
        -: 9110:
        -: 9111:///////////////////////////////////////////////////////////////////////////////
        -: 9112:#define INTERNAL_CATCH_THROWS_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \
        -: 9113:    do { \
        -: 9114:        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(exceptionType) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
        -: 9115:        if( catchAssertionHandler.allowThrows() ) \
        -: 9116:            try { \
        -: 9117:                static_cast<void>(__VA_ARGS__ ); \
        -: 9118:                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
        -: 9119:            } \
        -: 9120:            catch( exceptionType const& ex ) { \
        -: 9121:                catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher, #matcher##_catch_sr ) ); \
        -: 9122:            } \
        -: 9123:            catch( ... ) { \
        -: 9124:                catchAssertionHandler.handleUnexpectedInflightException(); \
        -: 9125:            } \
        -: 9126:        else \
        -: 9127:            catchAssertionHandler.handleThrowingCallSkipped(); \
        -: 9128:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 9129:    } while( false )
        -: 9130:
        -: 9131:
        -: 9132:#endif // CATCH_MATCHERS_IMPL_HPP_INCLUDED
        -: 9133:
        -: 9134:#include <string>
        -: 9135:#include <vector>
        -: 9136:
        -: 9137:namespace Catch {
        -: 9138:namespace Matchers {
        -: 9139:
    #####: 9140:    class MatcherUntypedBase {
        -: 9141:    public:
    #####: 9142:        MatcherUntypedBase() = default;
        -: 9143:
        -: 9144:        MatcherUntypedBase(MatcherUntypedBase const&) = default;
        -: 9145:        MatcherUntypedBase(MatcherUntypedBase&&) = default;
        -: 9146:
        -: 9147:        MatcherUntypedBase& operator = (MatcherUntypedBase const&) = delete;
        -: 9148:        MatcherUntypedBase& operator = (MatcherUntypedBase&&) = delete;
        -: 9149:
        -: 9150:        std::string toString() const;
        -: 9151:
        -: 9152:    protected:
        -: 9153:        virtual ~MatcherUntypedBase(); // = default;
        -: 9154:        virtual std::string describe() const = 0;
        -: 9155:        mutable std::string m_cachedToString;
        -: 9156:    };
        -: 9157:
        -: 9158:#ifdef __clang__
        -: 9159:#    pragma clang diagnostic push
        -: 9160:#    pragma clang diagnostic ignored "-Wnon-virtual-dtor"
        -: 9161:#endif
        -: 9162:
        -: 9163:    template<typename ObjectT>
    #####: 9164:    struct MatcherMethod {
        -: 9165:        virtual bool match(ObjectT const& arg) const = 0;
        -: 9166:    };
        -: 9167:
        -: 9168:#ifdef __clang__
        -: 9169:#    pragma clang diagnostic pop
        -: 9170:#endif
        -: 9171:
        -: 9172:    template<typename T>
    #####: 9173:    struct MatcherBase : MatcherUntypedBase, MatcherMethod<T> {};
        -: 9174:
        -: 9175:    namespace Detail {
        -: 9176:
        -: 9177:        template<typename ArgT>
        -: 9178:        struct MatchAllOf final : MatcherBase<ArgT> {
        -: 9179:            MatchAllOf() = default;
        -: 9180:            MatchAllOf(MatchAllOf const&) = delete;
        -: 9181:            MatchAllOf& operator=(MatchAllOf const&) = delete;
        -: 9182:            MatchAllOf(MatchAllOf&&) = default;
        -: 9183:            MatchAllOf& operator=(MatchAllOf&&) = default;
        -: 9184:
        -: 9185:
        -: 9186:            bool match( ArgT const& arg ) const override {
        -: 9187:                for( auto matcher : m_matchers ) {
        -: 9188:                    if (!matcher->match(arg))
        -: 9189:                        return false;
        -: 9190:                }
        -: 9191:                return true;
        -: 9192:            }
        -: 9193:            std::string describe() const override {
        -: 9194:                std::string description;
        -: 9195:                description.reserve( 4 + m_matchers.size()*32 );
        -: 9196:                description += "( ";
        -: 9197:                bool first = true;
        -: 9198:                for( auto matcher : m_matchers ) {
        -: 9199:                    if( first )
        -: 9200:                        first = false;
        -: 9201:                    else
        -: 9202:                        description += " and ";
        -: 9203:                    description += matcher->toString();
        -: 9204:                }
        -: 9205:                description += " )";
        -: 9206:                return description;
        -: 9207:            }
        -: 9208:
        -: 9209:            friend MatchAllOf operator&& (MatchAllOf&& lhs, MatcherBase<ArgT> const& rhs) {
        -: 9210:                lhs.m_matchers.push_back(&rhs);
        -: 9211:                return std::move(lhs);
        -: 9212:            }
        -: 9213:            friend MatchAllOf operator&& (MatcherBase<ArgT> const& lhs, MatchAllOf&& rhs) {
        -: 9214:                rhs.m_matchers.insert(rhs.m_matchers.begin(), &lhs);
        -: 9215:                return std::move(rhs);
        -: 9216:            }
        -: 9217:
        -: 9218:        private:
        -: 9219:            std::vector<MatcherBase<ArgT> const*> m_matchers;
        -: 9220:        };
        -: 9221:
        -: 9222:        //! lvalue overload is intentionally deleted, users should
        -: 9223:        //! not be trying to compose stored composition matchers
        -: 9224:        template<typename ArgT>
        -: 9225:        MatchAllOf<ArgT> operator&& (MatchAllOf<ArgT> const& lhs, MatcherBase<ArgT> const& rhs) = delete;
        -: 9226:        //! lvalue overload is intentionally deleted, users should
        -: 9227:        //! not be trying to compose stored composition matchers
        -: 9228:        template<typename ArgT>
        -: 9229:        MatchAllOf<ArgT> operator&& (MatcherBase<ArgT> const& lhs, MatchAllOf<ArgT> const& rhs) = delete;
        -: 9230:
        -: 9231:        template<typename ArgT>
        -: 9232:        struct MatchAnyOf final : MatcherBase<ArgT> {
        -: 9233:            MatchAnyOf() = default;
        -: 9234:            MatchAnyOf(MatchAnyOf const&) = delete;
        -: 9235:            MatchAnyOf& operator=(MatchAnyOf const&) = delete;
        -: 9236:            MatchAnyOf(MatchAnyOf&&) = default;
        -: 9237:            MatchAnyOf& operator=(MatchAnyOf&&) = default;
        -: 9238:
        -: 9239:            bool match( ArgT const& arg ) const override {
        -: 9240:                for( auto matcher : m_matchers ) {
        -: 9241:                    if (matcher->match(arg))
        -: 9242:                        return true;
        -: 9243:                }
        -: 9244:                return false;
        -: 9245:            }
        -: 9246:            std::string describe() const override {
        -: 9247:                std::string description;
        -: 9248:                description.reserve( 4 + m_matchers.size()*32 );
        -: 9249:                description += "( ";
        -: 9250:                bool first = true;
        -: 9251:                for( auto matcher : m_matchers ) {
        -: 9252:                    if( first )
        -: 9253:                        first = false;
        -: 9254:                    else
        -: 9255:                        description += " or ";
        -: 9256:                    description += matcher->toString();
        -: 9257:                }
        -: 9258:                description += " )";
        -: 9259:                return description;
        -: 9260:            }
        -: 9261:
        -: 9262:            friend MatchAnyOf operator|| (MatchAnyOf&& lhs, MatcherBase<ArgT> const& rhs) {
        -: 9263:                lhs.m_matchers.push_back(&rhs);
        -: 9264:                return std::move(lhs);
        -: 9265:            }
        -: 9266:            friend MatchAnyOf operator|| (MatcherBase<ArgT> const& lhs, MatchAnyOf&& rhs) {
        -: 9267:                rhs.m_matchers.insert(rhs.m_matchers.begin(), &lhs);
        -: 9268:                return std::move(rhs);
        -: 9269:            }
        -: 9270:
        -: 9271:        private:
        -: 9272:            std::vector<MatcherBase<ArgT> const*> m_matchers;
        -: 9273:        };
        -: 9274:
        -: 9275:        //! lvalue overload is intentionally deleted, users should
        -: 9276:        //! not be trying to compose stored composition matchers
        -: 9277:        template<typename ArgT>
        -: 9278:        MatchAnyOf<ArgT> operator|| (MatchAnyOf<ArgT> const& lhs, MatcherBase<ArgT> const& rhs) = delete;
        -: 9279:        //! lvalue overload is intentionally deleted, users should
        -: 9280:        //! not be trying to compose stored composition matchers
        -: 9281:        template<typename ArgT>
        -: 9282:        MatchAnyOf<ArgT> operator|| (MatcherBase<ArgT> const& lhs, MatchAnyOf<ArgT> const& rhs) = delete;
        -: 9283:
        -: 9284:        template<typename ArgT>
        -: 9285:        struct MatchNotOf final : MatcherBase<ArgT> {
        -: 9286:
        -: 9287:            explicit MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ):
        -: 9288:                m_underlyingMatcher( underlyingMatcher )
        -: 9289:            {}
        -: 9290:
        -: 9291:            bool match( ArgT const& arg ) const override {
        -: 9292:                return !m_underlyingMatcher.match( arg );
        -: 9293:            }
        -: 9294:
        -: 9295:            std::string describe() const override {
        -: 9296:                return "not " + m_underlyingMatcher.toString();
        -: 9297:            }
        -: 9298:
        -: 9299:        private:
        -: 9300:            MatcherBase<ArgT> const& m_underlyingMatcher;
        -: 9301:        };
        -: 9302:
        -: 9303:    } // namespace Detail
        -: 9304:
        -: 9305:    template <typename T>
        -: 9306:    Detail::MatchAllOf<T> operator&& (MatcherBase<T> const& lhs, MatcherBase<T> const& rhs) {
        -: 9307:        return Detail::MatchAllOf<T>{} && lhs && rhs;
        -: 9308:    }
        -: 9309:    template <typename T>
        -: 9310:    Detail::MatchAnyOf<T> operator|| (MatcherBase<T> const& lhs, MatcherBase<T> const& rhs) {
        -: 9311:        return Detail::MatchAnyOf<T>{} || lhs || rhs;
        -: 9312:    }
        -: 9313:
        -: 9314:    template <typename T>
        -: 9315:    Detail::MatchNotOf<T> operator! (MatcherBase<T> const& matcher) {
        -: 9316:        return Detail::MatchNotOf<T>{ matcher };
        -: 9317:    }
        -: 9318:
        -: 9319:
        -: 9320:} // namespace Matchers
        -: 9321:} // namespace Catch
        -: 9322:
        -: 9323:
        -: 9324:#if defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)
        -: 9325:  #define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )
        -: 9326:  #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
        -: 9327:
        -: 9328:  #define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
        -: 9329:  #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
        -: 9330:
        -: 9331:  #define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
        -: 9332:  #define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )
        -: 9333:
        -: 9334:#elif defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)
        -: 9335:
        -: 9336:  #define CATCH_REQUIRE_THROWS_WITH( expr, matcher )                   (void)(0)
        -: 9337:  #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
        -: 9338:
        -: 9339:  #define CATCH_CHECK_THROWS_WITH( expr, matcher )                     (void)(0)
        -: 9340:  #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher )   (void)(0)
        -: 9341:
        -: 9342:  #define CATCH_CHECK_THAT( arg, matcher )                             (void)(0)
        -: 9343:  #define CATCH_REQUIRE_THAT( arg, matcher )                           (void)(0)
        -: 9344:
        -: 9345:#elif !defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)
        -: 9346:
        -: 9347:  #define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )
        -: 9348:  #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
        -: 9349:
        -: 9350:  #define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
        -: 9351:  #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
        -: 9352:
        -: 9353:  #define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
        -: 9354:  #define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )
        -: 9355:
        -: 9356:#elif !defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)
        -: 9357:
        -: 9358:  #define REQUIRE_THROWS_WITH( expr, matcher )                   (void)(0)
        -: 9359:  #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
        -: 9360:
        -: 9361:  #define CHECK_THROWS_WITH( expr, matcher )                     (void)(0)
        -: 9362:  #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher )   (void)(0)
        -: 9363:
        -: 9364:  #define CHECK_THAT( arg, matcher )                             (void)(0)
        -: 9365:  #define REQUIRE_THAT( arg, matcher )                           (void)(0)
        -: 9366:
        -: 9367:#endif // end of user facing macro declarations
        -: 9368:
        -: 9369:#endif // CATCH_MATCHERS_HPP_INCLUDED
        -: 9370:
        -: 9371:
        -: 9372:#ifndef CATCH_MATCHERS_CONTAINER_PROPERTIES_HPP_INCLUDED
        -: 9373:#define CATCH_MATCHERS_CONTAINER_PROPERTIES_HPP_INCLUDED
        -: 9374:
        -: 9375:
        -: 9376:
        -: 9377:#ifndef CATCH_MATCHERS_TEMPLATED_HPP_INCLUDED
        -: 9378:#define CATCH_MATCHERS_TEMPLATED_HPP_INCLUDED
        -: 9379:
        -: 9380:
        -: 9381:#include <array>
        -: 9382:#include <algorithm>
        -: 9383:#include <string>
        -: 9384:#include <type_traits>
        -: 9385:#include <utility>
        -: 9386:
        -: 9387:namespace Catch {
        -: 9388:namespace Matchers {
    #####: 9389:    struct MatcherGenericBase : MatcherUntypedBase {
    #####: 9390:        MatcherGenericBase() = default;
        -: 9391:        virtual ~MatcherGenericBase(); // = default;
        -: 9392:
        -: 9393:        MatcherGenericBase(MatcherGenericBase&) = default;
        -: 9394:        MatcherGenericBase(MatcherGenericBase&&) = default;
        -: 9395:
        -: 9396:        MatcherGenericBase& operator=(MatcherGenericBase const&) = delete;
        -: 9397:        MatcherGenericBase& operator=(MatcherGenericBase&&) = delete;
        -: 9398:    };
        -: 9399:
        -: 9400:
        -: 9401:    namespace Detail {
        -: 9402:        template<std::size_t N, std::size_t M>
        -: 9403:        std::array<void const*, N + M> array_cat(std::array<void const*, N> && lhs, std::array<void const*, M> && rhs) {
        -: 9404:            std::array<void const*, N + M> arr{};
        -: 9405:            std::copy_n(lhs.begin(), N, arr.begin());
        -: 9406:            std::copy_n(rhs.begin(), M, arr.begin() + N);
        -: 9407:            return arr;
        -: 9408:        }
        -: 9409:
        -: 9410:        template<std::size_t N>
        -: 9411:        std::array<void const*, N+1> array_cat(std::array<void const*, N> && lhs, void const* rhs) {
        -: 9412:            std::array<void const*, N+1> arr{};
        -: 9413:            std::copy_n(lhs.begin(), N, arr.begin());
        -: 9414:            arr[N] = rhs;
        -: 9415:            return arr;
        -: 9416:        }
        -: 9417:
        -: 9418:        template<std::size_t N>
        -: 9419:        std::array<void const*, N+1> array_cat(void const* lhs, std::array<void const*, N> && rhs) {
        -: 9420:            std::array<void const*, N + 1> arr{ {lhs} };
        -: 9421:            std::copy_n(rhs.begin(), N, arr.begin() + 1);
        -: 9422:            return arr;
        -: 9423:        }
        -: 9424:
        -: 9425:        #ifdef CATCH_CPP17_OR_GREATER
        -: 9426:
        -: 9427:        using std::conjunction;
        -: 9428:
        -: 9429:        #else // CATCH_CPP17_OR_GREATER
        -: 9430:
        -: 9431:        template<typename... Cond>
        -: 9432:        struct conjunction : std::true_type {};
        -: 9433:
        -: 9434:        template<typename Cond, typename... Rest>
        -: 9435:        struct conjunction<Cond, Rest...> : std::integral_constant<bool, Cond::value && conjunction<Rest...>::value> {};
        -: 9436:
        -: 9437:        #endif // CATCH_CPP17_OR_GREATER
        -: 9438:
        -: 9439:        template<typename T>
        -: 9440:        using is_generic_matcher = std::is_base_of<
        -: 9441:            Catch::Matchers::MatcherGenericBase,
        -: 9442:            std::remove_cv_t<std::remove_reference_t<T>>
        -: 9443:        >;
        -: 9444:
        -: 9445:        template<typename... Ts>
        -: 9446:        using are_generic_matchers = conjunction<is_generic_matcher<Ts>...>;
        -: 9447:
        -: 9448:        template<typename T>
        -: 9449:        using is_matcher = std::is_base_of<
        -: 9450:            Catch::Matchers::MatcherUntypedBase,
        -: 9451:            std::remove_cv_t<std::remove_reference_t<T>>
        -: 9452:        >;
        -: 9453:
        -: 9454:
        -: 9455:        template<std::size_t N, typename Arg>
        -: 9456:        bool match_all_of(Arg&&, std::array<void const*, N> const&, std::index_sequence<>) {
        -: 9457:            return true;
        -: 9458:        }
        -: 9459:
        -: 9460:        template<typename T, typename... MatcherTs, std::size_t N, typename Arg, std::size_t Idx, std::size_t... Indices>
        -: 9461:        bool match_all_of(Arg&& arg, std::array<void const*, N> const& matchers, std::index_sequence<Idx, Indices...>) {
        -: 9462:            return static_cast<T const*>(matchers[Idx])->match(arg) && match_all_of<MatcherTs...>(arg, matchers, std::index_sequence<Indices...>{});
        -: 9463:        }
        -: 9464:
        -: 9465:
        -: 9466:        template<std::size_t N, typename Arg>
        -: 9467:        bool match_any_of(Arg&&, std::array<void const*, N> const&, std::index_sequence<>) {
        -: 9468:            return false;
        -: 9469:        }
        -: 9470:
        -: 9471:        template<typename T, typename... MatcherTs, std::size_t N, typename Arg, std::size_t Idx, std::size_t... Indices>
        -: 9472:        bool match_any_of(Arg&& arg, std::array<void const*, N> const& matchers, std::index_sequence<Idx, Indices...>) {
        -: 9473:            return static_cast<T const*>(matchers[Idx])->match(arg) || match_any_of<MatcherTs...>(arg, matchers, std::index_sequence<Indices...>{});
        -: 9474:        }
        -: 9475:
        -: 9476:        std::string describe_multi_matcher(StringRef combine, std::string const* descriptions_begin, std::string const* descriptions_end);
        -: 9477:
        -: 9478:        template<typename... MatcherTs, std::size_t... Idx>
        -: 9479:        std::string describe_multi_matcher(StringRef combine, std::array<void const*, sizeof...(MatcherTs)> const& matchers, std::index_sequence<Idx...>) {
        -: 9480:            std::array<std::string, sizeof...(MatcherTs)> descriptions {{
        -: 9481:                static_cast<MatcherTs const*>(matchers[Idx])->toString()...
        -: 9482:            }};
        -: 9483:
        -: 9484:            return describe_multi_matcher(combine, descriptions.data(), descriptions.data() + descriptions.size());
        -: 9485:        }
        -: 9486:
        -: 9487:
        -: 9488:        template<typename... MatcherTs>
        -: 9489:        struct MatchAllOfGeneric final : MatcherGenericBase {
        -: 9490:            MatchAllOfGeneric(MatchAllOfGeneric const&) = delete;
        -: 9491:            MatchAllOfGeneric& operator=(MatchAllOfGeneric const&) = delete;
        -: 9492:            MatchAllOfGeneric(MatchAllOfGeneric&&) = default;
        -: 9493:            MatchAllOfGeneric& operator=(MatchAllOfGeneric&&) = default;
        -: 9494:
        -: 9495:            MatchAllOfGeneric(MatcherTs const&... matchers) : m_matchers{ {std::addressof(matchers)...} } {}
        -: 9496:            explicit MatchAllOfGeneric(std::array<void const*, sizeof...(MatcherTs)> matchers) : m_matchers{matchers} {}
        -: 9497:
        -: 9498:            template<typename Arg>
        -: 9499:            bool match(Arg&& arg) const {
        -: 9500:                return match_all_of<MatcherTs...>(arg, m_matchers, std::index_sequence_for<MatcherTs...>{});
        -: 9501:            }
        -: 9502:
        -: 9503:            std::string describe() const override {
        -: 9504:                return describe_multi_matcher<MatcherTs...>(" and "_sr, m_matchers, std::index_sequence_for<MatcherTs...>{});
        -: 9505:            }
        -: 9506:
        -: 9507:            std::array<void const*, sizeof...(MatcherTs)> m_matchers;
        -: 9508:
        -: 9509:            //! Avoids type nesting for `GenericAllOf && GenericAllOf` case
        -: 9510:            template<typename... MatchersRHS>
        -: 9511:            friend
        -: 9512:            MatchAllOfGeneric<MatcherTs..., MatchersRHS...> operator && (
        -: 9513:                    MatchAllOfGeneric<MatcherTs...>&& lhs,
        -: 9514:                    MatchAllOfGeneric<MatchersRHS...>&& rhs) {
        -: 9515:                return MatchAllOfGeneric<MatcherTs..., MatchersRHS...>{array_cat(std::move(lhs.m_matchers), std::move(rhs.m_matchers))};
        -: 9516:            }
        -: 9517:
        -: 9518:            //! Avoids type nesting for `GenericAllOf && some matcher` case
        -: 9519:            template<typename MatcherRHS>
        -: 9520:            friend std::enable_if_t<is_matcher<MatcherRHS>::value,
        -: 9521:            MatchAllOfGeneric<MatcherTs..., MatcherRHS>> operator && (
        -: 9522:                    MatchAllOfGeneric<MatcherTs...>&& lhs,
        -: 9523:                    MatcherRHS const& rhs) {
        -: 9524:                return MatchAllOfGeneric<MatcherTs..., MatcherRHS>{array_cat(std::move(lhs.m_matchers), static_cast<void const*>(&rhs))};
        -: 9525:            }
        -: 9526:
        -: 9527:            //! Avoids type nesting for `some matcher && GenericAllOf` case
        -: 9528:            template<typename MatcherLHS>
        -: 9529:            friend std::enable_if_t<is_matcher<MatcherLHS>::value,
        -: 9530:            MatchAllOfGeneric<MatcherLHS, MatcherTs...>> operator && (
        -: 9531:                    MatcherLHS const& lhs,
        -: 9532:                    MatchAllOfGeneric<MatcherTs...>&& rhs) {
        -: 9533:                return MatchAllOfGeneric<MatcherLHS, MatcherTs...>{array_cat(static_cast<void const*>(std::addressof(lhs)), std::move(rhs.m_matchers))};
        -: 9534:            }
        -: 9535:        };
        -: 9536:
        -: 9537:
        -: 9538:        template<typename... MatcherTs>
        -: 9539:        struct MatchAnyOfGeneric final : MatcherGenericBase {
        -: 9540:            MatchAnyOfGeneric(MatchAnyOfGeneric const&) = delete;
        -: 9541:            MatchAnyOfGeneric& operator=(MatchAnyOfGeneric const&) = delete;
        -: 9542:            MatchAnyOfGeneric(MatchAnyOfGeneric&&) = default;
        -: 9543:            MatchAnyOfGeneric& operator=(MatchAnyOfGeneric&&) = default;
        -: 9544:
        -: 9545:            MatchAnyOfGeneric(MatcherTs const&... matchers) : m_matchers{ {std::addressof(matchers)...} } {}
        -: 9546:            explicit MatchAnyOfGeneric(std::array<void const*, sizeof...(MatcherTs)> matchers) : m_matchers{matchers} {}
        -: 9547:
        -: 9548:            template<typename Arg>
        -: 9549:            bool match(Arg&& arg) const {
        -: 9550:                return match_any_of<MatcherTs...>(arg, m_matchers, std::index_sequence_for<MatcherTs...>{});
        -: 9551:            }
        -: 9552:
        -: 9553:            std::string describe() const override {
        -: 9554:                return describe_multi_matcher<MatcherTs...>(" or "_sr, m_matchers, std::index_sequence_for<MatcherTs...>{});
        -: 9555:            }
        -: 9556:
        -: 9557:            std::array<void const*, sizeof...(MatcherTs)> m_matchers;
        -: 9558:
        -: 9559:            //! Avoids type nesting for `GenericAnyOf || GenericAnyOf` case
        -: 9560:            template<typename... MatchersRHS>
        -: 9561:            friend MatchAnyOfGeneric<MatcherTs..., MatchersRHS...> operator || (
        -: 9562:                    MatchAnyOfGeneric<MatcherTs...>&& lhs,
        -: 9563:                    MatchAnyOfGeneric<MatchersRHS...>&& rhs) {
        -: 9564:                return MatchAnyOfGeneric<MatcherTs..., MatchersRHS...>{array_cat(std::move(lhs.m_matchers), std::move(rhs.m_matchers))};
        -: 9565:            }
        -: 9566:
        -: 9567:            //! Avoids type nesting for `GenericAnyOf || some matcher` case
        -: 9568:            template<typename MatcherRHS>
        -: 9569:            friend std::enable_if_t<is_matcher<MatcherRHS>::value,
        -: 9570:            MatchAnyOfGeneric<MatcherTs..., MatcherRHS>> operator || (
        -: 9571:                    MatchAnyOfGeneric<MatcherTs...>&& lhs,
        -: 9572:                    MatcherRHS const& rhs) {
        -: 9573:                return MatchAnyOfGeneric<MatcherTs..., MatcherRHS>{array_cat(std::move(lhs.m_matchers), static_cast<void const*>(std::addressof(rhs)))};
        -: 9574:            }
        -: 9575:
        -: 9576:            //! Avoids type nesting for `some matcher || GenericAnyOf` case
        -: 9577:            template<typename MatcherLHS>
        -: 9578:            friend std::enable_if_t<is_matcher<MatcherLHS>::value,
        -: 9579:            MatchAnyOfGeneric<MatcherLHS, MatcherTs...>> operator || (
        -: 9580:                MatcherLHS const& lhs,
        -: 9581:                MatchAnyOfGeneric<MatcherTs...>&& rhs) {
        -: 9582:                return MatchAnyOfGeneric<MatcherLHS, MatcherTs...>{array_cat(static_cast<void const*>(std::addressof(lhs)), std::move(rhs.m_matchers))};
        -: 9583:            }
        -: 9584:        };
        -: 9585:
        -: 9586:
        -: 9587:        template<typename MatcherT>
        -: 9588:        struct MatchNotOfGeneric final : MatcherGenericBase {
        -: 9589:            MatchNotOfGeneric(MatchNotOfGeneric const&) = delete;
        -: 9590:            MatchNotOfGeneric& operator=(MatchNotOfGeneric const&) = delete;
        -: 9591:            MatchNotOfGeneric(MatchNotOfGeneric&&) = default;
        -: 9592:            MatchNotOfGeneric& operator=(MatchNotOfGeneric&&) = default;
        -: 9593:
        -: 9594:            explicit MatchNotOfGeneric(MatcherT const& matcher) : m_matcher{matcher} {}
        -: 9595:
        -: 9596:            template<typename Arg>
        -: 9597:            bool match(Arg&& arg) const {
        -: 9598:                return !m_matcher.match(arg);
        -: 9599:            }
        -: 9600:
        -: 9601:            std::string describe() const override {
        -: 9602:                return "not " + m_matcher.toString();
        -: 9603:            }
        -: 9604:
        -: 9605:            //! Negating negation can just unwrap and return underlying matcher
        -: 9606:            friend MatcherT const& operator ! (MatchNotOfGeneric<MatcherT> const& matcher) {
        -: 9607:                return matcher.m_matcher;
        -: 9608:            }
        -: 9609:        private:
        -: 9610:            MatcherT const& m_matcher;
        -: 9611:        };
        -: 9612:    } // namespace Detail
        -: 9613:
        -: 9614:
        -: 9615:    // compose only generic matchers
        -: 9616:    template<typename MatcherLHS, typename MatcherRHS>
        -: 9617:    std::enable_if_t<Detail::are_generic_matchers<MatcherLHS, MatcherRHS>::value, Detail::MatchAllOfGeneric<MatcherLHS, MatcherRHS>>
        -: 9618:        operator && (MatcherLHS const& lhs, MatcherRHS const& rhs) {
        -: 9619:        return { lhs, rhs };
        -: 9620:    }
        -: 9621:
        -: 9622:    template<typename MatcherLHS, typename MatcherRHS>
        -: 9623:    std::enable_if_t<Detail::are_generic_matchers<MatcherLHS, MatcherRHS>::value, Detail::MatchAnyOfGeneric<MatcherLHS, MatcherRHS>>
        -: 9624:        operator || (MatcherLHS const& lhs, MatcherRHS const& rhs) {
        -: 9625:        return { lhs, rhs };
        -: 9626:    }
        -: 9627:
        -: 9628:    //! Wrap provided generic matcher in generic negator
        -: 9629:    template<typename MatcherT>
        -: 9630:    std::enable_if_t<Detail::is_generic_matcher<MatcherT>::value, Detail::MatchNotOfGeneric<MatcherT>>
        -: 9631:        operator ! (MatcherT const& matcher) {
        -: 9632:        return Detail::MatchNotOfGeneric<MatcherT>{matcher};
        -: 9633:    }
        -: 9634:
        -: 9635:
        -: 9636:    // compose mixed generic and non-generic matchers
        -: 9637:    template<typename MatcherLHS, typename ArgRHS>
        -: 9638:    std::enable_if_t<Detail::is_generic_matcher<MatcherLHS>::value, Detail::MatchAllOfGeneric<MatcherLHS, MatcherBase<ArgRHS>>>
        -: 9639:        operator && (MatcherLHS const& lhs, MatcherBase<ArgRHS> const& rhs) {
        -: 9640:        return { lhs, rhs };
        -: 9641:    }
        -: 9642:
        -: 9643:    template<typename ArgLHS, typename MatcherRHS>
        -: 9644:    std::enable_if_t<Detail::is_generic_matcher<MatcherRHS>::value, Detail::MatchAllOfGeneric<MatcherBase<ArgLHS>, MatcherRHS>>
        -: 9645:        operator && (MatcherBase<ArgLHS> const& lhs, MatcherRHS const& rhs) {
        -: 9646:        return { lhs, rhs };
        -: 9647:    }
        -: 9648:
        -: 9649:    template<typename MatcherLHS, typename ArgRHS>
        -: 9650:    std::enable_if_t<Detail::is_generic_matcher<MatcherLHS>::value, Detail::MatchAnyOfGeneric<MatcherLHS, MatcherBase<ArgRHS>>>
        -: 9651:        operator || (MatcherLHS const& lhs, MatcherBase<ArgRHS> const& rhs) {
        -: 9652:        return { lhs, rhs };
        -: 9653:    }
        -: 9654:
        -: 9655:    template<typename ArgLHS, typename MatcherRHS>
        -: 9656:    std::enable_if_t<Detail::is_generic_matcher<MatcherRHS>::value, Detail::MatchAnyOfGeneric<MatcherBase<ArgLHS>, MatcherRHS>>
        -: 9657:        operator || (MatcherBase<ArgLHS> const& lhs, MatcherRHS const& rhs) {
        -: 9658:        return { lhs, rhs };
        -: 9659:    }
        -: 9660:
        -: 9661:} // namespace Matchers
        -: 9662:} // namespace Catch
        -: 9663:
        -: 9664:#endif // CATCH_MATCHERS_TEMPLATED_HPP_INCLUDED
        -: 9665:
        -: 9666:namespace Catch {
        -: 9667:    namespace Matchers {
        -: 9668:
    #####: 9669:        class IsEmptyMatcher final : public MatcherGenericBase {
        -: 9670:        public:
        -: 9671:            // todo: Use polyfills
        -: 9672:            template <typename RangeLike>
        -: 9673:            bool match(RangeLike&& rng) const {
        -: 9674:#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)
        -: 9675:                using Catch::Detail::empty;
        -: 9676:#else
        -: 9677:                using std::empty;
        -: 9678:#endif
        -: 9679:                return empty(rng);
        -: 9680:            }
        -: 9681:
        -: 9682:            std::string describe() const override;
        -: 9683:        };
        -: 9684:
    #####: 9685:        class HasSizeMatcher final : public MatcherGenericBase {
        -: 9686:            std::size_t m_target_size;
        -: 9687:        public:
        -: 9688:            explicit HasSizeMatcher(std::size_t target_size):
    #####: 9689:                m_target_size(target_size)
        -: 9690:            {}
        -: 9691:
        -: 9692:            template <typename RangeLike>
        -: 9693:            bool match(RangeLike&& rng) const {
        -: 9694:#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)
        -: 9695:                using Catch::Detail::size;
        -: 9696:#else
        -: 9697:                using std::size;
        -: 9698:#endif
        -: 9699:                return size(rng) == m_target_size;
        -: 9700:            }
        -: 9701:
        -: 9702:            std::string describe() const override;
        -: 9703:        };
        -: 9704:
        -: 9705:        template <typename Matcher>
        -: 9706:        class SizeMatchesMatcher final : public MatcherGenericBase {
        -: 9707:            Matcher m_matcher;
        -: 9708:        public:
        -: 9709:            explicit SizeMatchesMatcher(Matcher m):
        -: 9710:                m_matcher(std::move(m))
        -: 9711:            {}
        -: 9712:
        -: 9713:            template <typename RangeLike>
        -: 9714:            bool match(RangeLike&& rng) const {
        -: 9715:#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)
        -: 9716:                using Catch::Detail::size;
        -: 9717:#else
        -: 9718:                using std::size;
        -: 9719:#endif
        -: 9720:                return m_matcher.match(size(rng));
        -: 9721:            }
        -: 9722:
        -: 9723:            std::string describe() const override {
        -: 9724:                return "size matches " + m_matcher.describe();
        -: 9725:            }
        -: 9726:        };
        -: 9727:
        -: 9728:
        -: 9729:        //! Creates a matcher that accepts empty ranges/containers
        -: 9730:        IsEmptyMatcher IsEmpty();
        -: 9731:        //! Creates a matcher that accepts ranges/containers with specific size
        -: 9732:        HasSizeMatcher SizeIs(std::size_t sz);
        -: 9733:        template <typename Matcher>
        -: 9734:        std::enable_if_t<Detail::is_matcher<Matcher>::value,
        -: 9735:        SizeMatchesMatcher<Matcher>> SizeIs(Matcher&& m) {
        -: 9736:            return SizeMatchesMatcher<Matcher>{std::forward<Matcher>(m)};
        -: 9737:        }
        -: 9738:
        -: 9739:    } // end namespace Matchers
        -: 9740:} // end namespace Catch
        -: 9741:
        -: 9742:#endif // CATCH_MATCHERS_CONTAINER_PROPERTIES_HPP_INCLUDED
        -: 9743:
        -: 9744:
        -: 9745:#ifndef CATCH_MATCHERS_CONTAINS_HPP_INCLUDED
        -: 9746:#define CATCH_MATCHERS_CONTAINS_HPP_INCLUDED
        -: 9747:
        -: 9748:
        -: 9749:#include <algorithm>
        -: 9750:#include <functional>
        -: 9751:#include <utility>
        -: 9752:
        -: 9753:namespace Catch {
        -: 9754:    namespace Matchers {
        -: 9755:        //! Matcher for checking that an element in range is equal to specific element
        -: 9756:        template <typename T, typename Equality>
        -: 9757:        class ContainsElementMatcher final : public MatcherGenericBase {
        -: 9758:            T m_desired;
        -: 9759:            Equality m_eq;
        -: 9760:        public:
        -: 9761:            template <typename T2, typename Equality2>
        -: 9762:            ContainsElementMatcher(T2&& target, Equality2&& predicate):
        -: 9763:                m_desired(std::forward<T2>(target)),
        -: 9764:                m_eq(std::forward<Equality2>(predicate))
        -: 9765:            {}
        -: 9766:
        -: 9767:            std::string describe() const override {
        -: 9768:                return "contains element " + Catch::Detail::stringify(m_desired);
        -: 9769:            }
        -: 9770:
        -: 9771:            template <typename RangeLike>
        -: 9772:            bool match(RangeLike&& rng) const {
        -: 9773:                using std::begin; using std::end;
        -: 9774:
        -: 9775:                return end(rng) != std::find_if(begin(rng), end(rng),
        -: 9776:                                               [&](auto const& elem) {
        -: 9777:                                                    return m_eq(elem, m_desired);
        -: 9778:                                               });
        -: 9779:            }
        -: 9780:        };
        -: 9781:
        -: 9782:        //! Meta-matcher for checking that an element in a range matches a specific matcher
        -: 9783:        template <typename Matcher>
        -: 9784:        class ContainsMatcherMatcher final : public MatcherGenericBase {
        -: 9785:            Matcher m_matcher;
        -: 9786:        public:
        -: 9787:            // Note that we do a copy+move to avoid having to SFINAE this
        -: 9788:            // constructor (and also avoid some perfect forwarding failure
        -: 9789:            // cases)
        -: 9790:            ContainsMatcherMatcher(Matcher matcher):
        -: 9791:                m_matcher(std::move(matcher))
        -: 9792:            {}
        -: 9793:
        -: 9794:            template <typename RangeLike>
        -: 9795:            bool match(RangeLike&& rng) const {
        -: 9796:                using std::begin; using std::endl;
        -: 9797:                for (auto&& elem : rng) {
        -: 9798:                    if (m_matcher.match(elem)) {
        -: 9799:                        return true;
        -: 9800:                    }
        -: 9801:                }
        -: 9802:                return false;
        -: 9803:            }
        -: 9804:
        -: 9805:            std::string describe() const override {
        -: 9806:                return "contains element matching " + m_matcher.describe();
        -: 9807:            }
        -: 9808:        };
        -: 9809:
        -: 9810:        /**
        -: 9811:         * Creates a matcher that checks whether a range contains a specific element.
        -: 9812:         *
        -: 9813:         * Uses `std::equal_to` to do the comparison
        -: 9814:         */
        -: 9815:        template <typename T>
        -: 9816:        std::enable_if_t<!Detail::is_matcher<T>::value,
        -: 9817:        ContainsElementMatcher<T, std::equal_to<>>> Contains(T&& elem) {
        -: 9818:            return { std::forward<T>(elem), std::equal_to<>{} };
        -: 9819:        }
        -: 9820:
        -: 9821:        //! Creates a matcher that checks whether a range contains element matching a matcher
        -: 9822:        template <typename Matcher>
        -: 9823:        std::enable_if_t<Detail::is_matcher<Matcher>::value,
        -: 9824:        ContainsMatcherMatcher<Matcher>> Contains(Matcher&& matcher) {
        -: 9825:            return { std::forward<Matcher>(matcher) };
        -: 9826:        }
        -: 9827:
        -: 9828:        /**
        -: 9829:         * Creates a matcher that checks whether a range contains a specific element.
        -: 9830:         *
        -: 9831:         * Uses `eq` to do the comparisons
        -: 9832:         */
        -: 9833:        template <typename T, typename Equality>
        -: 9834:        ContainsElementMatcher<T, Equality> Contains(T&& elem, Equality&& eq) {
        -: 9835:            return { std::forward<T>(elem), std::forward<Equality>(eq) };
        -: 9836:        }
        -: 9837:
        -: 9838:    }
        -: 9839:}
        -: 9840:
        -: 9841:#endif // CATCH_MATCHERS_CONTAINS_HPP_INCLUDED
        -: 9842:
        -: 9843:
        -: 9844:#ifndef CATCH_MATCHERS_EXCEPTION_HPP_INCLUDED
        -: 9845:#define CATCH_MATCHERS_EXCEPTION_HPP_INCLUDED
        -: 9846:
        -: 9847:
        -: 9848:namespace Catch {
        -: 9849:namespace Matchers {
        -: 9850:
    #####: 9851:class ExceptionMessageMatcher final : public MatcherBase<std::exception> {
        -: 9852:    std::string m_message;
        -: 9853:public:
        -: 9854:
    #####: 9855:    ExceptionMessageMatcher(std::string const& message):
    #####: 9856:        m_message(message)
    #####: 9857:    {}
        -: 9858:
        -: 9859:    bool match(std::exception const& ex) const override;
        -: 9860:
        -: 9861:    std::string describe() const override;
        -: 9862:};
        -: 9863:
        -: 9864://! Creates a matcher that checks whether a std derived exception has the provided message
        -: 9865:ExceptionMessageMatcher Message(std::string const& message);
        -: 9866:
        -: 9867:} // namespace Matchers
        -: 9868:} // namespace Catch
        -: 9869:
        -: 9870:#endif // CATCH_MATCHERS_EXCEPTION_HPP_INCLUDED
        -: 9871:
        -: 9872:
        -: 9873:#ifndef CATCH_MATCHERS_FLOATING_HPP_INCLUDED
        -: 9874:#define CATCH_MATCHERS_FLOATING_HPP_INCLUDED
        -: 9875:
        -: 9876:
        -: 9877:namespace Catch {
        -: 9878:namespace Matchers {
        -: 9879:
        -: 9880:    namespace Detail {
        -: 9881:        enum class FloatingPointKind : uint8_t;
        -: 9882:    }
        -: 9883:
    #####: 9884:    struct WithinAbsMatcher final : MatcherBase<double> {
        -: 9885:        WithinAbsMatcher(double target, double margin);
        -: 9886:        bool match(double const& matchee) const override;
        -: 9887:        std::string describe() const override;
        -: 9888:    private:
        -: 9889:        double m_target;
        -: 9890:        double m_margin;
        -: 9891:    };
        -: 9892:
    #####: 9893:    struct WithinUlpsMatcher final : MatcherBase<double> {
        -: 9894:        WithinUlpsMatcher(double target, uint64_t ulps, Detail::FloatingPointKind baseType);
        -: 9895:        bool match(double const& matchee) const override;
        -: 9896:        std::string describe() const override;
        -: 9897:    private:
        -: 9898:        double m_target;
        -: 9899:        uint64_t m_ulps;
        -: 9900:        Detail::FloatingPointKind m_type;
        -: 9901:    };
        -: 9902:
        -: 9903:    // Given IEEE-754 format for floats and doubles, we can assume
        -: 9904:    // that float -> double promotion is lossless. Given this, we can
        -: 9905:    // assume that if we do the standard relative comparison of
        -: 9906:    // |lhs - rhs| <= epsilon * max(fabs(lhs), fabs(rhs)), then we get
        -: 9907:    // the same result if we do this for floats, as if we do this for
        -: 9908:    // doubles that were promoted from floats.
    #####: 9909:    struct WithinRelMatcher final : MatcherBase<double> {
        -: 9910:        WithinRelMatcher(double target, double epsilon);
        -: 9911:        bool match(double const& matchee) const override;
        -: 9912:        std::string describe() const override;
        -: 9913:    private:
        -: 9914:        double m_target;
        -: 9915:        double m_epsilon;
        -: 9916:    };
        -: 9917:
        -: 9918:    //! Creates a matcher that accepts doubles within certain ULP range of target
        -: 9919:    WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff);
        -: 9920:    //! Creates a matcher that accepts floats within certain ULP range of target
        -: 9921:    WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff);
        -: 9922:    //! Creates a matcher that accepts numbers within certain range of target
        -: 9923:    WithinAbsMatcher WithinAbs(double target, double margin);
        -: 9924:
        -: 9925:    //! Creates a matcher that accepts doubles within certain relative range of target
        -: 9926:    WithinRelMatcher WithinRel(double target, double eps);
        -: 9927:    //! Creates a matcher that accepts doubles within 100*DBL_EPS relative range of target
        -: 9928:    WithinRelMatcher WithinRel(double target);
        -: 9929:    //! Creates a matcher that accepts doubles within certain relative range of target
        -: 9930:    WithinRelMatcher WithinRel(float target, float eps);
        -: 9931:    //! Creates a matcher that accepts floats within 100*FLT_EPS relative range of target
        -: 9932:    WithinRelMatcher WithinRel(float target);
        -: 9933:
        -: 9934:} // namespace Matchers
        -: 9935:} // namespace Catch
        -: 9936:
        -: 9937:#endif // CATCH_MATCHERS_FLOATING_HPP_INCLUDED
        -: 9938:
        -: 9939:
        -: 9940:#ifndef CATCH_MATCHERS_PREDICATE_HPP_INCLUDED
        -: 9941:#define CATCH_MATCHERS_PREDICATE_HPP_INCLUDED
        -: 9942:
        -: 9943:
        -: 9944:#include <string>
        -: 9945:#include <utility>
        -: 9946:
        -: 9947:namespace Catch {
        -: 9948:namespace Matchers {
        -: 9949:
        -: 9950:namespace Detail {
        -: 9951:    std::string finalizeDescription(const std::string& desc);
        -: 9952:} // namespace Detail
        -: 9953:
        -: 9954:template <typename T, typename Predicate>
        -: 9955:class PredicateMatcher final : public MatcherBase<T> {
        -: 9956:    Predicate m_predicate;
        -: 9957:    std::string m_description;
        -: 9958:public:
        -: 9959:
        -: 9960:    PredicateMatcher(Predicate&& elem, std::string const& descr)
        -: 9961:        :m_predicate(std::forward<Predicate>(elem)),
        -: 9962:        m_description(Detail::finalizeDescription(descr))
        -: 9963:    {}
        -: 9964:
        -: 9965:    bool match( T const& item ) const override {
        -: 9966:        return m_predicate(item);
        -: 9967:    }
        -: 9968:
        -: 9969:    std::string describe() const override {
        -: 9970:        return m_description;
        -: 9971:    }
        -: 9972:};
        -: 9973:
        -: 9974:    /**
        -: 9975:     * Creates a matcher that calls delegates `match` to the provided predicate.
        -: 9976:     *
        -: 9977:     * The user has to explicitly specify the argument type to the matcher
        -: 9978:     */
        -: 9979:    template<typename T, typename Pred>
        -: 9980:    PredicateMatcher<T, Pred> Predicate(Pred&& predicate, std::string const& description = "") {
        -: 9981:        static_assert(is_callable<Pred(T)>::value, "Predicate not callable with argument T");
        -: 9982:        static_assert(std::is_same<bool, FunctionReturnType<Pred, T>>::value, "Predicate does not return bool");
        -: 9983:        return PredicateMatcher<T, Pred>(std::forward<Pred>(predicate), description);
        -: 9984:    }
        -: 9985:
        -: 9986:} // namespace Matchers
        -: 9987:} // namespace Catch
        -: 9988:
        -: 9989:#endif // CATCH_MATCHERS_PREDICATE_HPP_INCLUDED
        -: 9990:
        -: 9991:
        -: 9992:#ifndef CATCH_MATCHERS_STRING_HPP_INCLUDED
        -: 9993:#define CATCH_MATCHERS_STRING_HPP_INCLUDED
        -: 9994:
        -: 9995:
        -: 9996:#include <string>
        -: 9997:
        -: 9998:namespace Catch {
        -: 9999:namespace Matchers {
        -:10000:
    #####:10001:    struct CasedString {
        -:10002:        CasedString( std::string const& str, CaseSensitive caseSensitivity );
        -:10003:        std::string adjustString( std::string const& str ) const;
        -:10004:        StringRef caseSensitivitySuffix() const;
        -:10005:
        -:10006:        CaseSensitive m_caseSensitivity;
        -:10007:        std::string m_str;
        -:10008:    };
        -:10009:
    #####:10010:    struct StringMatcherBase : MatcherBase<std::string> {
        -:10011:        StringMatcherBase( std::string const& operation, CasedString const& comparator );
        -:10012:        std::string describe() const override;
        -:10013:
        -:10014:        CasedString m_comparator;
        -:10015:        std::string m_operation;
        -:10016:    };
        -:10017:
    #####:10018:    struct StringEqualsMatcher final : StringMatcherBase {
        -:10019:        StringEqualsMatcher( CasedString const& comparator );
        -:10020:        bool match( std::string const& source ) const override;
        -:10021:    };
    #####:10022:    struct StringContainsMatcher final : StringMatcherBase {
        -:10023:        StringContainsMatcher( CasedString const& comparator );
        -:10024:        bool match( std::string const& source ) const override;
        -:10025:    };
    #####:10026:    struct StartsWithMatcher final : StringMatcherBase {
        -:10027:        StartsWithMatcher( CasedString const& comparator );
        -:10028:        bool match( std::string const& source ) const override;
        -:10029:    };
    #####:10030:    struct EndsWithMatcher final : StringMatcherBase {
        -:10031:        EndsWithMatcher( CasedString const& comparator );
        -:10032:        bool match( std::string const& source ) const override;
        -:10033:    };
        -:10034:
    #####:10035:    struct RegexMatcher final : MatcherBase<std::string> {
        -:10036:        RegexMatcher( std::string regex, CaseSensitive caseSensitivity );
        -:10037:        bool match( std::string const& matchee ) const override;
        -:10038:        std::string describe() const override;
        -:10039:
        -:10040:    private:
        -:10041:        std::string m_regex;
        -:10042:        CaseSensitive m_caseSensitivity;
        -:10043:    };
        -:10044:
        -:10045:    //! Creates matcher that accepts strings that are exactly equal to `str`
        -:10046:    StringEqualsMatcher Equals( std::string const& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );
        -:10047:    //! Creates matcher that accepts strings that contain `str`
        -:10048:    StringContainsMatcher Contains( std::string const& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );
        -:10049:    //! Creates matcher that accepts strings that _end_ with `str`
        -:10050:    EndsWithMatcher EndsWith( std::string const& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );
        -:10051:    //! Creates matcher that accepts strings that _start_ with `str`
        -:10052:    StartsWithMatcher StartsWith( std::string const& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );
        -:10053:    //! Creates matcher that accepts strings matching `regex`
        -:10054:    RegexMatcher Matches( std::string const& regex, CaseSensitive caseSensitivity = CaseSensitive::Yes );
        -:10055:
        -:10056:} // namespace Matchers
        -:10057:} // namespace Catch
        -:10058:
        -:10059:#endif // CATCH_MATCHERS_STRING_HPP_INCLUDED
        -:10060:
        -:10061:
        -:10062:#ifndef CATCH_MATCHERS_VECTOR_HPP_INCLUDED
        -:10063:#define CATCH_MATCHERS_VECTOR_HPP_INCLUDED
        -:10064:
        -:10065:
        -:10066:#include <algorithm>
        -:10067:
        -:10068:namespace Catch {
        -:10069:namespace Matchers {
        -:10070:
        -:10071:    template<typename T, typename Alloc>
        -:10072:    struct VectorContainsElementMatcher final : MatcherBase<std::vector<T, Alloc>> {
        -:10073:
        -:10074:        VectorContainsElementMatcher(T const& comparator):
        -:10075:            m_comparator(comparator)
        -:10076:        {}
        -:10077:
        -:10078:        bool match(std::vector<T, Alloc> const& v) const override {
        -:10079:            for (auto const& el : v) {
        -:10080:                if (el == m_comparator) {
        -:10081:                    return true;
        -:10082:                }
        -:10083:            }
        -:10084:            return false;
        -:10085:        }
        -:10086:
        -:10087:        std::string describe() const override {
        -:10088:            return "Contains: " + ::Catch::Detail::stringify( m_comparator );
        -:10089:        }
        -:10090:
        -:10091:        T const& m_comparator;
        -:10092:    };
        -:10093:
        -:10094:    template<typename T, typename AllocComp, typename AllocMatch>
        -:10095:    struct ContainsMatcher final : MatcherBase<std::vector<T, AllocMatch>> {
        -:10096:
        -:10097:        ContainsMatcher(std::vector<T, AllocComp> const& comparator):
        -:10098:            m_comparator( comparator )
        -:10099:        {}
        -:10100:
        -:10101:        bool match(std::vector<T, AllocMatch> const& v) const override {
        -:10102:            // !TBD: see note in EqualsMatcher
        -:10103:            if (m_comparator.size() > v.size())
        -:10104:                return false;
        -:10105:            for (auto const& comparator : m_comparator) {
        -:10106:                auto present = false;
        -:10107:                for (const auto& el : v) {
        -:10108:                    if (el == comparator) {
        -:10109:                        present = true;
        -:10110:                        break;
        -:10111:                    }
        -:10112:                }
        -:10113:                if (!present) {
        -:10114:                    return false;
        -:10115:                }
        -:10116:            }
        -:10117:            return true;
        -:10118:        }
        -:10119:        std::string describe() const override {
        -:10120:            return "Contains: " + ::Catch::Detail::stringify( m_comparator );
        -:10121:        }
        -:10122:
        -:10123:        std::vector<T, AllocComp> const& m_comparator;
        -:10124:    };
        -:10125:
        -:10126:    template<typename T, typename AllocComp, typename AllocMatch>
        -:10127:    struct EqualsMatcher final : MatcherBase<std::vector<T, AllocMatch>> {
        -:10128:
        -:10129:        EqualsMatcher(std::vector<T, AllocComp> const& comparator):
        -:10130:            m_comparator( comparator )
        -:10131:        {}
        -:10132:
        -:10133:        bool match(std::vector<T, AllocMatch> const& v) const override {
        -:10134:            // !TBD: This currently works if all elements can be compared using !=
        -:10135:            // - a more general approach would be via a compare template that defaults
        -:10136:            // to using !=. but could be specialised for, e.g. std::vector<T> etc
        -:10137:            // - then just call that directly
        -:10138:            if (m_comparator.size() != v.size())
        -:10139:                return false;
        -:10140:            for (std::size_t i = 0; i < v.size(); ++i)
        -:10141:                if (m_comparator[i] != v[i])
        -:10142:                    return false;
        -:10143:            return true;
        -:10144:        }
        -:10145:        std::string describe() const override {
        -:10146:            return "Equals: " + ::Catch::Detail::stringify( m_comparator );
        -:10147:        }
        -:10148:        std::vector<T, AllocComp> const& m_comparator;
        -:10149:    };
        -:10150:
        -:10151:    template<typename T, typename AllocComp, typename AllocMatch>
        -:10152:    struct ApproxMatcher final : MatcherBase<std::vector<T, AllocMatch>> {
        -:10153:
        -:10154:        ApproxMatcher(std::vector<T, AllocComp> const& comparator):
        -:10155:            m_comparator( comparator )
        -:10156:        {}
        -:10157:
        -:10158:        bool match(std::vector<T, AllocMatch> const& v) const override {
        -:10159:            if (m_comparator.size() != v.size())
        -:10160:                return false;
        -:10161:            for (std::size_t i = 0; i < v.size(); ++i)
        -:10162:                if (m_comparator[i] != approx(v[i]))
        -:10163:                    return false;
        -:10164:            return true;
        -:10165:        }
        -:10166:        std::string describe() const override {
        -:10167:            return "is approx: " + ::Catch::Detail::stringify( m_comparator );
        -:10168:        }
        -:10169:        template <typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -:10170:        ApproxMatcher& epsilon( T const& newEpsilon ) {
        -:10171:            approx.epsilon(static_cast<double>(newEpsilon));
        -:10172:            return *this;
        -:10173:        }
        -:10174:        template <typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -:10175:        ApproxMatcher& margin( T const& newMargin ) {
        -:10176:            approx.margin(static_cast<double>(newMargin));
        -:10177:            return *this;
        -:10178:        }
        -:10179:        template <typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -:10180:        ApproxMatcher& scale( T const& newScale ) {
        -:10181:            approx.scale(static_cast<double>(newScale));
        -:10182:            return *this;
        -:10183:        }
        -:10184:
        -:10185:        std::vector<T, AllocComp> const& m_comparator;
        -:10186:        mutable Catch::Approx approx = Catch::Approx::custom();
        -:10187:    };
        -:10188:
        -:10189:    template<typename T, typename AllocComp, typename AllocMatch>
        -:10190:    struct UnorderedEqualsMatcher final : MatcherBase<std::vector<T, AllocMatch>> {
        -:10191:        UnorderedEqualsMatcher(std::vector<T, AllocComp> const& target):
        -:10192:            m_target(target)
        -:10193:        {}
        -:10194:        bool match(std::vector<T, AllocMatch> const& vec) const override {
        -:10195:            if (m_target.size() != vec.size()) {
        -:10196:                return false;
        -:10197:            }
        -:10198:            return std::is_permutation(m_target.begin(), m_target.end(), vec.begin());
        -:10199:        }
        -:10200:
        -:10201:        std::string describe() const override {
        -:10202:            return "UnorderedEquals: " + ::Catch::Detail::stringify(m_target);
        -:10203:        }
        -:10204:    private:
        -:10205:        std::vector<T, AllocComp> const& m_target;
        -:10206:    };
        -:10207:
        -:10208:
        -:10209:    // The following functions create the actual matcher objects.
        -:10210:    // This allows the types to be inferred
        -:10211:
        -:10212:
        -:10213:    //! Creates a matcher that matches vectors that contain all elements in `comparator`
        -:10214:    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
        -:10215:    ContainsMatcher<T, AllocComp, AllocMatch> Contains( std::vector<T, AllocComp> const& comparator ) {
        -:10216:        return ContainsMatcher<T, AllocComp, AllocMatch>(comparator);
        -:10217:    }
        -:10218:
        -:10219:    //! Creates a matcher that matches vectors that contain `comparator` as an element
        -:10220:    template<typename T, typename Alloc = std::allocator<T>>
        -:10221:    VectorContainsElementMatcher<T, Alloc> VectorContains( T const& comparator ) {
        -:10222:        return VectorContainsElementMatcher<T, Alloc>(comparator);
        -:10223:    }
        -:10224:
        -:10225:    //! Creates a matcher that matches vectors that are exactly equal to `comparator`
        -:10226:    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
        -:10227:    EqualsMatcher<T, AllocComp, AllocMatch> Equals( std::vector<T, AllocComp> const& comparator ) {
        -:10228:        return EqualsMatcher<T, AllocComp, AllocMatch>(comparator);
        -:10229:    }
        -:10230:
        -:10231:    //! Creates a matcher that matches vectors that `comparator` as an element
        -:10232:    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
        -:10233:    ApproxMatcher<T, AllocComp, AllocMatch> Approx( std::vector<T, AllocComp> const& comparator ) {
        -:10234:        return ApproxMatcher<T, AllocComp, AllocMatch>(comparator);
        -:10235:    }
        -:10236:
        -:10237:    //! Creates a matcher that matches vectors that is equal to `target` modulo permutation
        -:10238:    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
        -:10239:    UnorderedEqualsMatcher<T, AllocComp, AllocMatch> UnorderedEquals(std::vector<T, AllocComp> const& target) {
        -:10240:        return UnorderedEqualsMatcher<T, AllocComp, AllocMatch>(target);
        -:10241:    }
        -:10242:
        -:10243:} // namespace Matchers
        -:10244:} // namespace Catch
        -:10245:
        -:10246:#endif // CATCH_MATCHERS_VECTOR_HPP_INCLUDED
        -:10247:
        -:10248:#endif // CATCH_MATCHERS_ALL_HPP_INCLUDED
        -:10249:
        -:10250:
        -:10251:/** \file
        -:10252: * This is a convenience header for Catch2's Reporter support. It includes
        -:10253: * **all** of Catch2 headers related to reporters, including all reporters.
        -:10254: *
        -:10255: * Generally the Catch2 users should use specific includes they need,
        -:10256: * but this header can be used instead for ease-of-experimentation, or
        -:10257: * just plain convenience, at the cost of (significantly) increased
        -:10258: * compilation times.
        -:10259: *
        -:10260: * When a new header (reporter) is added to either the `reporter` folder,
        -:10261: * or to the corresponding internal subfolder, it should be added here.
        -:10262: */
        -:10263:
        -:10264:#ifndef CATCH_REPORTERS_ALL_HPP_INCLUDED
        -:10265:#define CATCH_REPORTERS_ALL_HPP_INCLUDED
        -:10266:
        -:10267:
        -:10268:
        -:10269:#ifndef CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED
        -:10270:#define CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED
        -:10271:
        -:10272:
        -:10273:
        -:10274:#ifndef CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED
        -:10275:#define CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED
        -:10276:
        -:10277:
        -:10278:
        -:10279:#include <iosfwd>
        -:10280:#include <string>
        -:10281:#include <vector>
        -:10282:
        -:10283:namespace Catch {
        -:10284:
        -:10285:    template<typename T>
        4:10286:    struct LazyStat : Option<T> {
        -:10287:        LazyStat& operator=(T const& _value) {
        2:10288:            Option<T>::operator=(_value);
        2:10289:            used = false;
        -:10290:            return *this;
        -:10291:        }
        -:10292:        void reset() {
        -:10293:            Option<T>::reset();
        3:10294:            used = false;
        -:10295:        }
        -:10296:        bool used = false;
        -:10297:    };
        -:10298:
        -:10299:
        2:10300:    struct StreamingReporterBase : IStreamingReporter {
        -:10301:
        -:10302:        StreamingReporterBase( ReporterConfig const& _config ):
        4:10303:            m_config( _config.fullConfig() ), stream( _config.stream() ) {
        -:10304:        }
        -:10305:
        -:10306:
        -:10307:        ~StreamingReporterBase() override;
        -:10308:
    #####:10309:        void noMatchingTestCases(std::string const&) override {}
        -:10310:
    #####:10311:        void reportInvalidArguments(std::string const&) override {}
        -:10312:
        -:10313:        void testRunStarting( TestRunInfo const& _testRunInfo ) override;
        -:10314:
        -:10315:        void testGroupStarting( GroupInfo const& _groupInfo ) override;
        -:10316:
        1:10317:        void testCaseStarting(TestCaseInfo const& _testInfo) override  {
        1:10318:            currentTestCaseInfo = &_testInfo;
        1:10319:        }
    #####:10320:        void sectionStarting(SectionInfo const& _sectionInfo) override {
        1:10321:            m_sectionStack.push_back(_sectionInfo);
    #####:10322:        }
        -:10323:
    #####:10324:        void sectionEnded(SectionStats const& /* _sectionStats */) override {
        -:10325:            m_sectionStack.pop_back();
    #####:10326:        }
    #####:10327:        void testCaseEnded(TestCaseStats const& /* _testCaseStats */) override {
        1:10328:            currentTestCaseInfo = nullptr;
    #####:10329:        }
        -:10330:        void testGroupEnded( TestGroupStats const& ) override;
        -:10331:        void testRunEnded( TestRunStats const& /* _testRunStats */ ) override;
        -:10332:
    #####:10333:        void skipTest(TestCaseInfo const&) override {
        -:10334:            // Don't do anything with this by default.
        -:10335:            // It can optionally be overridden in the derived class.
    #####:10336:        }
        -:10337:
        -:10338:        IConfig const* m_config;
        -:10339:        std::ostream& stream;
        -:10340:
        -:10341:        LazyStat<TestRunInfo> currentTestRunInfo;
        -:10342:        LazyStat<GroupInfo> currentGroupInfo;
        -:10343:        TestCaseInfo const* currentTestCaseInfo = nullptr;
        -:10344:
        -:10345:        std::vector<SectionInfo> m_sectionStack;
        -:10346:    };
        -:10347:
        -:10348:} // end namespace Catch
        -:10349:
        -:10350:#endif // CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED
        -:10351:
        -:10352:namespace Catch {
        -:10353:
        -:10354:    struct AutomakeReporter : StreamingReporterBase {
        -:10355:        AutomakeReporter( ReporterConfig const& _config )
    #####:10356:          :   StreamingReporterBase( _config )
        -:10357:        {}
        -:10358:
        -:10359:        ~AutomakeReporter() override;
        -:10360:
        -:10361:        static std::string getDescription() {
        -:10362:            using namespace std::string_literals;
        -:10363:            return "Reports test results in the format of Automake .trs files"s;
        -:10364:        }
        -:10365:
    #####:10366:        void assertionStarting( AssertionInfo const& ) override {}
        -:10367:
    #####:10368:        bool assertionEnded( AssertionStats const& /*_assertionStats*/ ) override { return true; }
        -:10369:
        -:10370:        void testCaseEnded(TestCaseStats const& _testCaseStats) override;
        -:10371:
        -:10372:        void skipTest(TestCaseInfo const& testInfo) override;
        -:10373:
        -:10374:    };
        -:10375:
        -:10376:} // end namespace Catch
        -:10377:
        -:10378:#endif // CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED
        -:10379:
        -:10380:
        -:10381:#ifndef CATCH_REPORTER_COMPACT_HPP_INCLUDED
        -:10382:#define CATCH_REPORTER_COMPACT_HPP_INCLUDED
        -:10383:
        -:10384:
        -:10385:
        -:10386:
        -:10387:namespace Catch {
        -:10388:
        -:10389:    struct CompactReporter : StreamingReporterBase {
        -:10390:
    #####:10391:        using StreamingReporterBase::StreamingReporterBase;
        -:10392:
        -:10393:        ~CompactReporter() override;
        -:10394:
        -:10395:        static std::string getDescription();
        -:10396:
        -:10397:        void noMatchingTestCases(std::string const& spec) override;
        -:10398:
        -:10399:        void assertionStarting(AssertionInfo const&) override;
        -:10400:
        -:10401:        bool assertionEnded(AssertionStats const& _assertionStats) override;
        -:10402:
        -:10403:        void sectionEnded(SectionStats const& _sectionStats) override;
        -:10404:
        -:10405:        void testRunEnded(TestRunStats const& _testRunStats) override;
        -:10406:
        -:10407:    };
        -:10408:
        -:10409:} // end namespace Catch
        -:10410:
        -:10411:#endif // CATCH_REPORTER_COMPACT_HPP_INCLUDED
        -:10412:
        -:10413:
        -:10414:#ifndef CATCH_REPORTER_CONSOLE_HPP_INCLUDED
        -:10415:#define CATCH_REPORTER_CONSOLE_HPP_INCLUDED
        -:10416:
        -:10417:
        -:10418:#if defined(_MSC_VER)
        -:10419:#pragma warning(push)
        -:10420:#pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch
        -:10421:                              // Note that 4062 (not all labels are handled
        -:10422:                              // and default is missing) is enabled
        -:10423:#endif
        -:10424:
        -:10425:
        -:10426:namespace Catch {
        -:10427:    // Fwd decls
        -:10428:    struct SummaryColumn;
        -:10429:    class TablePrinter;
        -:10430:
        1:10431:    struct ConsoleReporter : StreamingReporterBase {
        -:10432:        Detail::unique_ptr<TablePrinter> m_tablePrinter;
        -:10433:
        -:10434:        ConsoleReporter(ReporterConfig const& config);
        -:10435:        ~ConsoleReporter() override;
        -:10436:        static std::string getDescription();
        -:10437:
        -:10438:        void noMatchingTestCases(std::string const& spec) override;
        -:10439:
        -:10440:        void reportInvalidArguments(std::string const&arg) override;
        -:10441:
        -:10442:        void assertionStarting(AssertionInfo const&) override;
        -:10443:
        -:10444:        bool assertionEnded(AssertionStats const& _assertionStats) override;
        -:10445:
        -:10446:        void sectionStarting(SectionInfo const& _sectionInfo) override;
        -:10447:        void sectionEnded(SectionStats const& _sectionStats) override;
        -:10448:
        -:10449:        void benchmarkPreparing(std::string const& name) override;
        -:10450:        void benchmarkStarting(BenchmarkInfo const& info) override;
        -:10451:        void benchmarkEnded(BenchmarkStats<> const& stats) override;
        -:10452:        void benchmarkFailed(std::string const& error) override;
        -:10453:
        -:10454:        void testCaseEnded(TestCaseStats const& _testCaseStats) override;
        -:10455:        void testGroupEnded(TestGroupStats const& _testGroupStats) override;
        -:10456:        void testRunEnded(TestRunStats const& _testRunStats) override;
        -:10457:        void testRunStarting(TestRunInfo const& _testRunInfo) override;
        -:10458:    private:
        -:10459:
        -:10460:        void lazyPrint();
        -:10461:
        -:10462:        void lazyPrintWithoutClosingBenchmarkTable();
        -:10463:        void lazyPrintRunInfo();
        -:10464:        void lazyPrintGroupInfo();
        -:10465:        void printTestCaseAndSectionHeader();
        -:10466:
        -:10467:        void printClosedHeader(std::string const& _name);
        -:10468:        void printOpenHeader(std::string const& _name);
        -:10469:
        -:10470:        // if string has a : in first line will set indent to follow it on
        -:10471:        // subsequent lines
        -:10472:        void printHeaderString(std::string const& _string, std::size_t indent = 0);
        -:10473:
        -:10474:
        -:10475:        void printTotals(Totals const& totals);
        -:10476:        void printSummaryRow(std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row);
        -:10477:
        -:10478:        void printTotalsDivider(Totals const& totals);
        -:10479:        void printSummaryDivider();
        -:10480:        void printTestFilters();
        -:10481:
        -:10482:    private:
        -:10483:        bool m_headerPrinted = false;
        -:10484:    };
        -:10485:
        -:10486:} // end namespace Catch
        -:10487:
        -:10488:#if defined(_MSC_VER)
        -:10489:#pragma warning(pop)
        -:10490:#endif
        -:10491:
        -:10492:#endif // CATCH_REPORTER_CONSOLE_HPP_INCLUDED
        -:10493:
        -:10494:
        -:10495:#ifndef CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED
        -:10496:#define CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED
        -:10497:
        -:10498:
        -:10499:#include <iosfwd>
        -:10500:#include <memory>
        -:10501:#include <string>
        -:10502:#include <vector>
        -:10503:
        -:10504:namespace Catch {
        -:10505:
    #####:10506:    struct CumulativeReporterBase : IStreamingReporter {
        -:10507:        template<typename T, typename ChildNodeT>
        -:10508:        struct Node {
    #####:10509:            explicit Node( T const& _value ) : value( _value ) {}
    #####:10510:            virtual ~Node() {}
        -:10511:
        -:10512:            using ChildNodes = std::vector<std::shared_ptr<ChildNodeT>>;
        -:10513:            T value;
        -:10514:            ChildNodes children;
        -:10515:        };
    #####:10516:        struct SectionNode {
    #####:10517:            explicit SectionNode(SectionStats const& _stats) : stats(_stats) {}
        -:10518:
        -:10519:            bool operator == (SectionNode const& other) const {
        -:10520:                return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;
        -:10521:            }
        -:10522:
        -:10523:            SectionStats stats;
        -:10524:            using ChildSections = std::vector<std::shared_ptr<SectionNode>>;
        -:10525:            using Assertions = std::vector<AssertionStats>;
        -:10526:            ChildSections childSections;
        -:10527:            Assertions assertions;
        -:10528:            std::string stdOut;
        -:10529:            std::string stdErr;
        -:10530:        };
        -:10531:
        -:10532:
        -:10533:        using TestCaseNode = Node<TestCaseStats, SectionNode>;
        -:10534:        using TestGroupNode = Node<TestGroupStats, TestCaseNode>;
        -:10535:        using TestRunNode = Node<TestRunStats, TestGroupNode>;
        -:10536:
        -:10537:        CumulativeReporterBase( ReporterConfig const& _config ):
    #####:10538:            m_config( _config.fullConfig() ), stream( _config.stream() ) {}
        -:10539:        ~CumulativeReporterBase() override;
        -:10540:
    #####:10541:        void testRunStarting( TestRunInfo const& ) override {}
    #####:10542:        void testGroupStarting( GroupInfo const& ) override {}
        -:10543:
    #####:10544:        void testCaseStarting( TestCaseInfo const& ) override {}
        -:10545:
        -:10546:        void sectionStarting( SectionInfo const& sectionInfo ) override;
        -:10547:
    #####:10548:        void assertionStarting( AssertionInfo const& ) override {}
        -:10549:
        -:10550:        bool assertionEnded( AssertionStats const& assertionStats ) override;
        -:10551:        void sectionEnded( SectionStats const& sectionStats ) override;
        -:10552:        void testCaseEnded( TestCaseStats const& testCaseStats ) override;
        -:10553:        void testGroupEnded( TestGroupStats const& testGroupStats ) override;
        -:10554:        void testRunEnded( TestRunStats const& testRunStats ) override;
        -:10555:        virtual void testRunEndedCumulative() = 0;
        -:10556:
    #####:10557:        void skipTest(TestCaseInfo const&) override {}
        -:10558:
        -:10559:        IConfig const* m_config;
        -:10560:        std::ostream& stream;
        -:10561:        std::vector<AssertionStats> m_assertions;
        -:10562:        std::vector<std::vector<std::shared_ptr<SectionNode>>> m_sections;
        -:10563:        std::vector<std::shared_ptr<TestCaseNode>> m_testCases;
        -:10564:        std::vector<std::shared_ptr<TestGroupNode>> m_testGroups;
        -:10565:
        -:10566:        std::vector<std::shared_ptr<TestRunNode>> m_testRuns;
        -:10567:
        -:10568:        std::shared_ptr<SectionNode> m_rootSection;
        -:10569:        std::shared_ptr<SectionNode> m_deepestSection;
        -:10570:        std::vector<std::shared_ptr<SectionNode>> m_sectionStack;
        -:10571:    };
        -:10572:
        -:10573:} // end namespace Catch
        -:10574:
        -:10575:#endif // CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED
        -:10576:
        -:10577:
        -:10578:#ifndef CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDED
        -:10579:#define CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDED
        -:10580:
        -:10581:
        -:10582:namespace Catch {
        -:10583:
        -:10584:    /**
        -:10585:     * Base class identifying listeners.
        -:10586:     *
        -:10587:     * Provides default implementation for all IStreamingReporter member
        -:10588:     * functions, so that listeners implementations can pick which
        -:10589:     * member functions it actually cares about.
        -:10590:     */
    #####:10591:    class EventListenerBase : public IStreamingReporter {
        -:10592:        IConfig const* m_config;
        -:10593:
        -:10594:    public:
        -:10595:        EventListenerBase( ReporterConfig const& config ):
        -:10596:            m_config( config.fullConfig() ) {}
        -:10597:
        -:10598:        void assertionStarting( AssertionInfo const& assertionInfo ) override;
        -:10599:        bool assertionEnded( AssertionStats const& assertionStats ) override;
        -:10600:
        -:10601:        void
        -:10602:        listReporters( std::vector<ReporterDescription> const& descriptions,
        -:10603:                       IConfig const& config ) override;
        -:10604:        void listTests( std::vector<TestCaseHandle> const& tests,
        -:10605:                        IConfig const& config ) override;
        -:10606:        void listTags( std::vector<TagInfo> const& tagInfos,
        -:10607:                       IConfig const& config ) override;
        -:10608:
        -:10609:        void noMatchingTestCases( std::string const& spec ) override;
        -:10610:        void testRunStarting( TestRunInfo const& testRunInfo ) override;
        -:10611:        void testGroupStarting( GroupInfo const& groupInfo ) override;
        -:10612:        void testCaseStarting( TestCaseInfo const& testInfo ) override;
        -:10613:        void sectionStarting( SectionInfo const& sectionInfo ) override;
        -:10614:        void sectionEnded( SectionStats const& sectionStats ) override;
        -:10615:        void testCaseEnded( TestCaseStats const& testCaseStats ) override;
        -:10616:        void testGroupEnded( TestGroupStats const& testGroupStats ) override;
        -:10617:        void testRunEnded( TestRunStats const& testRunStats ) override;
        -:10618:        void skipTest( TestCaseInfo const& testInfo ) override;
        -:10619:    };
        -:10620:
        -:10621:} // end namespace Catch
        -:10622:
        -:10623:#endif // CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDED
        -:10624:
        -:10625:
        -:10626:#ifndef CATCH_REPORTER_HELPERS_HPP_INCLUDED
        -:10627:#define CATCH_REPORTER_HELPERS_HPP_INCLUDED
        -:10628:
        -:10629:#include <iosfwd>
        -:10630:#include <string>
        -:10631:#include <vector>
        -:10632:
        -:10633:namespace Catch {
        -:10634:
        -:10635:    struct IConfig;
        -:10636:
        -:10637:    // Returns double formatted as %.3f (format expected on output)
        -:10638:    std::string getFormattedDuration( double duration );
        -:10639:
        -:10640:    //! Should the reporter show duration of test given current configuration?
        -:10641:    bool shouldShowDuration( IConfig const& config, double duration );
        -:10642:
        -:10643:    std::string serializeFilters( std::vector<std::string> const& filters );
        -:10644:
        -:10645:    struct lineOfChars {
        -:10646:        char c;
        -:10647:        constexpr lineOfChars( char c_ ): c( c_ ) {}
        -:10648:
        -:10649:        friend std::ostream& operator<<( std::ostream& out, lineOfChars value );
        -:10650:    };
        -:10651:
        -:10652:} // end namespace Catch
        -:10653:
        -:10654:#endif // CATCH_REPORTER_HELPERS_HPP_INCLUDED
        -:10655:
        -:10656:
        -:10657:#ifndef CATCH_REPORTER_JUNIT_HPP_INCLUDED
        -:10658:#define CATCH_REPORTER_JUNIT_HPP_INCLUDED
        -:10659:
        -:10660:
        -:10661:
        -:10662:namespace Catch {
        -:10663:
        -:10664:    class JunitReporter : public CumulativeReporterBase {
        -:10665:    public:
        -:10666:        JunitReporter(ReporterConfig const& _config);
        -:10667:
        -:10668:        ~JunitReporter() override;
        -:10669:
        -:10670:        static std::string getDescription();
        -:10671:
        -:10672:        void noMatchingTestCases(std::string const& /*spec*/) override;
        -:10673:
        -:10674:        void testRunStarting(TestRunInfo const& runInfo) override;
        -:10675:
        -:10676:        void testGroupStarting(GroupInfo const& groupInfo) override;
        -:10677:
        -:10678:        void testCaseStarting(TestCaseInfo const& testCaseInfo) override;
        -:10679:        bool assertionEnded(AssertionStats const& assertionStats) override;
        -:10680:
        -:10681:        void testCaseEnded(TestCaseStats const& testCaseStats) override;
        -:10682:
        -:10683:        void testGroupEnded(TestGroupStats const& testGroupStats) override;
        -:10684:
        -:10685:        void testRunEndedCumulative() override;
        -:10686:
        -:10687:        void writeGroup(TestGroupNode const& groupNode, double suiteTime);
        -:10688:
        -:10689:        void writeTestCase(TestCaseNode const& testCaseNode);
        -:10690:
        -:10691:        void writeSection(std::string const& className,
        -:10692:                          std::string const& rootName,
        -:10693:                          SectionNode const& sectionNode);
        -:10694:
        -:10695:        void writeAssertions(SectionNode const& sectionNode);
        -:10696:        void writeAssertion(AssertionStats const& stats);
        -:10697:
        -:10698:        XmlWriter xml;
        -:10699:        Timer suiteTimer;
        -:10700:        std::string stdOutForSuite;
        -:10701:        std::string stdErrForSuite;
        -:10702:        unsigned int unexpectedExceptions = 0;
        -:10703:        bool m_okToFail = false;
        -:10704:    };
        -:10705:
        -:10706:} // end namespace Catch
        -:10707:
        -:10708:#endif // CATCH_REPORTER_JUNIT_HPP_INCLUDED
        -:10709:
        -:10710:
        -:10711:#ifndef CATCH_REPORTER_LISTENING_HPP_INCLUDED
        -:10712:#define CATCH_REPORTER_LISTENING_HPP_INCLUDED
        -:10713:
        -:10714:
        -:10715:namespace Catch {
        -:10716:
    #####:10717:    class ListeningReporter final : public IStreamingReporter {
        -:10718:        using Reporters = std::vector<IStreamingReporterPtr>;
        -:10719:        Reporters m_listeners;
        -:10720:        IStreamingReporterPtr m_reporter = nullptr;
        -:10721:
        -:10722:    public:
        -:10723:        ListeningReporter();
        -:10724:
        -:10725:        void addListener( IStreamingReporterPtr&& listener );
        -:10726:        void addReporter( IStreamingReporterPtr&& reporter );
        -:10727:
        -:10728:    public: // IStreamingReporter
        -:10729:
        -:10730:        void noMatchingTestCases( std::string const& spec ) override;
        -:10731:
        -:10732:        void reportInvalidArguments(std::string const&arg) override;
        -:10733:
        -:10734:        void benchmarkPreparing(std::string const& name) override;
        -:10735:        void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) override;
        -:10736:        void benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) override;
        -:10737:        void benchmarkFailed(std::string const&) override;
        -:10738:
        -:10739:        void testRunStarting( TestRunInfo const& testRunInfo ) override;
        -:10740:        void testGroupStarting( GroupInfo const& groupInfo ) override;
        -:10741:        void testCaseStarting( TestCaseInfo const& testInfo ) override;
        -:10742:        void sectionStarting( SectionInfo const& sectionInfo ) override;
        -:10743:        void assertionStarting( AssertionInfo const& assertionInfo ) override;
        -:10744:
        -:10745:        // The return value indicates if the messages buffer should be cleared:
        -:10746:        bool assertionEnded( AssertionStats const& assertionStats ) override;
        -:10747:        void sectionEnded( SectionStats const& sectionStats ) override;
        -:10748:        void testCaseEnded( TestCaseStats const& testCaseStats ) override;
        -:10749:        void testGroupEnded( TestGroupStats const& testGroupStats ) override;
        -:10750:        void testRunEnded( TestRunStats const& testRunStats ) override;
        -:10751:
        -:10752:        void skipTest( TestCaseInfo const& testInfo ) override;
        -:10753:
        -:10754:        void listReporters(std::vector<ReporterDescription> const& descriptions, IConfig const& config) override;
        -:10755:        void listTests(std::vector<TestCaseHandle> const& tests, IConfig const& config) override;
        -:10756:        void listTags(std::vector<TagInfo> const& tags, IConfig const& config) override;
        -:10757:
        -:10758:
        -:10759:    };
        -:10760:
        -:10761:} // end namespace Catch
        -:10762:
        -:10763:#endif // CATCH_REPORTER_LISTENING_HPP_INCLUDED
        -:10764:
        -:10765:
        -:10766:#ifndef CATCH_REPORTER_SONARQUBE_HPP_INCLUDED
        -:10767:#define CATCH_REPORTER_SONARQUBE_HPP_INCLUDED
        -:10768:
        -:10769:
        -:10770:
        -:10771:namespace Catch {
        -:10772:
        -:10773:    struct SonarQubeReporter : CumulativeReporterBase {
        -:10774:
    #####:10775:        SonarQubeReporter(ReporterConfig const& config)
        -:10776:        : CumulativeReporterBase(config)
    #####:10777:        , xml(config.stream()) {
    #####:10778:            m_preferences.shouldRedirectStdOut = true;
    #####:10779:            m_preferences.shouldReportAllAssertions = true;
    #####:10780:        }
        -:10781:
        -:10782:        ~SonarQubeReporter() override;
        -:10783:
        -:10784:        static std::string getDescription() {
        -:10785:            using namespace std::string_literals;
        -:10786:            return "Reports test results in the Generic Test Data SonarQube XML format"s;
        -:10787:        }
        -:10788:
    #####:10789:        void noMatchingTestCases(std::string const& /*spec*/) override {}
        -:10790:
        -:10791:        void testRunStarting(TestRunInfo const& testRunInfo) override;
        -:10792:
        -:10793:        void testGroupEnded(TestGroupStats const& testGroupStats) override;
        -:10794:
    #####:10795:        void testRunEndedCumulative() override {
    #####:10796:            xml.endElement();
    #####:10797:        }
        -:10798:
        -:10799:        void writeGroup(TestGroupNode const& groupNode);
        -:10800:
        -:10801:        void writeTestFile(std::string const& filename, TestGroupNode::ChildNodes const& testCaseNodes);
        -:10802:
        -:10803:        void writeTestCase(TestCaseNode const& testCaseNode);
        -:10804:
        -:10805:        void writeSection(std::string const& rootName, SectionNode const& sectionNode, bool okToFail);
        -:10806:
        -:10807:        void writeAssertions(SectionNode const& sectionNode, bool okToFail);
        -:10808:
        -:10809:        void writeAssertion(AssertionStats const& stats, bool okToFail);
        -:10810:
        -:10811:    private:
        -:10812:        XmlWriter xml;
        -:10813:    };
        -:10814:
        -:10815:
        -:10816:} // end namespace Catch
        -:10817:
        -:10818:#endif // CATCH_REPORTER_SONARQUBE_HPP_INCLUDED
        -:10819:
        -:10820:
        -:10821:#ifndef CATCH_REPORTER_TAP_HPP_INCLUDED
        -:10822:#define CATCH_REPORTER_TAP_HPP_INCLUDED
        -:10823:
        -:10824:
        -:10825:namespace Catch {
        -:10826:
        -:10827:    struct TAPReporter : StreamingReporterBase {
        -:10828:
        -:10829:        TAPReporter( ReporterConfig const& config ):
    #####:10830:            StreamingReporterBase( config ) {
    #####:10831:            m_preferences.shouldReportAllAssertions = true;
        -:10832:        }
        -:10833:        ~TAPReporter() override;
        -:10834:
        -:10835:        static std::string getDescription() {
        -:10836:            using namespace std::string_literals;
        -:10837:            return "Reports test results in TAP format, suitable for test harnesses"s;
        -:10838:        }
        -:10839:
        -:10840:        void noMatchingTestCases(std::string const& spec) override;
        -:10841:
    #####:10842:        void assertionStarting( AssertionInfo const& ) override {}
        -:10843:
        -:10844:        bool assertionEnded(AssertionStats const& _assertionStats) override;
        -:10845:
        -:10846:        void testRunEnded(TestRunStats const& _testRunStats) override;
        -:10847:
        -:10848:    private:
        -:10849:        std::size_t counter = 0;
        -:10850:    };
        -:10851:
        -:10852:} // end namespace Catch
        -:10853:
        -:10854:#endif // CATCH_REPORTER_TAP_HPP_INCLUDED
        -:10855:
        -:10856:
        -:10857:#ifndef CATCH_REPORTER_TEAMCITY_HPP_INCLUDED
        -:10858:#define CATCH_REPORTER_TEAMCITY_HPP_INCLUDED
        -:10859:
        -:10860:
        -:10861:#include <cstring>
        -:10862:
        -:10863:#ifdef __clang__
        -:10864:#   pragma clang diagnostic push
        -:10865:#   pragma clang diagnostic ignored "-Wpadded"
        -:10866:#endif
        -:10867:
        -:10868:namespace Catch {
        -:10869:
        -:10870:    struct TeamCityReporter : StreamingReporterBase {
        -:10871:        TeamCityReporter( ReporterConfig const& _config )
    #####:10872:        :   StreamingReporterBase( _config )
        -:10873:        {
    #####:10874:            m_preferences.shouldRedirectStdOut = true;
        -:10875:        }
        -:10876:
        -:10877:        ~TeamCityReporter() override;
        -:10878:
        -:10879:        static std::string getDescription() {
        -:10880:            using namespace std::string_literals;
        -:10881:            return "Reports test results as TeamCity service messages"s;
        -:10882:        }
        -:10883:
    #####:10884:        void skipTest( TestCaseInfo const& /* testInfo */ ) override {}
        -:10885:
    #####:10886:        void noMatchingTestCases( std::string const& /* spec */ ) override {}
        -:10887:
        -:10888:        void testGroupStarting(GroupInfo const& groupInfo) override;
        -:10889:        void testGroupEnded(TestGroupStats const& testGroupStats) override;
        -:10890:
        -:10891:
    #####:10892:        void assertionStarting(AssertionInfo const&) override {}
        -:10893:
        -:10894:        bool assertionEnded(AssertionStats const& assertionStats) override;
        -:10895:
    #####:10896:        void sectionStarting(SectionInfo const& sectionInfo) override {
    #####:10897:            m_headerPrintedForThisSection = false;
        -:10898:            StreamingReporterBase::sectionStarting( sectionInfo );
    #####:10899:        }
        -:10900:
        -:10901:        void testCaseStarting(TestCaseInfo const& testInfo) override;
        -:10902:
        -:10903:        void testCaseEnded(TestCaseStats const& testCaseStats) override;
        -:10904:
        -:10905:    private:
        -:10906:        void printSectionHeader(std::ostream& os);
        -:10907:
        -:10908:    private:
        -:10909:        bool m_headerPrintedForThisSection = false;
        -:10910:        Timer m_testTimer;
        -:10911:    };
        -:10912:
        -:10913:} // end namespace Catch
        -:10914:
        -:10915:#ifdef __clang__
        -:10916:#   pragma clang diagnostic pop
        -:10917:#endif
        -:10918:
        -:10919:#endif // CATCH_REPORTER_TEAMCITY_HPP_INCLUDED
        -:10920:
        -:10921:
        -:10922:#ifndef CATCH_REPORTER_XML_HPP_INCLUDED
        -:10923:#define CATCH_REPORTER_XML_HPP_INCLUDED
        -:10924:
        -:10925:
        -:10926:
        -:10927:
        -:10928:namespace Catch {
    #####:10929:    class XmlReporter : public StreamingReporterBase {
        -:10930:    public:
        -:10931:        XmlReporter(ReporterConfig const& _config);
        -:10932:
        -:10933:        ~XmlReporter() override;
        -:10934:
        -:10935:        static std::string getDescription();
        -:10936:
        -:10937:        virtual std::string getStylesheetRef() const;
        -:10938:
        -:10939:        void writeSourceInfo(SourceLineInfo const& sourceInfo);
        -:10940:
        -:10941:    public: // StreamingReporterBase
        -:10942:
        -:10943:        void noMatchingTestCases(std::string const& s) override;
        -:10944:
        -:10945:        void testRunStarting(TestRunInfo const& testInfo) override;
        -:10946:
        -:10947:        void testGroupStarting(GroupInfo const& groupInfo) override;
        -:10948:
        -:10949:        void testCaseStarting(TestCaseInfo const& testInfo) override;
        -:10950:
        -:10951:        void sectionStarting(SectionInfo const& sectionInfo) override;
        -:10952:
        -:10953:        void assertionStarting(AssertionInfo const&) override;
        -:10954:
        -:10955:        bool assertionEnded(AssertionStats const& assertionStats) override;
        -:10956:
        -:10957:        void sectionEnded(SectionStats const& sectionStats) override;
        -:10958:
        -:10959:        void testCaseEnded(TestCaseStats const& testCaseStats) override;
        -:10960:
        -:10961:        void testGroupEnded(TestGroupStats const& testGroupStats) override;
        -:10962:
        -:10963:        void testRunEnded(TestRunStats const& testRunStats) override;
        -:10964:
        -:10965:        void benchmarkPreparing(std::string const& name) override;
        -:10966:        void benchmarkStarting(BenchmarkInfo const&) override;
        -:10967:        void benchmarkEnded(BenchmarkStats<> const&) override;
        -:10968:        void benchmarkFailed(std::string const&) override;
        -:10969:
        -:10970:        void listReporters(std::vector<ReporterDescription> const& descriptions, IConfig const& config) override;
        -:10971:        void listTests(std::vector<TestCaseHandle> const& tests, IConfig const& config) override;
        -:10972:        void listTags(std::vector<TagInfo> const& tags, IConfig const& config) override;
        -:10973:
        -:10974:    private:
        -:10975:        Timer m_testCaseTimer;
        -:10976:        XmlWriter m_xml;
        -:10977:        int m_sectionDepth = 0;
        -:10978:    };
        -:10979:
        -:10980:} // end namespace Catch
        -:10981:
        -:10982:#endif // CATCH_REPORTER_XML_HPP_INCLUDED
        -:10983:
        -:10984:#endif // CATCH_REPORTERS_ALL_HPP_INCLUDED
        -:10985:
        -:10986:#endif // CATCH_ALL_HPP_INCLUDED
        -:10987:#endif // CATCH_AMALGAMATED_HPP_INCLUDED
